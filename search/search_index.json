{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to the Digital Clinical Safety Platform (DCSP) App","text":"<p>Streamline and automate clinical safety documentation with our open-source solution.</p>"},{"location":"#about-the-dcsp","title":"About the DCSP","text":"<p>The Digital Clinical Safety Platform (DCSP) is a cutting-edge tool designed to transform the way clinical safety documentation is managed for digital health systems. Built in alignment with clinical safety standards, including DCB0129 and DCB0160, the DCSP empowers users with a seamless, user-friendly interface and state-of-the-art methodologies, including:</p> <ul> <li>Git-based version control for traceability and accountability.</li> <li>Structured hazard typing to streamline risk management.</li> <li>The innovative DevSecRegOps framework for integrating security and compliance.</li> <li>Dynamic and static documentation capabilities.</li> <li>An open-source foundation for transparency and community collaboration.</li> </ul>"},{"location":"#why-choose-the-dcsp","title":"Why Choose the DCSP?","text":"<p>The DCSP is revolutionising clinical safety documentation by:</p> <ul> <li>Reducing manual workflows and minimising errors.</li> <li>Standardising safety documentation for consistency across projects.</li> <li>Enhancing collaboration between developers, clinicians, and regulatory bodies.</li> <li>Providing a cost-efficient, community-driven open-source solution.</li> </ul>"},{"location":"#explore-the-platform","title":"Explore the Platform","text":"<p>The DCSP combines advanced features with an intuitive design to make clinical safety documentation more efficient and reliable. Its capabilities include:</p> <ul> <li>Version-controlled audit trails to track changes.</li> <li>Reusable templates for streamlined documentation.</li> <li>Dynamic interfaces for real-time updates.</li> <li>Static PDF generation for regulatory compliance.</li> </ul> <p>Watch a live demonstration to see the DCSP in action!</p>"},{"location":"#join-the-community","title":"Join the Community","text":"<p>As an open-source platform, the DCSP thrives on collaboration and innovation. We invite developers, clinicians, and stakeholders to contribute, customise, and enhance the platform for the benefit of the global healthcare community. By joining the DCSP ecosystem, you can:</p> <ul> <li>Drive advancements in clinical safety technology</li> <li>Shape the future of digital health systems</li> <li>Access a transparent, flexible, and scalable solution</li> </ul>"},{"location":"#get-started","title":"Get Started","text":"<p>Ready to transform your clinical safety documentation? Visit our GitHub repository to explore the DCSP, download the code, and contribute to the project. Better yet, contact us at dcsp.information@gmail.com to see how we can provide you the service of the DCSP.</p> <p>Together, we can build safer, more efficient digital health systems.</p>"},{"location":"#table-of-contents","title":"Table Of Contents","text":"<ol> <li>Source code</li> <li>Acknowledgements</li> <li>Developers</li> <li>How to develop projects, templates and the DCSP app itself</li> </ol>"},{"location":"acknowledgements/","title":"Acknowledgements","text":"<p>Many thanks are due for Marcus Baw for his work on his cookiecutter-DCB0129 code. Many, if not all of the ideas within this program have been used to create DCSP.</p>"},{"location":"developers/","title":"Developers","text":"<p>The Clinicians-who-code team. Main contributions from:</p> <ul> <li>Mark Bailey</li> <li>Marcus Baw</li> <li>Grant Vallance</li> <li>Joe Channing</li> </ul>"},{"location":"cicd/cicd/","title":"The CICD pipeline","text":""},{"location":"cicd/cicd/#the-following-testing-is-carried-out","title":"The following testing is carried out","text":"<p>The following tests are carried out before the production environment will allow updated code.</p> <ol> <li>Checks all of the necessary enviromental variables have been set.</li> <li>Python code linter via Black linter.</li> <li>Security scan via Bandit.</li> <li>Python type hint check via mypy.</li> <li>Python unit testing via Django's in built tester.</li> <li>Coverage test, needs to be 100% to pass.</li> <li>Template linter check via djLint</li> <li>Push to main branch and then deply to production and create Github pages.</li> </ol> <p>Integration testing needs to be added. This will likely be via Selenium.</p>"},{"location":"code/","title":"DCSP source code","text":"<p>Welcome to the source code documentation of DCSP</p>"},{"location":"code/#table-of-contents","title":"Table Of Contents","text":"<ol> <li>Django</li> <li>Backend functions</li> </ol>"},{"location":"code/#standards-adhered-to","title":"Standards adhered to","text":"<ul> <li>Defensive programming where possible (catching erroneous code early in the script).</li> <li>CICD pipeline with all the bells and whistles.</li> </ul>"},{"location":"code/django/forms/","title":"Forms","text":"<p>Form management for the Django dynamic site app</p> <p>Classes:</p> Name Description <code>InstallationForm</code> <p>placeholder</p> <code>TemplateSelectForm</code> <p>placeholder</p> <code>PlaceholdersForm</code> <p>placeholder</p> <code>DocumentUpdateForm</code> <p>placeholder</p> <code>LogHazardForm</code> <p>placeholder</p> <code>HazardCommentForm</code> <p>placeholder</p> <code>UploadToGithubForm</code> <p>placeholder</p> <p>Functions:</p> Name Description <code>validated_response</code> <p>placeholder</p> <code>md_files</code> <p>placeholder</p>"},{"location":"code/django/forms/#forms.DocumentNewForm","title":"<code>DocumentNewForm</code>","text":"<p>               Bases: <code>Form</code></p> Source code in <code>app/dcsp/app/forms.py</code> <pre><code>class DocumentNewForm(forms.Form):\n    \"\"\" \"\"\"\n\n    def __init__(self, project_id: int, *args: Any, **kwargs: Any) -&gt; None:\n        \"\"\"Initialisation of the selection field\n\n        Searches the docs folder and searches for markdown files, noting the\n        any subfolders. These are then provided as a selection field.\n        \"\"\"\n        super(DocumentNewForm, self).__init__(*args, **kwargs)\n        self.project_id: int = project_id\n\n        self.fields[\"document_name\"] = forms.CharField(\n            help_text=\"This must be a valid path and end in '.md'\",\n            required=True,\n            widget=forms.TextInput(\n                attrs={\n                    \"class\": \"form-control field-color-dcsp font-dcsp border-info\"\n                }\n            ),\n        )\n\n    def clean(self) -&gt; dict[str, Any]:\n        \"\"\"Checks if a valid path\"\"\"\n        cleaned_data: dict[str, Any] = self.cleaned_data\n        document_name: Optional[str] = cleaned_data.get(\"document_name\")\n        valid_1: bool = False\n        valid_2: bool = False\n        error_messages_1: list[str] = []\n        error_messages_2: list[str] = []\n\n        if not document_name:\n            validated_response(\n                self,\n                \"document_name\",\n                False,\n                f\"'document_name' is missing\",\n            )\n            return cleaned_data\n\n        (\n            valid_1,\n            error_messages_1,\n        ) = valid_partial_linux_path(document_name)\n\n        project = project_builder.ProjectBuilder(self.project_id)\n        (\n            valid_2,\n            error_messages_2,\n        ) = project.document_create_check(document_name)\n\n        errors_all = list_to_string(error_messages_1 + error_messages_2)\n\n        validated_response(\n            self,\n            \"document_name\",\n            valid_1 and valid_2,\n            f\"The supplied path is invalid due to: { errors_all }\",\n        )\n\n        return cleaned_data\n</code></pre>"},{"location":"code/django/forms/#forms.DocumentNewForm.__init__","title":"<code>__init__(project_id, *args, **kwargs)</code>","text":"<p>Initialisation of the selection field</p> <p>Searches the docs folder and searches for markdown files, noting the any subfolders. These are then provided as a selection field.</p> Source code in <code>app/dcsp/app/forms.py</code> <pre><code>def __init__(self, project_id: int, *args: Any, **kwargs: Any) -&gt; None:\n    \"\"\"Initialisation of the selection field\n\n    Searches the docs folder and searches for markdown files, noting the\n    any subfolders. These are then provided as a selection field.\n    \"\"\"\n    super(DocumentNewForm, self).__init__(*args, **kwargs)\n    self.project_id: int = project_id\n\n    self.fields[\"document_name\"] = forms.CharField(\n        help_text=\"This must be a valid path and end in '.md'\",\n        required=True,\n        widget=forms.TextInput(\n            attrs={\n                \"class\": \"form-control field-color-dcsp font-dcsp border-info\"\n            }\n        ),\n    )\n</code></pre>"},{"location":"code/django/forms/#forms.DocumentNewForm.clean","title":"<code>clean()</code>","text":"<p>Checks if a valid path</p> Source code in <code>app/dcsp/app/forms.py</code> <pre><code>def clean(self) -&gt; dict[str, Any]:\n    \"\"\"Checks if a valid path\"\"\"\n    cleaned_data: dict[str, Any] = self.cleaned_data\n    document_name: Optional[str] = cleaned_data.get(\"document_name\")\n    valid_1: bool = False\n    valid_2: bool = False\n    error_messages_1: list[str] = []\n    error_messages_2: list[str] = []\n\n    if not document_name:\n        validated_response(\n            self,\n            \"document_name\",\n            False,\n            f\"'document_name' is missing\",\n        )\n        return cleaned_data\n\n    (\n        valid_1,\n        error_messages_1,\n    ) = valid_partial_linux_path(document_name)\n\n    project = project_builder.ProjectBuilder(self.project_id)\n    (\n        valid_2,\n        error_messages_2,\n    ) = project.document_create_check(document_name)\n\n    errors_all = list_to_string(error_messages_1 + error_messages_2)\n\n    validated_response(\n        self,\n        \"document_name\",\n        valid_1 and valid_2,\n        f\"The supplied path is invalid due to: { errors_all }\",\n    )\n\n    return cleaned_data\n</code></pre>"},{"location":"code/django/forms/#forms.DocumentUpdateForm","title":"<code>DocumentUpdateForm</code>","text":"<p>               Bases: <code>Form</code></p> <p>Text edit area of selected markdown file</p> <p>Provides the raw markdown for the selected file.</p> Fields <p>document_name: TODO document_markdown: raw markdown of the file with placeholders evident in double          curley brackets (eg {{ placeholder }})</p> Source code in <code>app/dcsp/app/forms.py</code> <pre><code>class DocumentUpdateForm(forms.Form):\n    \"\"\"Text edit area of selected markdown file\n\n    Provides the raw markdown for the selected file.\n\n    Fields:\n        document_name: TODO\n        document_markdown: raw markdown of the file with placeholders evident in double\n                 curley brackets (eg {{ placeholder }})\n    \"\"\"\n\n    def __init__(\n        self,\n        project_id: int,\n        document_name: str = \"\",\n        *args: Any,\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"Initialisation of the selection field\n\n        Searches the docs folder and searches for markdown files, noting the\n        any subfolders. These are then provided as a selection field.\n        \"\"\"\n        super(DocumentUpdateForm, self).__init__(*args, **kwargs)\n        self.project_id: int = project_id\n        docs_dir: str = f\"{ c.PROJECTS_FOLDER }project_{ project_id }/{ c.CLINICAL_SAFETY_FOLDER }docs/\"\n        initial_data: Mapping[str, str] = self.initial or {}\n        document_markdown: str = \"\"\n\n        # TODO - perhaps a message that docs folder is missing should be presented.\n        if initial_data == {} and document_name == \"\":\n            for _, __, files in os.walk(docs_dir):\n                for name in files:\n                    if fnmatch(name, \"*.md\"):\n                        document_name = name\n                        loop_exit = True\n                        break\n                if loop_exit:\n                    break\n\n            with open(\n                f\"{ docs_dir }{ document_name }\",\n                \"r\",\n            ) as file:\n                document_markdown = file.read()\n                document_markdown = document_markdown.replace(\"\\n\", \"\\r\\n\")\n\n        elif document_name != \"\":\n            if not Path(f\"{ docs_dir }{ document_name }\").is_file():\n                raise FileNotFoundError(f\"File '{ document_name }' not found\")\n\n            with open(\n                f\"{ docs_dir }{ document_name }\",\n                \"r\",\n            ) as file:\n                document_markdown = file.read()\n                document_markdown = document_markdown.replace(\"\\n\", \"\\r\\n\")\n\n        else:\n            document_name = initial_data.get(\"document_name\", \"\")\n            document_markdown = initial_data.get(\"document_markdown\", \"\")\n\n        CHOICES = tuple(md_files(self.project_id))\n\n        self.fields[\"document_name\"] = forms.ChoiceField(\n            choices=CHOICES,\n            initial=document_name,\n            widget=forms.Select(\n                attrs={\n                    \"class\": c.SELECT_STYLE,\n                    \"onChange\": \"form.submit()\",\n                }\n            ),\n        )\n\n        self.fields[\"document_markdown\"] = forms.CharField(\n            label=\"Markdown view\",\n            required=False,\n            initial=document_markdown,\n            widget=forms.Textarea(\n                attrs={\n                    \"style\": \"width:100%; overflow:hidden;\",\n                    \"class\": \"form-control field-color-dcsp font-dcsp border-info\",\n                    \"onkeyup\": \"update_web_view()\",\n                }\n            ),\n        )\n\n        self.fields[\"document_name_initial\"] = forms.CharField(\n            initial=document_name,\n            widget=forms.HiddenInput(attrs={}),\n        )\n\n        self.fields[\"document_markdown_initial\"] = forms.CharField(\n            initial=document_markdown,\n            required=False,\n            widget=forms.HiddenInput(attrs={}),\n        )\n\n    def clean(self) -&gt; dict[str, Any]:\n        \"\"\" \"\"\"\n        cleaned_data: dict[str, Any] = self.cleaned_data\n        \"\"\"document_name: str = cleaned_data[\"document_name\"]\"\"\"\n        # document_markdown: str = cleaned_data[\"document_markdown\"]\n        # md_files_list: list = md_files(self.project_id)\n        # doc_build: Builder\n        linter_results: dict[str, str] = {}\n\n        \"\"\"validated_response(\n            self,\n            \"document_markdown\",\n            document_name in md_files_list,\n            \"Internal error with document_name (hidden attribute)\",\n        )\"\"\"\n\n        \"\"\"# Not, mkdocs directory is not provided as an argument. But this should\n        # Be ok just for linting.\n        doc_build = Builder()\n        linter_results = doc_build.linter_text(document_markdown)\n        results_readable: str = \"\"\"\n\n        \"\"\" if linter_results[\"overal\"] != \"pass\":\n            self.add_error(\"document_markdown\", \"Error with syntax in markdown file\")\"\"\"\n\n        \"\"\"for key, value in linter_results.items():\n            if value == \"pass\":\n                results_readable += f\"{ key }: {value }&lt;/br&gt;\"\n            else:\n                results_readable += f\"&lt;u&gt;{ key }: {value }&lt;/u&gt;&lt;/br&gt;\"\n\n        validated_response(\n            self,\n            \"document_markdown\",\n            linter_results[\"overal\"] == \"pass\",\n            f\"There is invalid syntax in the markdown file, please correct:&lt;/br&gt; { results_readable }\",\n        )\"\"\"\n\n        return cleaned_data\n</code></pre>"},{"location":"code/django/forms/#forms.DocumentUpdateForm.__init__","title":"<code>__init__(project_id, document_name='', *args, **kwargs)</code>","text":"<p>Initialisation of the selection field</p> <p>Searches the docs folder and searches for markdown files, noting the any subfolders. These are then provided as a selection field.</p> Source code in <code>app/dcsp/app/forms.py</code> <pre><code>def __init__(\n    self,\n    project_id: int,\n    document_name: str = \"\",\n    *args: Any,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"Initialisation of the selection field\n\n    Searches the docs folder and searches for markdown files, noting the\n    any subfolders. These are then provided as a selection field.\n    \"\"\"\n    super(DocumentUpdateForm, self).__init__(*args, **kwargs)\n    self.project_id: int = project_id\n    docs_dir: str = f\"{ c.PROJECTS_FOLDER }project_{ project_id }/{ c.CLINICAL_SAFETY_FOLDER }docs/\"\n    initial_data: Mapping[str, str] = self.initial or {}\n    document_markdown: str = \"\"\n\n    # TODO - perhaps a message that docs folder is missing should be presented.\n    if initial_data == {} and document_name == \"\":\n        for _, __, files in os.walk(docs_dir):\n            for name in files:\n                if fnmatch(name, \"*.md\"):\n                    document_name = name\n                    loop_exit = True\n                    break\n            if loop_exit:\n                break\n\n        with open(\n            f\"{ docs_dir }{ document_name }\",\n            \"r\",\n        ) as file:\n            document_markdown = file.read()\n            document_markdown = document_markdown.replace(\"\\n\", \"\\r\\n\")\n\n    elif document_name != \"\":\n        if not Path(f\"{ docs_dir }{ document_name }\").is_file():\n            raise FileNotFoundError(f\"File '{ document_name }' not found\")\n\n        with open(\n            f\"{ docs_dir }{ document_name }\",\n            \"r\",\n        ) as file:\n            document_markdown = file.read()\n            document_markdown = document_markdown.replace(\"\\n\", \"\\r\\n\")\n\n    else:\n        document_name = initial_data.get(\"document_name\", \"\")\n        document_markdown = initial_data.get(\"document_markdown\", \"\")\n\n    CHOICES = tuple(md_files(self.project_id))\n\n    self.fields[\"document_name\"] = forms.ChoiceField(\n        choices=CHOICES,\n        initial=document_name,\n        widget=forms.Select(\n            attrs={\n                \"class\": c.SELECT_STYLE,\n                \"onChange\": \"form.submit()\",\n            }\n        ),\n    )\n\n    self.fields[\"document_markdown\"] = forms.CharField(\n        label=\"Markdown view\",\n        required=False,\n        initial=document_markdown,\n        widget=forms.Textarea(\n            attrs={\n                \"style\": \"width:100%; overflow:hidden;\",\n                \"class\": \"form-control field-color-dcsp font-dcsp border-info\",\n                \"onkeyup\": \"update_web_view()\",\n            }\n        ),\n    )\n\n    self.fields[\"document_name_initial\"] = forms.CharField(\n        initial=document_name,\n        widget=forms.HiddenInput(attrs={}),\n    )\n\n    self.fields[\"document_markdown_initial\"] = forms.CharField(\n        initial=document_markdown,\n        required=False,\n        widget=forms.HiddenInput(attrs={}),\n    )\n</code></pre>"},{"location":"code/django/forms/#forms.DocumentUpdateForm.clean","title":"<code>clean()</code>","text":"Source code in <code>app/dcsp/app/forms.py</code> <pre><code>def clean(self) -&gt; dict[str, Any]:\n    \"\"\" \"\"\"\n    cleaned_data: dict[str, Any] = self.cleaned_data\n    \"\"\"document_name: str = cleaned_data[\"document_name\"]\"\"\"\n    # document_markdown: str = cleaned_data[\"document_markdown\"]\n    # md_files_list: list = md_files(self.project_id)\n    # doc_build: Builder\n    linter_results: dict[str, str] = {}\n\n    \"\"\"validated_response(\n        self,\n        \"document_markdown\",\n        document_name in md_files_list,\n        \"Internal error with document_name (hidden attribute)\",\n    )\"\"\"\n\n    \"\"\"# Not, mkdocs directory is not provided as an argument. But this should\n    # Be ok just for linting.\n    doc_build = Builder()\n    linter_results = doc_build.linter_text(document_markdown)\n    results_readable: str = \"\"\"\n\n    \"\"\" if linter_results[\"overal\"] != \"pass\":\n        self.add_error(\"document_markdown\", \"Error with syntax in markdown file\")\"\"\"\n\n    \"\"\"for key, value in linter_results.items():\n        if value == \"pass\":\n            results_readable += f\"{ key }: {value }&lt;/br&gt;\"\n        else:\n            results_readable += f\"&lt;u&gt;{ key }: {value }&lt;/u&gt;&lt;/br&gt;\"\n\n    validated_response(\n        self,\n        \"document_markdown\",\n        linter_results[\"overal\"] == \"pass\",\n        f\"There is invalid syntax in the markdown file, please correct:&lt;/br&gt; { results_readable }\",\n    )\"\"\"\n\n    return cleaned_data\n</code></pre>"},{"location":"code/django/forms/#forms.EntryUpdateForm","title":"<code>EntryUpdateForm</code>","text":"<p>               Bases: <code>Form</code></p> Source code in <code>app/dcsp/app/forms.py</code> <pre><code>class EntryUpdateForm(forms.Form):\n    def __init__(\n        self,\n        project_id: int,\n        entry_type: str,\n        *args: Any,\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"Initialise the entry form\n\n        Gets available entry labels for entry form\n\n        Fields:\n            horizontal_line: a horizontal line across the web page.\n            TODO:TODO\n        \"\"\"\n        super(EntryUpdateForm, self).__init__(*args, **kwargs)\n        project: project_builder.ProjectBuilder = (\n            project_builder.ProjectBuilder(project_id)\n        )\n        entry_template: list[dict[str, Any]] = project.entry_file_read(\n            entry_type\n        )\n\n        field_type: str = \"\"\n        help_text: str = \"\"\n        self.labels_for_calculations: dict[str, str] = {}\n        labels_for_calculations: dict[str, str] = {}\n        self.calculation_field: list[dict[str, Any]] = []\n\n        for index, field in enumerate(entry_template):\n            help_text = \"\"\n\n            if field[\"field_type\"] == \"horizontal_line\":\n                self.fields[field[\"heading\"]] = forms.CharField(\n                    label=\"\",\n                    required=False,\n                    widget=forms.HiddenInput(attrs={}),\n                )\n\n            elif field[\"field_type\"] == \"new_line\":\n                self.fields[field[\"heading\"]] = forms.CharField(\n                    label=\"\",\n                    required=False,\n                    widget=forms.HiddenInput(attrs={}),\n                )\n\n            elif field[\"field_type\"] == \"icon\":\n                self.fields[field[\"heading\"]] = forms.CharField(\n                    label=\"\",\n                    required=False,\n                    widget=forms.HiddenInput(attrs={}),\n                )\n\n            elif field[\"field_type\"] == \"code\":\n                self.fields[field[\"heading\"]] = forms.CharField(\n                    label=\"\",\n                    required=False,\n                    widget=forms.HiddenInput(attrs={}),\n                )\n\n            elif field[\"field_type\"] == \"select\":\n                help_text = field[\"text\"].replace(\"\\n\", \"&lt;br&gt;\")\n                self.fields[field[\"heading\"]] = forms.ChoiceField(\n                    label=field[\"gui_label\"],\n                    required=False,\n                    choices=field[\"choices\"],\n                    help_text=f\"{index}|{help_text}\",\n                    widget=forms.Select(\n                        attrs={\n                            \"class\": c.SELECT_STYLE,\n                        }\n                    ),\n                )\n\n                if \"labels\" in field:\n                    self.labels_for_calculations[\n                        f\"id_{ field['heading'] }\"\n                    ] = field[\"labels\"]\n\n            elif field[\"field_type\"] == \"multiselect\":\n                help_text = field[\"text\"].replace(\"\\n\", \"&lt;br&gt;\")\n                self.fields[field[\"heading\"]] = forms.MultipleChoiceField(\n                    label=field[\"gui_label\"],\n                    required=False,\n                    choices=field[\"choices\"],\n                    help_text=f\"{index}|{help_text}\",\n                    widget=forms.SelectMultiple(\n                        attrs={\n                            \"class\": \"selectpicker font-dcsp border-info\",\n                            \"multiple\": \"true\",\n                        }\n                    ),\n                )\n\n            elif field[\"field_type\"] == \"calculate\":\n                labels_for_calculations = {}\n\n                help_text = field[\"text\"].replace(\"\\n\", \"&lt;br&gt;\")\n                self.fields[field[\"heading\"]] = forms.CharField(\n                    label=f\"{ field['gui_label'] } (read only)\",\n                    required=False,\n                    help_text=f\"{index}|{help_text}\",\n                    widget=forms.TextInput(\n                        attrs={\n                            \"class\": \"form-control field-color-dcsp font-dcsp border-info no-pointer-cursor\",\n                            \"readonly\": \"readonly\",\n                        }\n                    ),\n                )\n\n                # Match only labels that are required for this calculation field\n                for label in field[\"labels\"]:\n                    for (\n                        key,\n                        value,\n                    ) in self.labels_for_calculations.items():\n                        for label2 in value:\n                            if label2 == label:\n                                labels_for_calculations[key] = value\n\n                self.calculation_field.append(\n                    {\n                        \"id\": f\"id_{ field['heading'] }\",\n                        \"monitor_labels\": labels_for_calculations,\n                        \"choices\": field[\"choices\"],\n                    },\n                )\n\n            elif field[\"field_type\"] == \"readonly\":\n                self.fields[field[\"heading\"]] = forms.CharField(\n                    label=field[\"gui_label\"],\n                    required=False,\n                    widget=ReadOnlyInput(\n                        attrs={\n                            \"class\": \"readonly-field-dcsp\",\n                            \"value\": field[\"text\"],\n                            \"label_class\": heading_level(field[\"heading\"]),\n                        }\n                    ),\n                )\n\n            elif field[\"field_type\"] == \"date\":\n                self.fields[field[\"heading\"]] = forms.DateField(\n                    required=False,\n                    widget=forms.DateInput(\n                        attrs={\n                            \"class\": f\"date-dcsp { c.SELECT_STYLE }\",\n                            \"type\": \"date\",\n                        }\n                    ),\n                )\n\n            elif field[\"field_type\"] == \"text_area\":\n                self.fields[field[\"heading\"]] = forms.CharField(\n                    label=field[\"gui_label\"],\n                    # initial=\"test data\",\n                    required=False,\n                    widget=forms.Textarea(\n                        attrs={\n                            \"class\": \"form-control field-color-dcsp font-dcsp border-info\",\n                            \"rows\": 3,\n                            \"placeholder\": field[\"text\"],\n                        }\n                    ),\n                )\n            else:\n                # TODO #48 - need a soft fail here\n                raise ValueError(\n                    f\"'field_type' has wrong value of '{ field_type }'\"\n                )\n</code></pre>"},{"location":"code/django/forms/#forms.EntryUpdateForm.__init__","title":"<code>__init__(project_id, entry_type, *args, **kwargs)</code>","text":"<p>Initialise the entry form</p> <p>Gets available entry labels for entry form</p> Fields <p>horizontal_line: a horizontal line across the web page. TODO:TODO</p> Source code in <code>app/dcsp/app/forms.py</code> <pre><code>def __init__(\n    self,\n    project_id: int,\n    entry_type: str,\n    *args: Any,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"Initialise the entry form\n\n    Gets available entry labels for entry form\n\n    Fields:\n        horizontal_line: a horizontal line across the web page.\n        TODO:TODO\n    \"\"\"\n    super(EntryUpdateForm, self).__init__(*args, **kwargs)\n    project: project_builder.ProjectBuilder = (\n        project_builder.ProjectBuilder(project_id)\n    )\n    entry_template: list[dict[str, Any]] = project.entry_file_read(\n        entry_type\n    )\n\n    field_type: str = \"\"\n    help_text: str = \"\"\n    self.labels_for_calculations: dict[str, str] = {}\n    labels_for_calculations: dict[str, str] = {}\n    self.calculation_field: list[dict[str, Any]] = []\n\n    for index, field in enumerate(entry_template):\n        help_text = \"\"\n\n        if field[\"field_type\"] == \"horizontal_line\":\n            self.fields[field[\"heading\"]] = forms.CharField(\n                label=\"\",\n                required=False,\n                widget=forms.HiddenInput(attrs={}),\n            )\n\n        elif field[\"field_type\"] == \"new_line\":\n            self.fields[field[\"heading\"]] = forms.CharField(\n                label=\"\",\n                required=False,\n                widget=forms.HiddenInput(attrs={}),\n            )\n\n        elif field[\"field_type\"] == \"icon\":\n            self.fields[field[\"heading\"]] = forms.CharField(\n                label=\"\",\n                required=False,\n                widget=forms.HiddenInput(attrs={}),\n            )\n\n        elif field[\"field_type\"] == \"code\":\n            self.fields[field[\"heading\"]] = forms.CharField(\n                label=\"\",\n                required=False,\n                widget=forms.HiddenInput(attrs={}),\n            )\n\n        elif field[\"field_type\"] == \"select\":\n            help_text = field[\"text\"].replace(\"\\n\", \"&lt;br&gt;\")\n            self.fields[field[\"heading\"]] = forms.ChoiceField(\n                label=field[\"gui_label\"],\n                required=False,\n                choices=field[\"choices\"],\n                help_text=f\"{index}|{help_text}\",\n                widget=forms.Select(\n                    attrs={\n                        \"class\": c.SELECT_STYLE,\n                    }\n                ),\n            )\n\n            if \"labels\" in field:\n                self.labels_for_calculations[\n                    f\"id_{ field['heading'] }\"\n                ] = field[\"labels\"]\n\n        elif field[\"field_type\"] == \"multiselect\":\n            help_text = field[\"text\"].replace(\"\\n\", \"&lt;br&gt;\")\n            self.fields[field[\"heading\"]] = forms.MultipleChoiceField(\n                label=field[\"gui_label\"],\n                required=False,\n                choices=field[\"choices\"],\n                help_text=f\"{index}|{help_text}\",\n                widget=forms.SelectMultiple(\n                    attrs={\n                        \"class\": \"selectpicker font-dcsp border-info\",\n                        \"multiple\": \"true\",\n                    }\n                ),\n            )\n\n        elif field[\"field_type\"] == \"calculate\":\n            labels_for_calculations = {}\n\n            help_text = field[\"text\"].replace(\"\\n\", \"&lt;br&gt;\")\n            self.fields[field[\"heading\"]] = forms.CharField(\n                label=f\"{ field['gui_label'] } (read only)\",\n                required=False,\n                help_text=f\"{index}|{help_text}\",\n                widget=forms.TextInput(\n                    attrs={\n                        \"class\": \"form-control field-color-dcsp font-dcsp border-info no-pointer-cursor\",\n                        \"readonly\": \"readonly\",\n                    }\n                ),\n            )\n\n            # Match only labels that are required for this calculation field\n            for label in field[\"labels\"]:\n                for (\n                    key,\n                    value,\n                ) in self.labels_for_calculations.items():\n                    for label2 in value:\n                        if label2 == label:\n                            labels_for_calculations[key] = value\n\n            self.calculation_field.append(\n                {\n                    \"id\": f\"id_{ field['heading'] }\",\n                    \"monitor_labels\": labels_for_calculations,\n                    \"choices\": field[\"choices\"],\n                },\n            )\n\n        elif field[\"field_type\"] == \"readonly\":\n            self.fields[field[\"heading\"]] = forms.CharField(\n                label=field[\"gui_label\"],\n                required=False,\n                widget=ReadOnlyInput(\n                    attrs={\n                        \"class\": \"readonly-field-dcsp\",\n                        \"value\": field[\"text\"],\n                        \"label_class\": heading_level(field[\"heading\"]),\n                    }\n                ),\n            )\n\n        elif field[\"field_type\"] == \"date\":\n            self.fields[field[\"heading\"]] = forms.DateField(\n                required=False,\n                widget=forms.DateInput(\n                    attrs={\n                        \"class\": f\"date-dcsp { c.SELECT_STYLE }\",\n                        \"type\": \"date\",\n                    }\n                ),\n            )\n\n        elif field[\"field_type\"] == \"text_area\":\n            self.fields[field[\"heading\"]] = forms.CharField(\n                label=field[\"gui_label\"],\n                # initial=\"test data\",\n                required=False,\n                widget=forms.Textarea(\n                    attrs={\n                        \"class\": \"form-control field-color-dcsp font-dcsp border-info\",\n                        \"rows\": 3,\n                        \"placeholder\": field[\"text\"],\n                    }\n                ),\n            )\n        else:\n            # TODO #48 - need a soft fail here\n            raise ValueError(\n                f\"'field_type' has wrong value of '{ field_type }'\"\n            )\n</code></pre>"},{"location":"code/django/forms/#forms.HazardCommentForm","title":"<code>HazardCommentForm</code>","text":"<p>               Bases: <code>Form</code></p> <p>Form for adding comments to a preexisting hazard</p> <p>A simple form to add a comment to a pre-existing hazard.</p> Fields <p>comment: a new comment for the hazard.</p> Source code in <code>app/dcsp/app/forms.py</code> <pre><code>class HazardCommentForm(forms.Form):\n    \"\"\"Form for adding comments to a preexisting hazard\n\n    A simple form to add a comment to a pre-existing hazard.\n\n    Fields:\n        comment: a new comment for the hazard.\n    \"\"\"\n\n    comment = forms.CharField(\n        widget=forms.Textarea(\n            attrs={\n                \"class\": \"form-control field-color-dcsp font-dcsp border-info\",\n                \"style\": \"height: 500px\",\n                \"onkeyup\": \"update_web_view()\",\n            }\n        ),\n    )\n</code></pre>"},{"location":"code/django/forms/#forms.PlaceholdersForm","title":"<code>PlaceholdersForm</code>","text":"<p>               Bases: <code>Form</code></p> <p>Creates fields for all available placeholders</p> <p>Searches through the docs folder in mkdocs for markdown files. If a placeholder is found, then this is made available for the user to provide a value for.</p> <p>Methods:</p> Name Description <code>clean</code> <p>placeholder</p> Fields <p>[Automatically created]</p> Source code in <code>app/dcsp/app/forms.py</code> <pre><code>class PlaceholdersForm(forms.Form):\n    \"\"\"Creates fields for all available placeholders\n\n    Searches through the docs folder in mkdocs for markdown files. If a\n    placeholder is found, then this is made available for the user to provide a\n    value for.\n\n    Methods:\n        clean: placeholder\n\n    Fields:\n        [Automatically created]\n    \"\"\"\n\n    def __init__(self, project_id: int, *args: Any, **kwargs: Any) -&gt; None:\n        \"\"\"Find placeholders and initialises web app fields\n\n        Searches for placeholders in markdown files in doc folder and creates\n        fields for each.\n        \"\"\"\n        super(PlaceholdersForm, self).__init__(*args, **kwargs)\n        placeholders: dict[str, str] = {}\n        placeholder: str = \"\"\n        value: str = \"\"\n\n        project_build = project_builder.ProjectBuilder(project_id)\n        placeholders = project_build.get_placeholders()\n\n        for (\n            placeholder,\n            value,\n        ) in placeholders.items():\n            self.fields[placeholder] = forms.CharField(\n                required=False,\n                initial=value,\n                widget=forms.TextInput(\n                    attrs={\n                        \"class\": \"form-control field-color-dcsp font-dcsp border-info\"\n                    }\n                ),\n            )\n\n    def clean(self) -&gt; dict[str, Any]:\n        \"\"\"Checks placeholders for invalid characters\n\n        Current invalid characters are \"{}\\\"'\"\n        \"\"\"\n        INVALID_CHARACTERS: str = \"{}\\\"'\"\n        cleaned_data: dict[str, Any] = self.cleaned_data.copy()\n        key: str = \"\"\n        value: str = \"\"\n\n        for key, value in cleaned_data.items():\n            validated_response(\n                self,\n                key,\n                not any(illegal in value for illegal in INVALID_CHARACTERS),\n                f\"Invalid character in placeholder '{ key }' - '{ value }'\",\n            )\n\n        return cleaned_data\n</code></pre>"},{"location":"code/django/forms/#forms.PlaceholdersForm.__init__","title":"<code>__init__(project_id, *args, **kwargs)</code>","text":"<p>Find placeholders and initialises web app fields</p> <p>Searches for placeholders in markdown files in doc folder and creates fields for each.</p> Source code in <code>app/dcsp/app/forms.py</code> <pre><code>def __init__(self, project_id: int, *args: Any, **kwargs: Any) -&gt; None:\n    \"\"\"Find placeholders and initialises web app fields\n\n    Searches for placeholders in markdown files in doc folder and creates\n    fields for each.\n    \"\"\"\n    super(PlaceholdersForm, self).__init__(*args, **kwargs)\n    placeholders: dict[str, str] = {}\n    placeholder: str = \"\"\n    value: str = \"\"\n\n    project_build = project_builder.ProjectBuilder(project_id)\n    placeholders = project_build.get_placeholders()\n\n    for (\n        placeholder,\n        value,\n    ) in placeholders.items():\n        self.fields[placeholder] = forms.CharField(\n            required=False,\n            initial=value,\n            widget=forms.TextInput(\n                attrs={\n                    \"class\": \"form-control field-color-dcsp font-dcsp border-info\"\n                }\n            ),\n        )\n</code></pre>"},{"location":"code/django/forms/#forms.PlaceholdersForm.clean","title":"<code>clean()</code>","text":"<p>Checks placeholders for invalid characters</p> <p>Current invalid characters are \"{}\"'\"</p> Source code in <code>app/dcsp/app/forms.py</code> <pre><code>def clean(self) -&gt; dict[str, Any]:\n    \"\"\"Checks placeholders for invalid characters\n\n    Current invalid characters are \"{}\\\"'\"\n    \"\"\"\n    INVALID_CHARACTERS: str = \"{}\\\"'\"\n    cleaned_data: dict[str, Any] = self.cleaned_data.copy()\n    key: str = \"\"\n    value: str = \"\"\n\n    for key, value in cleaned_data.items():\n        validated_response(\n            self,\n            key,\n            not any(illegal in value for illegal in INVALID_CHARACTERS),\n            f\"Invalid character in placeholder '{ key }' - '{ value }'\",\n        )\n\n    return cleaned_data\n</code></pre>"},{"location":"code/django/forms/#forms.ProjectSetupInitialForm","title":"<code>ProjectSetupInitialForm</code>","text":"<p>               Bases: <code>Form</code></p> <p>Setup a project</p> Source code in <code>app/dcsp/app/forms.py</code> <pre><code>class ProjectSetupInitialForm(forms.Form):\n    \"\"\"Setup a project\"\"\"\n\n    CHOICES_1 = (\n        (\"\", \"\"),\n        (\n            \"import\",\n            \"Import from external source\",\n        ),\n        (\n            \"start_anew\",\n            \"Start a new project from scratch\",\n        ),\n    )\n\n    setup_choice = forms.ChoiceField(\n        choices=CHOICES_1,\n        widget=forms.Select(\n            attrs={\n                \"class\": c.SELECT_STYLE,\n                \"onChange\": \"change_visibility()\",\n            }\n        ),\n    )\n\n    external_repository_url_import = forms.CharField(\n        label=\"Respository URL\",\n        required=False,\n        widget=forms.TextInput(\n            attrs={\n                \"class\": f\"form-control field-color-dcsp font-dcsp border-info { c.FORM_ELEMENTS_MAX_WIDTH }\",\n                \"autocomplete\": \"url\",\n            }\n        ),\n    )\n\n    external_repository_username_import = forms.CharField(\n        label=\"Respository username\",\n        required=False,\n        widget=forms.TextInput(\n            attrs={\n                \"class\": f\"form-control field-color-dcsp font-dcsp border-info { c.FORM_ELEMENTS_MAX_WIDTH }\",\n                \"autocomplete\": \"username\",\n            }\n        ),\n    )\n\n    external_repository_password_token_import = forms.CharField(\n        label=\"Repository token\",\n        help_text=\"You can get your Github &lt;a class='link-dcsp' href='https://github.com/settings/tokens/new' target='_blank'&gt; token here&lt;/a&gt;\",\n        required=False,\n        widget=forms.PasswordInput(\n            attrs={\n                \"class\": f\"form-control field-color-dcsp font-dcsp border-info { c.FORM_ELEMENTS_MAX_WIDTH }\",\n                \"autocomplete\": \"current-password\",\n            }\n        ),\n    )\n\n    def clean(self) -&gt; dict[str, str]:\n        \"\"\" \"\"\"\n        cleaned_data: dict[str, str] = self.cleaned_data\n        setup_choice: str = cleaned_data[\"setup_choice\"]\n        external_repository_url_import: str = cleaned_data[\n            \"external_repository_url_import\"\n        ]\n\n        if setup_choice == \"start_anew\":\n            cleaned_data.pop(\"external_repository_url_import\", None)\n            cleaned_data.pop(\"external_repository_username_import\", None)\n            cleaned_data.pop(\"external_repository_password_token_import\", None)\n        else:\n            validated_response(\n                self,\n                \"external_repository_url_import\",\n                not \" \" in external_repository_url_import,\n                \"Spaces are not allowed in a url\",\n            )\n\n        return cleaned_data\n</code></pre>"},{"location":"code/django/forms/#forms.ProjectSetupInitialForm.clean","title":"<code>clean()</code>","text":"Source code in <code>app/dcsp/app/forms.py</code> <pre><code>def clean(self) -&gt; dict[str, str]:\n    \"\"\" \"\"\"\n    cleaned_data: dict[str, str] = self.cleaned_data\n    setup_choice: str = cleaned_data[\"setup_choice\"]\n    external_repository_url_import: str = cleaned_data[\n        \"external_repository_url_import\"\n    ]\n\n    if setup_choice == \"start_anew\":\n        cleaned_data.pop(\"external_repository_url_import\", None)\n        cleaned_data.pop(\"external_repository_username_import\", None)\n        cleaned_data.pop(\"external_repository_password_token_import\", None)\n    else:\n        validated_response(\n            self,\n            \"external_repository_url_import\",\n            not \" \" in external_repository_url_import,\n            \"Spaces are not allowed in a url\",\n        )\n\n    return cleaned_data\n</code></pre>"},{"location":"code/django/forms/#forms.ProjectSetupStepTwoForm","title":"<code>ProjectSetupStepTwoForm</code>","text":"<p>               Bases: <code>Form</code></p> <p>ProjectSetupStepTwoForm</p> Fields <p>project_name_import_start_anew: name of the project</p> Source code in <code>app/dcsp/app/forms.py</code> <pre><code>class ProjectSetupStepTwoForm(forms.Form):\n    \"\"\"ProjectSetupStepTwoForm\n\n    Fields:\n        project_name_import_start_anew: name of the project\n    \"\"\"\n\n    def __init__(self, *args: Any, **kwargs: Any) -&gt; None:\n        \"\"\"Initialise the fields for the second step of project setup\"\"\"\n        super(ProjectSetupStepTwoForm, self).__init__(*args, **kwargs)\n        groups_list: QuerySet[Any] = ProjectGroup.objects.none()\n        choices_list_1: list[Any] = []\n        choices_list_2: list[Any] = []\n\n        self.fields[\"project_name\"] = forms.CharField(\n            label=\"Project name\",\n            required=True,\n            widget=forms.TextInput(\n                attrs={\n                    \"class\": f\"form-control field-color-dcsp font-dcsp border-info { c.FORM_ELEMENTS_MAX_WIDTH }\",\n                    \"autocomplete\": \"off\",\n                }\n            ),\n        )\n\n        self.fields[\"description\"] = forms.CharField(\n            required=True,\n            widget=forms.Textarea(\n                attrs={\n                    \"class\": f\"form-control field-color-dcsp font-dcsp border-info { c.FORM_ELEMENTS_MAX_WIDTH }\",\n                    \"rows\": 3,\n                    \"autocomplete\": \"off\",\n                }\n            ),\n        )\n\n        self.fields[\"access\"] = forms.ChoiceField(\n            choices=ViewAccess.choices,\n            initial=ViewAccess.PUBLIC,\n            widget=forms.Select(\n                attrs={\n                    \"class\": c.SELECT_STYLE,\n                    \"onChange\": \"change_visibility()\",\n                }\n            ),\n        )\n\n        groups_list = ProjectGroup.objects.values(\"id\", \"name\")\n\n        for group in groups_list:\n            choices_list_1.append([group[\"id\"], group[\"name\"]])\n\n        CHOICES_1 = tuple(choices_list_1)\n\n        self.fields[\"groups\"] = forms.MultipleChoiceField(\n            label=\"Group select\",\n            help_text=\"Press CTRL or Command (&amp;#8984;) to select multiple groups\",\n            required=False,\n            choices=CHOICES_1,\n            widget=forms.SelectMultiple(\n                attrs={\n                    \"class\": \"form-select w-auto\",\n                    # \"style\": \"height: 80px\",\n                }\n            ),\n        )\n\n        # TODO #40 - will need to figure out who you can see to add (some people may want to have membership hidden)\n        members_list = User.objects.values(\"id\", \"first_name\", \"last_name\")\n\n        for member in members_list:\n            choices_list_2.append(\n                [\n                    member[\"id\"],\n                    f\"{ member['first_name']} { member['last_name']}\",\n                ]\n            )\n\n        CHOICES_2 = tuple(choices_list_2)\n\n        self.fields[\"members\"] = forms.MultipleChoiceField(\n            label=\"Add members \",\n            help_text=\"Press CTRL or Command (&amp;#8984;) to select multiple members\",\n            required=False,\n            choices=CHOICES_2,\n            widget=forms.SelectMultiple(\n                attrs={\n                    \"class\": \"form-select w-auto\",\n                    # \"style\": \"height: 80px\",\n                }\n            ),\n        )\n</code></pre>"},{"location":"code/django/forms/#forms.ProjectSetupStepTwoForm.__init__","title":"<code>__init__(*args, **kwargs)</code>","text":"<p>Initialise the fields for the second step of project setup</p> Source code in <code>app/dcsp/app/forms.py</code> <pre><code>def __init__(self, *args: Any, **kwargs: Any) -&gt; None:\n    \"\"\"Initialise the fields for the second step of project setup\"\"\"\n    super(ProjectSetupStepTwoForm, self).__init__(*args, **kwargs)\n    groups_list: QuerySet[Any] = ProjectGroup.objects.none()\n    choices_list_1: list[Any] = []\n    choices_list_2: list[Any] = []\n\n    self.fields[\"project_name\"] = forms.CharField(\n        label=\"Project name\",\n        required=True,\n        widget=forms.TextInput(\n            attrs={\n                \"class\": f\"form-control field-color-dcsp font-dcsp border-info { c.FORM_ELEMENTS_MAX_WIDTH }\",\n                \"autocomplete\": \"off\",\n            }\n        ),\n    )\n\n    self.fields[\"description\"] = forms.CharField(\n        required=True,\n        widget=forms.Textarea(\n            attrs={\n                \"class\": f\"form-control field-color-dcsp font-dcsp border-info { c.FORM_ELEMENTS_MAX_WIDTH }\",\n                \"rows\": 3,\n                \"autocomplete\": \"off\",\n            }\n        ),\n    )\n\n    self.fields[\"access\"] = forms.ChoiceField(\n        choices=ViewAccess.choices,\n        initial=ViewAccess.PUBLIC,\n        widget=forms.Select(\n            attrs={\n                \"class\": c.SELECT_STYLE,\n                \"onChange\": \"change_visibility()\",\n            }\n        ),\n    )\n\n    groups_list = ProjectGroup.objects.values(\"id\", \"name\")\n\n    for group in groups_list:\n        choices_list_1.append([group[\"id\"], group[\"name\"]])\n\n    CHOICES_1 = tuple(choices_list_1)\n\n    self.fields[\"groups\"] = forms.MultipleChoiceField(\n        label=\"Group select\",\n        help_text=\"Press CTRL or Command (&amp;#8984;) to select multiple groups\",\n        required=False,\n        choices=CHOICES_1,\n        widget=forms.SelectMultiple(\n            attrs={\n                \"class\": \"form-select w-auto\",\n                # \"style\": \"height: 80px\",\n            }\n        ),\n    )\n\n    # TODO #40 - will need to figure out who you can see to add (some people may want to have membership hidden)\n    members_list = User.objects.values(\"id\", \"first_name\", \"last_name\")\n\n    for member in members_list:\n        choices_list_2.append(\n            [\n                member[\"id\"],\n                f\"{ member['first_name']} { member['last_name']}\",\n            ]\n        )\n\n    CHOICES_2 = tuple(choices_list_2)\n\n    self.fields[\"members\"] = forms.MultipleChoiceField(\n        label=\"Add members \",\n        help_text=\"Press CTRL or Command (&amp;#8984;) to select multiple members\",\n        required=False,\n        choices=CHOICES_2,\n        widget=forms.SelectMultiple(\n            attrs={\n                \"class\": \"form-select w-auto\",\n                # \"style\": \"height: 80px\",\n            }\n        ),\n    )\n</code></pre>"},{"location":"code/django/forms/#forms.TemplateSelectForm","title":"<code>TemplateSelectForm</code>","text":"<p>               Bases: <code>Form</code></p> <p>Template selection form</p> <p>Provides available templates.</p> Fields <p>template_choice: pick the template to use for hazard documentation.</p> Source code in <code>app/dcsp/app/forms.py</code> <pre><code>class TemplateSelectForm(forms.Form):\n    \"\"\"Template selection form\n\n    Provides available templates.\n\n    Fields:\n        template_choice: pick the template to use for hazard documentation.\n    \"\"\"\n\n    def __init__(self, project_id: int, *args: Any, **kwargs: Any) -&gt; None:\n        \"\"\"Initialise with available templates\n\n        Searches in the templates folder for template sub-folders and provides\n        these as options in a selection field for the user.\n        \"\"\"\n        super(TemplateSelectForm, self).__init__(*args, **kwargs)\n        project: project_builder.ProjectBuilder = (\n            project_builder.ProjectBuilder(project_id)\n        )\n        templates: list[str] = project.master_template_get()\n        template: str = \"\"\n        choices_list: list[Any] = []\n\n        if len(templates) == 0:\n            raise Exception(\"No templates found in templates folder!\")\n\n        for template in templates:\n            choices_list.append([template, template])\n\n        CHOICES = tuple(choices_list)\n\n        self.fields[\"template_choice\"] = forms.ChoiceField(\n            choices=CHOICES,\n            widget=forms.Select(attrs={\"class\": c.SELECT_STYLE}),\n        )\n</code></pre>"},{"location":"code/django/forms/#forms.TemplateSelectForm.__init__","title":"<code>__init__(project_id, *args, **kwargs)</code>","text":"<p>Initialise with available templates</p> <p>Searches in the templates folder for template sub-folders and provides these as options in a selection field for the user.</p> Source code in <code>app/dcsp/app/forms.py</code> <pre><code>def __init__(self, project_id: int, *args: Any, **kwargs: Any) -&gt; None:\n    \"\"\"Initialise with available templates\n\n    Searches in the templates folder for template sub-folders and provides\n    these as options in a selection field for the user.\n    \"\"\"\n    super(TemplateSelectForm, self).__init__(*args, **kwargs)\n    project: project_builder.ProjectBuilder = (\n        project_builder.ProjectBuilder(project_id)\n    )\n    templates: list[str] = project.master_template_get()\n    template: str = \"\"\n    choices_list: list[Any] = []\n\n    if len(templates) == 0:\n        raise Exception(\"No templates found in templates folder!\")\n\n    for template in templates:\n        choices_list.append([template, template])\n\n    CHOICES = tuple(choices_list)\n\n    self.fields[\"template_choice\"] = forms.ChoiceField(\n        choices=CHOICES,\n        widget=forms.Select(attrs={\"class\": c.SELECT_STYLE}),\n    )\n</code></pre>"},{"location":"code/django/forms/#forms.UploadToGithubForm","title":"<code>UploadToGithubForm</code>","text":"<p>               Bases: <code>Form</code></p> <p>Add comment for commit</p> <p>Form to add comment to then add to commit and then push to GitHub</p> Fields <p>comment</p> Source code in <code>app/dcsp/app/forms.py</code> <pre><code>class UploadToGithubForm(forms.Form):\n    \"\"\"Add comment for commit\n\n    Form to add comment to then add to commit and then push to GitHub\n\n    Fields:\n        comment\n    \"\"\"\n\n    comment = forms.CharField(\n        widget=forms.Textarea(\n            attrs={\n                \"class\": \"form-control field-color-dcsp font-dcsp border-info\",\n                \"style\": \"height: 150px\",\n            }\n        ),\n    )\n</code></pre>"},{"location":"code/django/forms/#forms.heading_level","title":"<code>heading_level(heading)</code>","text":"<p>Determine the heading level</p> <p>Parameters:</p> Name Type Description Default <code>heading</code> <code>str</code> <p>heading to check</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>the heading css class</p> Source code in <code>app/dcsp/app/forms.py</code> <pre><code>def heading_level(heading: str) -&gt; str:\n    \"\"\"Determine the heading level\n\n    Args:\n        heading: heading to check\n\n    Returns:\n        str: the heading css class\n    \"\"\"\n    if heading.startswith(\"# \"):\n        return \"h1-dcsp\"\n    elif heading.startswith(\"## \"):\n        return \"h2-dcsp\"\n    elif heading.startswith(\"### \"):\n        return \"h3-dcsp\"\n    elif heading.startswith(\"#### \"):\n        return \"h4-dcsp\"\n    else:\n        return \"h5-dcsp\"\n</code></pre>"},{"location":"code/django/forms/#forms.md_files","title":"<code>md_files(project_id)</code>","text":"<p>Finds markdown files</p> <p>Looks for markdown files in MKDOCS_PATH. Returns a list of paths.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>int</code> <p>project database id number</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>list[tuple[Any, Any]]</code> <p>list of paths of markdown files relative to MKDOCS_PATH</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>if the docs location is not a valid directory</p> Source code in <code>app/dcsp/app/forms.py</code> <pre><code>def md_files(project_id: int) -&gt; list[tuple[Any, Any]]:\n    \"\"\"Finds markdown files\n\n    Looks for markdown files in MKDOCS_PATH. Returns a list of paths.\n\n    Args:\n        project_id (int): project database id number\n\n    Returns:\n        list: list of paths of markdown files relative to MKDOCS_PATH\n\n    Raises:\n        FileNotFoundError: if the docs location is not a valid directory\n    \"\"\"\n    md_files: list[Any] = []\n    file: Any = \"\"\n    choices_list: list[tuple[Any, Any]] = []\n\n    project: project_builder.ProjectBuilder = project_builder.ProjectBuilder(\n        project_id\n    )\n    md_files = project.documents_list()\n\n    for file in md_files:\n        choices_list.append((file, file))\n\n    return choices_list\n</code></pre>"},{"location":"code/django/forms/#forms.validated_response","title":"<code>validated_response(self, field, valid, error_message)</code>","text":"<p>A general function to create form validation results</p> <p>Provides the field class and error messages to work with Bootstrap.</p> <p>Parameters:</p> Name Type Description Default <code>field</code> <code>str</code> <p>name of field.</p> required <code>valid</code> <code>bool</code> <p>if the validation of the field passes, True = passes, False = does    not pass.</p> required <code>error_message</code> <code>str</code> <p>message to display if data does not pass validation.</p> required Source code in <code>app/dcsp/app/forms.py</code> <pre><code>def validated_response(  # type: ignore[no-untyped-def]\n    self,\n    field: str,\n    valid: bool,\n    error_message: str,\n) -&gt; None:\n    \"\"\"A general function to create form validation results\n\n    Provides the field class and error messages to work with Bootstrap.\n\n    Args:\n        field: name of field.\n        valid: if the validation of the field passes, True = passes, False = does\n               not pass.\n        error_message: message to display if data does not pass validation.\n    \"\"\"\n    if valid:\n        self.fields[field].widget.attrs[\n            \"class\"\n        ] = f\"form-control is-valid { c.FORM_ELEMENTS_MAX_WIDTH }\"\n    else:\n        self.add_error(field, error_message)\n        self.fields[field].widget.attrs[\n            \"class\"\n        ] = f\"form-control is-invalid { c.FORM_ELEMENTS_MAX_WIDTH }\"\n    return\n</code></pre>"},{"location":"code/django/models/","title":"Models","text":"<p>Django Models </p> <p>Models for the DCPS app.</p> <p>Functions:</p> Name Description <code>project_timestamp</code> <p>Updates the last_modified timestamp of a project if it exists.</p> Enumerations <p>ViewAccess: Enumeration for view access levels.</p> Models <p>UserProfile: A user profile model. Project: Project model. UserProjectAttribute: A user project attribute model. ProjectGroup: A project group model.</p>"},{"location":"code/django/models/#models.ViewAccess","title":"<code>ViewAccess</code>","text":"<p>               Bases: <code>TextChoices</code></p> <p>Enumeration for view access levels.</p> <p>Attributes: PRIVATE: Represents a private access level. MEMBERS: Represents an access level for members only. PUBLIC: Represents a public access level.</p> Source code in <code>app/dcsp/app/models.py</code> <pre><code>class ViewAccess(TextChoices):\n    \"\"\"\n    Enumeration for view access levels.\n\n    Attributes:\n    PRIVATE: Represents a private access level.\n    MEMBERS: Represents an access level for members only.\n    PUBLIC: Represents a public access level.\n    \"\"\"\n\n    PRIVATE = \"PR\", \"private\"\n    MEMBERS = \"ME\", \"members\"\n    PUBLIC = \"PU\", \"public\"\n\n    # TODO #61 need to test this\n    @classmethod\n    def get_label(cls, choice: str) -&gt; str:\n        return cls(choice).label\n</code></pre>"},{"location":"code/django/models/#models.project_timestamp","title":"<code>project_timestamp(project_id)</code>","text":"<p>Updates the last_modified timestamp of a project if it exists.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>int</code> <p>The id of the project to update.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the project exists and was updated, False otherwise.</p> Source code in <code>app/dcsp/app/models.py</code> <pre><code>def project_timestamp(project_id: int) -&gt; bool:\n    \"\"\"Updates the last_modified timestamp of a project if it exists.\n\n    Args:\n        project_id (int): The id of the project to update.\n\n    Returns:\n        bool: True if the project exists and was updated, False otherwise.\n    \"\"\"\n    project: Optional[Project] = None\n\n    if not isinstance(project_id, int):\n        raise TypeError(\"project_id must be an integer\")\n\n    if not Project.objects.filter(id=project_id).exists():\n        return False\n\n    project = Project.objects.get(id=project_id)\n    project.last_modified = timezone.now()\n    project.save()\n    return True\n</code></pre>"},{"location":"code/django/views/","title":"Views","text":"<p>Manages the views for the DCSP app</p> <p>This is part of a Django web server app that is used to create a static site in mkdocs.</p> <p>Functions:</p> Name Description <code>index</code> <p>landing page for DCSP app, redirects logged members.</p> <code>member_landing_page</code> <p>landing page for logged in members</p> <code>start_new_project</code> <p>start a new project, import from git or from clean slate.</p> <code>setup_documents</code> <p>build up the documents for the static site.</p> <code>project_build_asap</code> <p>build the static site ad hoc</p> <code>project_documents</code> <p>main page for document editing.</p> <code>view_docs</code> <p>provides static site via NGINX X-Accel-Redirect</p> <code>document_new</code> <p>create a new document.</p> <code>document_update</code> <p>edit of main documents.</p> <code>entry_update</code> <p>create a new entry or update a preexisting one.</p> <code>entry_select</code> <p>select an entry file to edit.</p> <code>upload_to_external_repository</code> <p>git commit and push project to external                             repository.</p> <code>std_context</code> <p>provides a standard collection of values for views.</p> <code>user_accessible_projects</code> <p>provides a list of projects a user has access to.</p> <code>placeholders</code> <p>gets placeholders (used in document_update to convert           placeholders to their values).</p> <code>build_documents</code> <p>builds the static webpages via mkdocs.</p> <code>custom_400</code> <p>custom 400 (bad request) page.</p> <code>custom_403</code> <p>custom 403 (forbidden) page.</p> <code>custom_404</code> <p>custom 404 (not found) page.</p> <code>custom_500</code> <p>custom 500 (internal server error) page.</p>"},{"location":"code/django/views/#views.custom_400","title":"<code>custom_400(request, exception=None)</code>","text":"<p>Custom 400 - bad request page</p> <p>Custom 400 page for bad request.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>HttpRequest</code> <p>request from user</p> required <p>Returns:</p> Name Type Description <code>HttpResponse</code> <code>HttpResponse</code> <p>for loading the correct webpage</p> Source code in <code>app/dcsp/app/views.py</code> <pre><code>def custom_400(\n    request: HttpRequest, exception: Optional[Exception] = None\n) -&gt; HttpResponse:\n    \"\"\"Custom 400 - bad request page\n\n    Custom 400 page for bad request.\n\n    Args:\n        request (HttpRequest): request from user\n\n    Returns:\n        HttpResponse: for loading the correct webpage\n    \"\"\"\n\n    context: dict[str, Any] = {\"page_title\": \"400 - Bad request\"}\n\n    return render(\n        request, \"error_handler.html\", context | std_context(), status=400\n    )\n</code></pre>"},{"location":"code/django/views/#views.custom_403","title":"<code>custom_403(request, exception=None)</code>","text":"<p>Custom 403 - access forbidden page</p> <p>Custom 403 page for access forbidden</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>HttpRequest</code> <p>request from user</p> required <p>Returns:</p> Name Type Description <code>HttpResponse</code> <code>HttpResponse</code> <p>for loading the correct webpage</p> Source code in <code>app/dcsp/app/views.py</code> <pre><code>def custom_403(\n    request: HttpRequest, exception: Optional[Exception] = None\n) -&gt; HttpResponse:\n    \"\"\"Custom 403 - access forbidden page\n\n    Custom 403 page for access forbidden\n\n    Args:\n        request (HttpRequest): request from user\n\n    Returns:\n        HttpResponse: for loading the correct webpage\n    \"\"\"\n\n    context: dict[str, Any] = {\"page_title\": \"403 - Forbidden access\"}\n\n    return render(\n        request, \"error_handler.html\", context | std_context(), status=403\n    )\n</code></pre>"},{"location":"code/django/views/#views.custom_403_csrf","title":"<code>custom_403_csrf(request, reason=None)</code>","text":"<p>Custom 403 - CSRF page</p> <p>Custom 403 access forbidden when CRSF triggered.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>HttpRequest</code> <p>request from user</p> required <p>Returns:</p> Name Type Description <code>HttpResponse</code> <code>HttpResponse</code> <p>for loading the correct webpage</p> Source code in <code>app/dcsp/app/views.py</code> <pre><code>def custom_403_csrf(request: HttpRequest, reason: Any = None) -&gt; HttpResponse:\n    \"\"\"Custom 403 - CSRF page\n\n    Custom 403 access forbidden when CRSF triggered.\n\n    Args:\n        request (HttpRequest): request from user\n\n    Returns:\n        HttpResponse: for loading the correct webpage\n    \"\"\"\n    return custom_403(request)\n</code></pre>"},{"location":"code/django/views/#views.custom_404","title":"<code>custom_404(request, exception=None)</code>","text":"<p>Custom 404 page - page not found</p> <p>Custom page not found.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>HttpRequest</code> <p>request from user</p> required <p>Returns:</p> Name Type Description <code>HttpResponse</code> <code>HttpResponse</code> <p>for loading the correct webpage</p> Source code in <code>app/dcsp/app/views.py</code> <pre><code>def custom_404(\n    request: HttpRequest, exception: Optional[Exception] = None\n) -&gt; HttpResponse:\n    \"\"\"Custom 404 page - page not found\n\n    Custom page not found.\n\n    Args:\n        request (HttpRequest): request from user\n\n    Returns:\n        HttpResponse: for loading the correct webpage\n    \"\"\"\n    context: dict[str, Any] = {\"page_title\": \"404 - Page not found\"}\n\n    return render(\n        request, \"error_handler.html\", context | std_context(), status=404\n    )\n</code></pre>"},{"location":"code/django/views/#views.custom_405","title":"<code>custom_405(request, exception=None)</code>","text":"<p>Custom 405 page - method not allowed</p> <p>Custom page method not allowed</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>HttpRequest</code> <p>request from user</p> required <p>Returns:</p> Name Type Description <code>HttpResponse</code> <code>HttpResponse</code> <p>for loading the correct webpage</p> Source code in <code>app/dcsp/app/views.py</code> <pre><code>def custom_405(\n    request: HttpRequest, exception: Optional[Exception] = None\n) -&gt; HttpResponse:\n    \"\"\"Custom 405 page - method not allowed\n\n    Custom page method not allowed\n\n    Args:\n        request (HttpRequest): request from user\n\n    Returns:\n        HttpResponse: for loading the correct webpage\n    \"\"\"\n    context: dict[str, Any] = {\"page_title\": \"405 - method not allowed\"}\n\n    return render(\n        request, \"error_handler.html\", context | std_context(), status=405\n    )\n</code></pre>"},{"location":"code/django/views/#views.custom_500","title":"<code>custom_500(request, exception=None)</code>","text":"<p>Custom 500 page - internal server error</p> <p>Description</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>HttpRequest</code> <p>request from user</p> required <p>Returns:</p> Name Type Description <code>HttpResponse</code> <code>HttpResponse</code> <p>for loading the correct webpage</p> Source code in <code>app/dcsp/app/views.py</code> <pre><code>def custom_500(\n    request: HttpRequest, exception: Optional[Exception] = None\n) -&gt; HttpResponse:\n    \"\"\"Custom 500 page - internal server error\n\n    Description\n\n    Args:\n        request (HttpRequest): request from user\n\n    Returns:\n        HttpResponse: for loading the correct webpage\n    \"\"\"\n    context: dict[str, Any] = {\"page_title\": \"500 - Internal Server Error\"}\n\n    return render(\n        request,\n        \"error_handler.html\",\n        context | std_context(),\n        status=500,\n    )\n</code></pre>"},{"location":"code/django/views/#views.document_new","title":"<code>document_new(request, project_id, setup_step)</code>","text":"<p>To create a new safety document</p> <p>This will allow the user to create a new safety document, which are stored as markdown files. A new directory will be created if it does not already exist.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>HttpRequest</code> <p>request from user</p> required <code>project_id</code> <code>int</code> <p>primary key of project</p> required <code>setup_step</code> <code>int</code> <p>the step in the setup process</p> required <p>Returns:</p> Name Type Description <code>HttpResponse</code> <code>HttpResponse</code> <p>for loading the correct webpage</p> Source code in <code>app/dcsp/app/views.py</code> <pre><code>@project_access\ndef document_new(  # type: ignore[return]\n    request: HttpRequest,\n    project_id: int,\n    setup_step: int,\n) -&gt; HttpResponse:\n    \"\"\"To create a new safety document\n\n    This will allow the user to create a new safety document, which are stored as\n    markdown files. A new directory will be created if it does not already exist.\n\n    Args:\n        request (HttpRequest): request from user\n        project_id (int): primary key of project\n        setup_step (int): the step in the setup process\n\n    Returns:\n        HttpResponse: for loading the correct webpage\n    \"\"\"\n    context: dict[str, Any] = {}\n    form: Optional[DocumentNewForm] = None\n    project: Optional[ProjectBuilder] = None\n    document_name_new: str = \"\"\n\n    if setup_step &lt; 2:\n        return redirect(f\"/setup_documents/{ project_id }\")\n\n    if request.method == \"GET\":\n        context = {\n            \"page_title\": \"Create a new safety document\",\n            \"project_name\": Project.objects.get(id=project_id).name,\n            \"form\": DocumentNewForm(project_id),\n            \"project_id\": project_id,\n        }\n        return render(\n            request,\n            \"document_new.html\",\n            context | std_context(project_id),\n        )\n\n    elif request.method == \"POST\":\n        form = DocumentNewForm(project_id, request.POST)\n        if form.is_valid():\n            document_name_new = form.cleaned_data[\"document_name\"]\n\n            project = ProjectBuilder(project_id)\n\n            project.document_create(document_name_new)\n\n            messages.success(\n                request,\n                f\"Document '{ document_name_new }' has been created\",\n            )\n\n            context = {\n                \"page_title\": \"New document created\",\n                \"project_name\": Project.objects.get(id=project_id).name,\n                \"submitted\": True,\n                \"project_id\": project_id,\n                \"document_name_new\": document_name_new,\n            }\n\n            return render(\n                request, \"document_new.html\", context | std_context(project_id)\n            )\n\n        else:\n            context = {\n                \"page_title\": \"Create a new safety document\",\n                \"project_name\": Project.objects.get(id=project_id).name,\n                \"form\": form,\n                \"project_id\": project_id,\n            }\n\n            return render(\n                request,\n                \"document_new.html\",\n                context | std_context(project_id),\n                status=400,\n            )\n</code></pre>"},{"location":"code/django/views/#views.document_update","title":"<code>document_update(request, project_id, setup_step)</code>","text":"<p>Save the safety document</p> <p>If no issues are found after running the markdown file through a linter the file is saved.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>HttpRequest</code> <p>request from user</p> required <code>project_id</code> <code>int</code> <p>primary key of project</p> required <code>setup_step</code> <code>int</code> <p>the step in the setup process</p> required <p>Returns:</p> Name Type Description <code>HttpResponse</code> <code>HttpResponse</code> <p>for loading the correct webpage</p> Source code in <code>app/dcsp/app/views.py</code> <pre><code>@project_access\ndef document_update(  # type: ignore[return]\n    request: HttpRequest, project_id: int, setup_step: int\n) -&gt; HttpResponse:\n    \"\"\"Save the safety document\n\n    If no issues are found after running the markdown file through a linter\n    the file is saved.\n\n    Args:\n        request (HttpRequest): request from user\n        project_id (int): primary key of project\n        setup_step (int): the step in the setup process\n\n    Returns:\n        HttpResponse: for loading the correct webpage\n    \"\"\"\n    form: Optional[DocumentUpdateForm] = None\n    document_name_initial: str = \"\"\n    document_name: str = \"\"\n    document_markdown_initial: str = \"\"\n    document_markdown: str = \"\"\n    document_markdown_file_read: str = \"\"\n    form_data: dict[str, str] = {}\n    docs_dir: str = f\"{ c.PROJECTS_FOLDER }project_{ project_id }/{ c.CLINICAL_SAFETY_FOLDER }docs/\"\n    file: TextIO\n    context: dict[str, Any] = {}\n\n    if setup_step &lt; 2:\n        return redirect(f\"/setup_documents/{ project_id }\")\n\n    if request.method == \"GET\":\n        form = DocumentUpdateForm(project_id)\n\n        context = {\n            \"page_title_left\": \"Edit safety document\",\n            \"form\": form,\n            \"project_id\": project_id,\n            \"placeholders\": placeholders(project_id),\n            \"nav_top\": \"True\",\n        }\n\n        return render(\n            request,\n            \"document_update.html\",\n            context | std_context(project_id),\n        )\n\n    elif request.method == \"POST\":\n        form = DocumentUpdateForm(project_id, data=request.POST)\n\n        if form.is_valid():\n            document_name_initial = form.cleaned_data[\"document_name_initial\"]\n            document_name = form.cleaned_data[\"document_name\"]\n            document_markdown_initial = form.cleaned_data[\n                \"document_markdown_initial\"\n            ]\n            document_markdown = form.cleaned_data[\"document_markdown\"]\n\n            if document_name_initial != document_name:\n                with open(Path(docs_dir) / document_name, \"r\") as file:\n                    document_markdown_file_read = file.read()\n                    document_markdown_file_read = (\n                        document_markdown_file_read.replace(\"\\n\", \"\\r\\n\")\n                    )\n\n                form_data = {\n                    \"document_name\": document_name,\n                    \"document_markdown\": document_markdown_file_read,\n                }\n\n                context = {\n                    \"page_title_left\": \"Edit safety document\",\n                    \"form\": DocumentUpdateForm(\n                        project_id,\n                        initial=form_data,\n                    ),\n                    \"project_id\": project_id,\n                    \"placeholders\": placeholders(project_id),\n                    \"nav_top\": \"True\",\n                }\n\n                return render(\n                    request,\n                    \"document_update.html\",\n                    context | std_context(project_id),\n                )\n\n            elif document_markdown_initial != document_markdown:\n                with open(Path(docs_dir) / document_name, \"w\") as file:\n                    file.write(document_markdown)\n\n                project_timestamp(project_id)\n\n                form_data = {\n                    \"document_name\": document_name,\n                    \"document_markdown\": document_markdown,\n                }\n\n                messages.success(\n                    request,\n                    f\"Mark down file '{ document_name }' has been successfully saved\",\n                )\n\n                context = {\n                    \"page_title_left\": \"Edit safety document\",\n                    \"form\": DocumentUpdateForm(\n                        project_id,\n                        initial=form_data,\n                    ),\n                    \"project_id\": project_id,\n                    \"placeholders\": placeholders(project_id),\n                    \"nav_top\": \"True\",\n                }\n                return render(\n                    request,\n                    \"document_update.html\",\n                    context | std_context(project_id),\n                )\n            else:\n                messages.success(\n                    request,\n                    \"As no changes have been made, no save has been made\",\n                )\n                context = {\n                    \"page_title_left\": \"Edit safety document\",\n                    \"form\": form,\n                    \"project_id\": project_id,\n                    \"placeholders\": placeholders(project_id),\n                    \"nav_top\": \"True\",\n                }\n                return render(\n                    request,\n                    \"document_update.html\",\n                    context | std_context(project_id),\n                )\n\n        else:\n            context = {\n                \"page_title_left\": \"Edit safety document\",\n                \"form\": form,\n                \"project_id\": project_id,\n                \"placeholders\": placeholders(project_id),\n                \"nav_top\": \"True\",\n            }\n            return render(\n                request,\n                \"document_update.html\",\n                context | std_context(project_id),\n                status=400,\n            )\n</code></pre>"},{"location":"code/django/views/#views.document_update_named","title":"<code>document_update_named(request, project_id, setup_step, document_name)</code>","text":"<p>Select a specific document to edit</p> <p>Uses the url to select a specific document to edit.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>HttpRequest</code> <p>request from user</p> required <code>project_id</code> <code>int</code> <p>primary key of project</p> required <code>setup_step</code> <code>int</code> <p>the step in the setup process</p> required <code>document_name</code> <code>str</code> <p>name of the document to edit</p> required <p>Returns:</p> Name Type Description <code>HttpResponse</code> <code>HttpResponse</code> <p>for loading the correct webpage</p> Source code in <code>app/dcsp/app/views.py</code> <pre><code>@project_access\ndef document_update_named(  # type: ignore[return]\n    request: HttpRequest, project_id: int, setup_step: int, document_name: str\n) -&gt; HttpResponse:\n    \"\"\"Select a specific document to edit\n\n    Uses the url to select a specific document to edit.\n\n    Args:\n        request (HttpRequest): request from user\n        project_id (int): primary key of project\n        setup_step (int): the step in the setup process\n        document_name (str): name of the document to edit\n\n    Returns:\n        HttpResponse: for loading the correct webpage\n    \"\"\"\n    form: Optional[DocumentUpdateForm] = None\n    context: dict[str, Any] = {}\n\n    if not request.method == \"GET\":\n        return custom_405(request)\n\n    if setup_step &lt; 2:\n        return redirect(f\"/setup_documents/{ project_id }\")\n\n    if request.method == \"GET\":\n        try:\n            form = DocumentUpdateForm(project_id, document_name)\n        except FileNotFoundError:\n            return custom_404(request)\n\n        context = {\n            \"page_title_left\": \"Edit safety document\",\n            \"form\": form,\n            \"project_id\": project_id,\n            \"placeholders\": placeholders(project_id),\n            \"nav_top\": \"True\",\n        }\n\n        return render(\n            request,\n            \"document_update.html\",\n            context | std_context(project_id),\n        )\n</code></pre>"},{"location":"code/django/views/#views.entry_select","title":"<code>entry_select(request, project_id, setup_step, entry_type)</code>","text":"<p>Displays entries that can be edited</p> <p>For the given entry type, displays the entries that can be edited.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>HttpRequest</code> <p>request from user</p> required <code>project_id</code> <code>int</code> <p>primary key of the project</p> required <code>setup_step</code> <code>int</code> <p>the step in the setup process</p> required <code>entry_type</code> <code>str</code> <p>type of entry (eg hazard, incident)</p> required <p>Returns:</p> Name Type Description <code>HttpResponse</code> <code>HttpResponse</code> <p>for loading the correct webpage</p> Source code in <code>app/dcsp/app/views.py</code> <pre><code>@project_access\ndef entry_select(\n    request: HttpRequest,\n    project_id: int,\n    setup_step: int,\n    entry_type: str,\n) -&gt; HttpResponse:\n    \"\"\"Displays entries that can be edited\n\n    For the given entry type, displays the entries that can be edited.\n\n    Args:\n        request (HttpRequest): request from user\n        project_id (int): primary key of the project\n        setup_step (int): the step in the setup process\n        entry_type (str): type of entry (eg hazard, incident)\n\n    Returns:\n        HttpResponse: for loading the correct webpage\n    \"\"\"\n    context: dict[str, Any] = {}\n    project: ProjectBuilder = ProjectBuilder(int(project_id))\n    entries: list[str] = []\n\n    if setup_step &lt; 2:\n        return redirect(f\"/setup_documents/{ project_id }\")\n\n    if request.method != \"GET\":\n        return custom_405(request)\n\n    if not project.entry_type_exists(entry_type):\n        return custom_404(request)\n\n    entries = project.entries_all_get(entry_type)\n\n    context = {\n        \"page_title\": f\"Select { kebab_to_sentense(entry_type) } to edit\",\n        \"project_name\": Project.objects.get(id=project_id).name,\n        \"project_id\": project_id,\n        \"entries\": entries,\n        \"entry_type\": entry_type,\n        \"project_side_bars\": True,\n    }\n    return render(\n        request, \"entry_select.html\", context | std_context(project_id)\n    )\n</code></pre>"},{"location":"code/django/views/#views.entry_update","title":"<code>entry_update(request, project_id, setup_step, entry_type, id_new)</code>","text":"<p>Create or update an entry</p> <p>Creates a new entry (for example a hazard or incident) or updates a pre- existing one.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>HttpRequest</code> <p>request user.</p> required <code>project_id</code> <code>int</code> <p>the primary key of the project.</p> required <code>setup_step</code> <code>int</code> <p>the step in the setup process.</p> required <code>entry_type</code> <code>str</code> <p>type of entry (eg hazard, incident).</p> required <code>id_new</code> <code>str</code> <p>an entry file number or \"new\" to create a new entry.</p> required <p>Returns:</p> Name Type Description <code>HttpResponse</code> <code>HttpResponse</code> <p>for loading the webpage.</p> Source code in <code>app/dcsp/app/views.py</code> <pre><code>@project_access\ndef entry_update(  # type: ignore[return]\n    request: HttpRequest,\n    project_id: int,\n    setup_step: int,\n    entry_type: str,\n    id_new: str,\n) -&gt; HttpResponse:\n    \"\"\"Create or update an entry\n\n    Creates a new entry (for example a hazard or incident) or updates a pre-\n    existing one.\n\n    Args:\n        request (HttpRequest): request user.\n        project_id (int): the primary key of the project.\n        setup_step (int): the step in the setup process.\n        entry_type (str): type of entry (eg hazard, incident).\n        id_new (str): an entry file number or \"new\" to create a new entry.\n\n    Returns:\n        HttpResponse: for loading the webpage.\n    \"\"\"\n    project: ProjectBuilder = ProjectBuilder(project_id)\n    context: dict[str, Any] = {\"project_id\": project_id}\n    form_initial: dict[str, str] = {}\n    form: EntryUpdateForm\n    entry_update_outcome: bool = False\n    page_title: str = \"\"\n\n    if setup_step &lt; 2:\n        return redirect(f\"/setup_documents/{ project_id }\")\n\n    if id_new != \"new\":\n        if not id_new.isdigit() or not project.entry_exists(\n            entry_type, int(id_new)\n        ):\n            return custom_404(request)\n\n    if not project.entry_type_exists(entry_type):\n        return custom_404(request)\n\n    if request.method == \"GET\":\n        if id_new == \"new\":\n            context = {\n                \"page_title\": f\"Create new { kebab_to_sentense(entry_type) }\",\n                \"project_name\": Project.objects.get(id=project_id).name,\n                \"project_id\": project_id,\n                \"form\": EntryUpdateForm(project_id, entry_type),\n                \"entry_type\": entry_type,\n                \"id_new\": id_new,\n                \"project_side_bars\": True,\n            }\n            return render(\n                request,\n                \"entry_update.html\",\n                context | std_context(project_id),\n            )\n\n        else:\n            form_initial = project.form_initial(entry_type, int(id_new))\n            context = {\n                \"page_title\": f\"Update { kebab_to_sentense(entry_type) }\",\n                \"project_name\": Project.objects.get(id=project_id).name,\n                \"project_id\": project_id,\n                \"form\": EntryUpdateForm(\n                    project_id,\n                    entry_type,\n                    initial=form_initial,\n                ),\n                \"entry_type\": entry_type,\n                \"id_new\": id_new,\n                \"project_side_bars\": True,\n            }\n            return render(\n                request,\n                \"entry_update.html\",\n                context | std_context(project_id),\n            )\n\n    elif request.method == \"POST\":\n        form = EntryUpdateForm(project_id, entry_type, request.POST)\n        if form.is_valid():\n            project_timestamp(project_id)\n\n            entry_update_outcome = project.entry_update(\n                form.cleaned_data,\n                entry_type,\n                id_new,\n            )\n\n            context = {\n                \"page_title\": f\"{ kebab_to_sentense(entry_type) } saved\",\n                \"project_name\": Project.objects.get(id=project_id).name,\n                \"project_id\": project_id,\n                \"entry_update_outcome\": entry_update_outcome,\n                \"entry_type\": entry_type,\n                \"id_new\": id_new,\n                \"project_side_bars\": True,\n            }\n            return render(\n                request,\n                \"entry_saved.html\",\n                context | std_context(project_id),\n            )\n\n        else:\n            if id_new == \"new\":\n                page_title = f\"Create new { kebab_to_sentense(entry_type) }\"\n            else:\n                page_title = f\"Update { kebab_to_sentense(entry_type) }\"\n\n            context = {\n                \"page_title\": page_title,\n                \"project_name\": Project.objects.get(id=project_id).name,\n                \"form\": form,\n                \"project_id\": project_id,\n                \"entry_type\": entry_type,\n                \"id_new\": id_new,\n                \"project_side_bars\": True,\n            }\n            return render(\n                request,\n                \"entry_update.html\",\n                context | std_context(project_id),\n            )\n</code></pre>"},{"location":"code/django/views/#views.index","title":"<code>index(request)</code>","text":"<p>Landing page for DCSP app</p> <p>Landing page for DCSP app</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>HttpRequest</code> <p>request from user</p> required <p>Returns:</p> Name Type Description <code>HttpResponse</code> <code>HttpResponse</code> <p>for loading the correct webpage</p> Source code in <code>app/dcsp/app/views.py</code> <pre><code>def index(request: HttpRequest) -&gt; HttpResponse:\n    \"\"\"Landing page for DCSP app\n\n    Landing page for DCSP app\n\n    Args:\n        request (HttpRequest): request from user\n\n    Returns:\n        HttpResponse: for loading the correct webpage\n    \"\"\"\n    context: dict[str, Any] = {\n        \"page_title\": \"Welcome to the Digital Clinical Safety Platform\",\n        \"NON_EXISTENT_VARIABLE\": \"NON_EXISTENT_VARIABLE\",\n    }\n\n    if request.method != \"GET\":\n        return custom_405(request)\n\n    if request.user.is_authenticated:\n        return redirect(\"/member\")\n\n    return render(request, \"index.html\", context | std_context())\n</code></pre>"},{"location":"code/django/views/#views.member_landing_page","title":"<code>member_landing_page(request)</code>","text":"<p>Landing page for members</p> <p>If no documents related to user, will help user set this up. If user has access to documents, these will be displayed here.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>HttpRequest</code> <p>request from user</p> required <p>Returns:</p> Name Type Description <code>HttpResponse</code> <code>HttpResponse</code> <p>for loading the correct webpage</p> Source code in <code>app/dcsp/app/views.py</code> <pre><code>@login_required\ndef member_landing_page(request: HttpRequest) -&gt; HttpResponse:\n    \"\"\"Landing page for members\n\n    If no documents related to user, will help user set this up. If user has\n    access to documents, these will be displayed here.\n\n    Args:\n        request (HttpRequest): request from user\n\n    Returns:\n        HttpResponse: for loading the correct webpage\n    \"\"\"\n    projects: list[dict[str, Any]] = []\n    viewed_documents: bool = False\n    context: dict[str, Any] = {}\n\n    if request.method != \"GET\":\n        return custom_405(request)\n\n    projects = user_accessible_projects(request)\n\n    viewed_documents = any(\n        record.get(\"doc_last_accessed\") is not None for record in projects\n    )\n\n    context = {\n        \"page_title\": \"Safety documents\",\n        \"available_projects\": projects,\n        \"viewed_documents\": viewed_documents,\n    }\n\n    return render(request, \"member_landing_page.html\", context | std_context())\n</code></pre>"},{"location":"code/django/views/#views.placeholders","title":"<code>placeholders(project_id)</code>","text":"<p>Provides placeholders in serialised form</p> <p>This is used in the documents edit page, where markdown is converted to html and placeholders are converted into their corresponding values.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>placeholders in a serialised form.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>placeholders in serialised form, with empty values replaced with  \"[key undefined]\"</p> Source code in <code>app/dcsp/app/views.py</code> <pre><code>def placeholders(project_id: int) -&gt; str:\n    \"\"\"Provides placeholders in serialised form\n\n    This is used in the documents edit page, where markdown is converted to\n    html and placeholders are converted into their corresponding values.\n\n    Args:\n        project_id (str): placeholders in a serialised form.\n\n    Returns:\n        str: placeholders in serialised form, with empty values replaced with\n             \"[key undefined]\"\n    \"\"\"\n    project_builder: Optional[ProjectBuilder] = None\n    placeholders: dict[str, str] = {}\n    key: str = \"\"\n    value: str = \"\"\n\n    if not isinstance(project_id, int):\n        return \"\"\n\n    if not Project.objects.filter(id=project_id).exists():\n        return \"\"\n\n    project_builder = ProjectBuilder(int(project_id))\n    placeholders = project_builder.get_placeholders()\n    for key, value in placeholders.items():\n        if value == \"\":\n            placeholders[key] = f\"[{ key } undefined]\"\n\n    return json.dumps(placeholders)\n</code></pre>"},{"location":"code/django/views/#views.project_build_asap","title":"<code>project_build_asap(request, project_id, _)</code>","text":"<p>Ad hoc build of the static site</p> <p>This function allows the user to build the static site ad hoc. This is useful if the user has made changes to the documents and wants to see the changes immediately.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>HttpRequest</code> <p>request from user</p> required <code>project_id</code> <code>int</code> <p>primary key of project</p> required <p>Returns:</p> Name Type Description <code>HttpResponse</code> <code>HttpResponse</code> <p>for loading the webpage</p> Source code in <code>app/dcsp/app/views.py</code> <pre><code>@project_access\ndef project_build_asap(  # type: ignore[return]\n    request: HttpRequest,\n    project_id: int,\n    _: int,\n) -&gt; HttpResponse:\n    \"\"\"Ad hoc build of the static site\n\n    This function allows the user to build the static site ad hoc. This is\n    useful if the user has made changes to the documents and wants to see the\n    changes immediately.\n\n    Args:\n        request (HttpRequest): request from user\n        project_id (int): primary key of project\n\n    Returns:\n        HttpResponse: for loading the webpage\n    \"\"\"\n    context: dict[str, Any] = {}\n    build_output: str = \"\"\n    mkdocs_control: MkdocsControl = MkdocsControl(project_id)\n\n    if request.method == \"GET\":\n        context = {\n            \"page_title\": \"Build documents\",\n            \"project_id\": project_id,\n            \"project_name\": Project.objects.get(id=project_id).name,\n            \"project_side_bars\": True,\n        }\n\n        return render(\n            request,\n            \"project_build_asap.html\",\n            context | std_context(project_id),\n        )\n    elif request.method == \"POST\":\n        build_output = mkdocs_control.build_documents(force=True)\n\n        context = {\n            \"page_title\": \"Build documents\",\n            \"project_id\": project_id,\n            \"build_output\": build_output,\n            \"project_name\": Project.objects.get(id=project_id).name,\n            \"project_side_bars\": True,\n        }\n\n        return render(\n            request,\n            \"project_build_asap.html\",\n            context | std_context(project_id),\n        )\n</code></pre>"},{"location":"code/django/views/#views.project_documents","title":"<code>project_documents(request, project_id, _)</code>","text":"<p>Shows the project main page</p> <p>This provides an overview of the project and the documents that are part of it.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>HttpRequest</code> <p>request from user.</p> required <code>project_id</code> <code>int</code> <p>primary key of project.</p> required <p>Returns:</p> Name Type Description <code>HttpResponse</code> <code>HttpResponse</code> <p>for loading the correct webpage.</p> Source code in <code>app/dcsp/app/views.py</code> <pre><code>@project_access\ndef project_documents(\n    request: HttpRequest,\n    project_id: int,\n    _: int,\n) -&gt; HttpResponse:\n    \"\"\"Shows the project main page\n\n    This provides an overview of the project and the documents that are part of\n    it.\n\n    Args:\n        request (HttpRequest): request from user.\n        project_id (int): primary key of project.\n\n    Returns:\n        HttpResponse: for loading the correct webpage.\n    \"\"\"\n    project: Optional[Project] = None\n    members: QuerySet[User] = User.objects.none()\n    groups: QuerySet[ProjectGroup] = ProjectGroup.objects.none()\n    context: dict[str, Any] = {}\n\n    if request.method != \"GET\":\n        return custom_405(request)\n\n    project = Project.objects.get(id=project_id)\n    members = project.member.all()\n    groups = ProjectGroup.objects.filter(project_access=project)\n\n    context = {\n        \"page_title\": \"--- Placeholder ---\",\n        \"page_title\": project.name,\n        \"project\": project,\n        \"members\": members,\n        \"groups\": groups,\n        \"project_id\": project_id,\n        \"project_name\": project.name,\n        \"project_side_bars\": True,\n    }\n    return render(\n        request,\n        \"project_documents.html\",\n        context | std_context(project_id),\n    )\n</code></pre>"},{"location":"code/django/views/#views.setup_documents","title":"<code>setup_documents(request, project_id, setup_step)</code>","text":"<p>Setup the safety documents prior to building them</p> <p>After the project has been initialised via 'start_new_project' above, this method setups the safety documents, enabling safety documents to then be built. The state of the installation is stored in an setup.ini file as 'setup_step'.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>HttpRequest</code> <p>request from user</p> required <p>Returns:</p> Name Type Description <code>HttpResponse</code> <code>HttpResponse</code> <p>for loading the correct webpage</p> Source code in <code>app/dcsp/app/views.py</code> <pre><code>@project_access\ndef setup_documents(  # type: ignore[return]\n    request: HttpRequest,\n    project_id: int,\n    setup_step: int,\n) -&gt; HttpResponse:\n    \"\"\"Setup the safety documents prior to building them\n\n    After the project has been initialised via 'start_new_project' above, this\n    method setups the safety documents, enabling safety documents to then be\n    built. The state of the installation is stored in an setup.ini file as\n    'setup_step'.\n\n    Args:\n        request (HttpRequest): request from user\n\n    Returns:\n        HttpResponse: for loading the correct webpage\n    \"\"\"\n    project_builder: ProjectBuilder = ProjectBuilder(project_id)\n    context: dict[str, Any] = {}\n    template_choice: str = \"\"\n    form: TemplateSelectForm | PlaceholdersForm\n\n    if setup_step == 1:\n        if request.method == \"GET\":\n            context = {\n                \"page_title\": \"Select Template\",\n                \"form\": TemplateSelectForm(project_id),\n                \"project_id\": project_id,\n            }\n\n            return render(\n                request,\n                \"setup_documents_template_select.html\",\n                context | std_context(project_id),\n            )\n\n        elif request.method == \"POST\":\n            form = TemplateSelectForm(project_id, request.POST)\n            if form.is_valid():\n                project_builder.configuration_set(\"setup_step\", 2)\n                template_choice = form.cleaned_data[\"template_choice\"]\n                project_builder.copy_master_template(template_choice)\n\n                messages.success(\n                    request,\n                    f\"{ template_choice } template initiated\",\n                )\n\n                context = {\n                    \"page_title\": \"Edit placeholders\",\n                    \"form\": PlaceholdersForm(project_id),\n                    \"project_id\": project_id,\n                    \"project_side_bars\": True,\n                }\n\n                return render(\n                    request,\n                    \"setup_documents_placeholders_show.html\",\n                    context | std_context(project_id),\n                )\n            else:\n                context = {\n                    \"page_title\": \"Select Template\",\n                    \"form\": form,\n                    \"project_id\": project_id,\n                }\n\n                return render(\n                    request,\n                    \"setup_documents_template_select.html\",\n                    context | std_context(project_id),\n                    status=400,\n                )\n\n    elif setup_step &gt;= 2:\n        if request.method == \"GET\":\n            context = {\n                \"page_title\": \"Edit placeholders\",\n                \"form\": PlaceholdersForm(project_id),\n                \"project_id\": project_id,\n                \"project_name\": Project.objects.get(id=project_id).name,\n                \"project_side_bars\": True,\n            }\n\n            return render(\n                request,\n                \"setup_documents_placeholders_show.html\",\n                context | std_context(project_id),\n            )\n\n        elif request.method == \"POST\":\n            form = PlaceholdersForm(project_id, request.POST)\n            if form.is_valid():\n                project_builder.configuration_set(\"setup_step\", 3)\n\n                project_builder.save_placeholders_from_form(form)\n\n                project_timestamp(project_id)\n\n                context = {\n                    \"page_title\": \"Documents published\",\n                    \"project_id\": project_id,\n                    \"project_name\": Project.objects.get(id=project_id).name,\n                    \"project_side_bars\": True,\n                }\n\n                return render(\n                    request,\n                    \"setup_documents_placeholders_saved.html\",\n                    context | std_context(project_id),\n                )\n            else:\n                context = {\n                    \"page_title\": \"Edit placeholders\",\n                    \"form\": form,\n                    \"project_id\": project_id,\n                    \"project_name\": Project.objects.get(id=project_id).name,\n                    \"project_side_bars\": True,\n                }\n\n                return render(\n                    request,\n                    \"setup_documents_placeholders_show.html\",\n                    context | std_context(project_id),\n                    status=400,\n                )\n</code></pre>"},{"location":"code/django/views/#views.start_new_project","title":"<code>start_new_project(request)</code>","text":"<p>Setup a new project</p> <p>Create a project by importing an external git repository or starting from a blank slate. A clinical safety document folder will be added if not already present.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>HttpRequest</code> <p>request from user</p> required <p>Returns:</p> Name Type Description <code>HttpResponse</code> <code>HttpResponse</code> <p>for loading the correct webpage</p> Source code in <code>app/dcsp/app/views.py</code> <pre><code>@login_required\ndef start_new_project(  # type: ignore[return]\n    request: HttpRequest,\n) -&gt; HttpResponse:\n    \"\"\"Setup a new project\n\n    Create a project by importing an external git repository or starting from a\n    blank slate. A clinical safety document folder will be added if not already\n    present.\n\n    Args:\n        request (HttpRequest): request from user\n\n    Returns:\n        HttpResponse: for loading the correct webpage\n    \"\"\"\n    context: dict[str, Any] = {}\n    form: ProjectSetupInitialForm | ProjectSetupStepTwoForm\n    setup_choice: str = \"\"\n    external_repo_url: str = \"\"\n    setup_step: int = 0\n    inputs: dict[str, str] = {}\n    project_builder: ProjectBuilder\n    project_id: str = \"\"\n\n    if not (request.method == \"POST\" or request.method == \"GET\"):\n        return custom_405(request)\n\n    if request.method == \"GET\":\n        setup_step = 1\n        request.session.pop(\"repository_type\", None)\n        request.session[\"project_setup_step\"] = setup_step\n        request.session[\"inputs\"] = {}\n\n        context = {\n            \"page_title\": \"Setup a new project\",\n            \"setup_step\": setup_step,\n            \"form\": ProjectSetupInitialForm(),\n        }\n\n        return render(\n            request, \"start_new_project.html\", context | std_context()\n        )\n\n    elif request.method == \"POST\":\n        setup_step = request.session.get(\"project_setup_step\", None)\n        if setup_step == None:\n            return redirect(\"/start_new_project\")\n        if setup_step == 1:\n            form = ProjectSetupInitialForm(request.POST)\n            if form.is_valid():\n                setup_step = 2\n                request.session[\"project_setup_step\"] = setup_step\n                request.session[\n                    \"project_setup_1_form_data\"\n                ] = form.cleaned_data\n                setup_choice = form.cleaned_data[\"setup_choice\"]\n\n                if setup_choice == \"import\":\n                    external_repo_url = form.cleaned_data[\n                        \"external_repository_url_import\"\n                    ]\n\n                    if \"github.com/\" in external_repo_url:\n                        request.session[\"inputs\"][\"repository_type\"] = \"github\"\n                    elif \"gitlab.com/\" in external_repo_url:\n                        request.session[\"inputs\"][\"repository_type\"] = \"gitlab\"\n                    elif \"gitbucket\" in external_repo_url:\n                        request.session[\"inputs\"][\n                            \"repository_type\"\n                        ] = \"gitbucket\"\n                    else:\n                        request.session[\"inputs\"][\"repository_type\"] = \"other\"\n\n                # start_anew just jumps straight to the next step\n                context = {\n                    \"page_title\": \"Setup a new project\",\n                    \"setup_choice\": snake_to_sentense(setup_choice),\n                    \"form\": ProjectSetupStepTwoForm(),\n                    \"setup_step\": setup_step,\n                }\n\n                return render(\n                    request,\n                    \"start_new_project.html\",\n                    context | std_context(),\n                )\n\n            else:\n                context = {\n                    \"page_title\": \"Setup a new project\",\n                    \"form\": form,\n                    \"setup_step\": setup_step,\n                }\n\n                return render(\n                    request,\n                    \"start_new_project.html\",\n                    context | std_context(),\n                    status=400,\n                )\n\n        elif setup_step == 2:\n            form = ProjectSetupStepTwoForm(request.POST)\n            if form.is_valid():\n                setup_choice = request.session[\"project_setup_1_form_data\"][\n                    \"setup_choice\"\n                ]\n                if setup_choice != \"start_anew\" and setup_choice != \"import\":\n                    return custom_500(request)\n\n                setup_step = 3\n                request.session[\"project_setup_step\"] = setup_step\n                request.session[\n                    \"project_setup_2_form_data\"\n                ] = form.cleaned_data\n\n                inputs = request.session[\"project_setup_1_form_data\"].copy()\n                inputs.update(request.session[\"project_setup_2_form_data\"])\n                setup_choice = request.session[\"project_setup_1_form_data\"][\n                    \"setup_choice\"\n                ]\n\n                request.session[\"inputs\"].update(inputs)\n\n                context = {\n                    \"page_title\": \"Setup a new project\",\n                    \"setup_choice\": snake_to_sentense(setup_choice),\n                    \"inputs_GUI\": start_new_project_step_2_input_GUI(inputs),\n                    \"setup_step\": setup_step,\n                    \"CLINICAL_SAFETY_FOLDER\": c.CLINICAL_SAFETY_FOLDER,\n                }\n\n                return render(\n                    request, \"start_new_project.html\", context | std_context()\n                )\n            else:\n                context = {\"form\": form, \"setup_step\": setup_step}\n\n                return render(\n                    request,\n                    \"start_new_project.html\",\n                    context | std_context(),\n                    status=400,\n                )\n\n        elif setup_step == 3:\n            setup_step = 4\n            request.session[\"project_setup_step\"] = setup_step\n\n            project_builder = ProjectBuilder()\n            try:\n                project_builder.new_build(request)\n            except (\n                ValueError,\n                KeyError,\n                RepositoryAccessException,\n                NotImplementedError,\n                FileExistsError,\n            ) as e:\n                messages.error(\n                    request,\n                    f\"There was an error with the data you supplied: '{ e }'. Please correct these errors.\",\n                )\n\n                context = {\n                    \"page_title\": \"Error with data supplied\",\n                    \"setup_step\": setup_step,\n                    \"restart_button\": \"yes\",\n                }\n\n                return render(\n                    request,\n                    \"start_new_project.html\",\n                    context | std_context(),\n                    status=400,\n                )\n\n            inputs = request.session[\"inputs\"]\n\n            messages.success(\n                request,\n                f\"You have successfully created the project titled '{inputs['project_name']}'.\",\n            )\n\n            project_id = request.session[\"project_id\"]\n\n            request.session.pop(\"project_id\")\n\n            context = {\n                \"page_title\": \"Complete\",\n                \"setup_step\": setup_step,\n                \"project_id\": project_id,\n            }\n\n            return render(\n                request, \"start_new_project.html\", context | std_context()\n            )\n\n        elif setup_step == 4:\n            return redirect(\"/start_new_project\")\n</code></pre>"},{"location":"code/django/views/#views.start_new_project_step_2_input_GUI","title":"<code>start_new_project_step_2_input_GUI(inputs)</code>","text":"<p>Converts the inputs into a more user friendly format</p> <p>Takes the user inputs from the previous submissions and prepares them for displaying in the GUI.</p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <code>dict[str, str]</code> <p>inputs from the previous submissions.</p> required <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>dict[str, str]: inputs in a GUI friendly format.</p> Source code in <code>app/dcsp/app/views.py</code> <pre><code>def start_new_project_step_2_input_GUI(\n    inputs: dict[str, str]\n) -&gt; dict[str, str]:\n    \"\"\"Converts the inputs into a more user friendly format\n\n    Takes the user inputs from the previous submissions and prepares them for\n    displaying in the GUI.\n\n    Args:\n        inputs (dict[str, str]): inputs from the previous submissions.\n\n    Returns:\n        dict[str, str]: inputs in a GUI friendly format.\n    \"\"\"\n    key: str = \"\"\n    value: str = \"\"\n    inputs_GUI: dict[str, str] = {}\n    groups_list: list[str] = []\n    members_list: QuerySet[Any] = User.objects.none()\n    members_list_fullnames: list[str] = []\n\n    for key, value in inputs.items():\n        key = key.replace(\"import\", \"\")\n        key = key.replace(\"start_anew\", \"\")\n        key = snake_to_sentense(key)\n\n        if key == \"Setup choice\":\n            inputs_GUI[key] = snake_to_sentense(value)\n\n        elif key == \"Groups\":\n            groups_list = [\n                name\n                for name in ProjectGroup.objects.filter(\n                    id__in=value\n                ).values_list(\"name\", flat=True)\n                if name is not None\n            ]\n            inputs_GUI[key] = \", \".join(groups_list)\n            if inputs_GUI[key] == \"\":\n                inputs_GUI[key] = \"&lt;i&gt;none selected&lt;/i&gt;\"\n\n        elif key == \"Members\":\n            members_list = User.objects.filter(id__in=value).values(\n                \"id\", \"first_name\", \"last_name\"\n            )\n            members_list_fullnames = [\n                f\"{member['first_name']} {member['last_name']}\"\n                for member in members_list\n            ]\n            inputs_GUI[key] = \", \".join(members_list_fullnames)\n            if inputs_GUI[key] == \"\":\n                inputs_GUI[key] = \"&lt;i&gt;none selected&lt;/i&gt;\"\n        elif key == \"Access\":\n            inputs_GUI[key] = ViewAccess.get_label(value)\n\n        elif any(keyword in key for keyword in [\"password\", \"token\"]):\n            key = key.replace(\"password token\", \"password / token\")\n            inputs_GUI[key] = \"***\"\n\n        else:\n            inputs_GUI[key] = value\n\n    return inputs_GUI\n</code></pre>"},{"location":"code/django/views/#views.std_context","title":"<code>std_context(project_id=0)</code>","text":"<p>Provides standard context for the rendered view</p> <p>Provides a standard collection of values that can be used in page renderings.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>int</code> <p>primary key of project.</p> <code>0</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>dict[str,Any]: context that is comment across the different views</p> Source code in <code>app/dcsp/app/views.py</code> <pre><code>def std_context(project_id: int = 0) -&gt; dict[str, Any]:\n    \"\"\"Provides standard context for the rendered view\n\n    Provides a standard collection of values that can be used in page renderings.\n\n    Args:\n        project_id (int): primary key of project.\n\n    Returns:\n        dict[str,Any]: context that is comment across the different views\n    \"\"\"\n    project: Optional[ProjectBuilder] = None\n    entry_templates: list[str] = []\n    std_context_dict: dict[str, Any] = {}\n    project_setup_step: int = 0\n\n    if not isinstance(project_id, int):\n        raise ValueError(\"project_id must be an integer\")\n\n    if project_id &gt; 0:\n        project = ProjectBuilder(project_id)\n        entry_templates = project.entry_template_names()\n        project_setup_step = project.configuration_get()[\"setup_step\"]\n\n    std_context_dict = {\n        \"entry_templates\": entry_templates,\n        \"project_setup_step\": project_setup_step,\n    }\n\n    return std_context_dict\n</code></pre>"},{"location":"code/django/views/#views.under_construction","title":"<code>under_construction(request, message)</code>","text":"<p>Under construction page</p> <p>This page is displayed when a page is under construction.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>HttpRequest</code> <p>request from user.</p> required <code>message</code> <code>str</code> <p>message to display.</p> required <p>Returns:</p> Name Type Description <code>HttpResponse</code> <code>HttpResponse</code> <p>for loading the correct webpage.</p> Source code in <code>app/dcsp/app/views.py</code> <pre><code>def under_construction(\n    request: HttpRequest,\n    message: str,\n) -&gt; HttpResponse:\n    \"\"\"Under construction page\n\n    This page is displayed when a page is under construction.\n\n    Args:\n        request (HttpRequest): request from user.\n        message (str): message to display.\n\n    Returns:\n        HttpResponse: for loading the correct webpage.\n    \"\"\"\n    context: dict[str, Any] = {\n        \"page_title\": \" Under contruction\",\n        \"message\": message,\n    }\n\n    return render(request, \"under_construction.html\", context | std_context())\n</code></pre>"},{"location":"code/django/views/#views.user_accessible_projects","title":"<code>user_accessible_projects(request)</code>","text":"<p>Finds all documents that the user has access to</p> <p>Provides a list of all documents that the user has access to. This includes documents that the user owns, documents that the user is a member of, and documents that the user has access to through a project group.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>HttpRequest</code> <p>request from user</p> required <p>Returns:</p> Type Description <code>list[dict[str, Any]]</code> <p>list[None | dict[str, Any]]: a list of documents</p> Source code in <code>app/dcsp/app/views.py</code> <pre><code>def user_accessible_projects(\n    request: HttpRequest,\n) -&gt; list[dict[str, Any]]:\n    \"\"\"Finds all documents that the user has access to\n\n    Provides a list of all documents that the user has access to. This includes\n    documents that the user owns, documents that the user is a member of, and\n    documents that the user has access to through a project group.\n\n    Args:\n        request (HttpRequest): request from user\n\n    Returns:\n        list[None | dict[str, Any]]: a list of documents\n    \"\"\"\n    user_id: int = (\n        int(str(request.user.id)) if request.user.id is not None else 0\n    )\n    documents_owner: QuerySet[Any] = Project.objects.none()\n    documents_member: QuerySet[Any] = Project.objects.none()\n    project_group: QuerySet[Any] = ProjectGroup.objects.none()\n    record: Any = {}\n    documents_combined: list[dict[str, Any]] = []\n    documents_sorted: list[dict[str, Any]] = []\n    i: int = 0\n\n    documents_owner = Project.objects.values(\n        doc_id=F(\"id\"),\n        project_name=F(\"name\"),\n        doc_last_accessed=F(\"userprojectattribute__last_accessed\"),\n    ).filter(owner=user_id)\n\n    documents_member = Project.objects.values(\n        doc_id=F(\"id\"),\n        project_name=F(\"name\"),\n        doc_last_accessed=F(\"userprojectattribute__last_accessed\"),\n    ).filter(member=user_id)\n\n    project_group = (\n        ProjectGroup.objects.values(\n            doc_id=F(\"project_access__id\"),\n            project_name=F(\"project_access__name\"),\n            doc_last_accessed=F(\n                \"project_access__userprojectattribute__last_accessed\"\n            ),\n        )\n        .filter(member=user_id)\n        .order_by(\n            \"project_access__name\",\n            \"project_access__id\",\n        )\n        .distinct(\"project_access__name\")\n    )\n\n    if documents_owner:\n        for record in list(documents_owner):\n            documents_combined.append(record)\n\n    if documents_member:\n        for record in documents_member:\n            documents_combined.append(record)\n\n    if project_group:\n        for record in project_group:\n            documents_combined.append(record)\n\n    documents_combined = list(\n        {tuple(sorted(d.items())): d for d in documents_combined}.values()\n    )\n\n    for i in range(len(documents_combined)):\n        if documents_combined[i][\"doc_last_accessed\"] != None:\n            documents_combined[i][\"doc_last_accessed\"] = documents_combined[i][\n                \"doc_last_accessed\"\n            ].replace(tzinfo=None)\n\n    documents_sorted = sorted(\n        documents_combined,\n        key=lambda x: (\n            x[\"doc_last_accessed\"] or datetime.min,\n            x[\"doc_id\"],\n        ),\n        reverse=True,\n    )\n\n    documents_sorted = [\n        item\n        for item in documents_sorted\n        if item\n        != {\n            \"doc_id\": None,\n            \"project_name\": None,\n            \"doc_last_accessed\": None,\n        }\n    ]\n\n    \"\"\"if documents_sorted == [{}]:\n        documents_sorted = []\"\"\"\n\n    return documents_sorted\n</code></pre>"},{"location":"code/django/views/#views.view_docs","title":"<code>view_docs(request, project_id, doc_path='')</code>","text":"<p>Delivers controlled access to static site material</p> <p>Delivers controlled access to static site pages. It uses the NGINX X-Accel-Redirect. Depending on if the project's documents have private, member or public access, the user will be able to view the documents. Hence, access to the static pages are also dependent on if the user is authenticated.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>HttpRequest</code> <p>request from user</p> required <code>project_id</code> <code>str</code> <p>primary key of project</p> required <code>doc_path</code> <code>str</code> <p>path to the document</p> <code>''</code> <p>Returns:</p> Name Type Description <code>HttpResponse</code> <code>HttpResponse</code> <p>for loading the correct webpage</p> Source code in <code>app/dcsp/app/views.py</code> <pre><code>def view_docs(\n    request: HttpRequest,\n    project_id: str,\n    doc_path: str = \"\",\n) -&gt; HttpResponse:\n    \"\"\"Delivers controlled access to static site material\n\n    Delivers controlled access to static site pages. It uses the NGINX\n    X-Accel-Redirect. Depending on if the project's documents have private,\n    member or public access, the user will be able to view the documents.\n    Hence, access to the static pages are also dependent on if the user is\n    authenticated.\n\n    Args:\n        request (HttpRequest): request from user\n        project_id (str): primary key of project\n        doc_path (str): path to the document\n\n    Returns:\n        HttpResponse: for loading the correct webpage\n    \"\"\"\n    project_id_int: int\n    accessible_projects: list[dict[str, str]] = []\n    internal_path: str = \"\"\n    mkdocs_control: Optional[MkdocsControl] = None\n    file: Optional[TextIO] = None\n    document_content = \"\"\n    context: dict[str, Any] = {}\n    content_type: str = \"invalid\"\n    file_extension: str = \"\"\n    key: str = \"\"\n    value: str = \"\"\n    response: Optional[HttpResponse] = None\n\n    if project_id.isdigit():\n        project_id_int = int(project_id)\n    else:\n        return custom_404(request)\n\n    if not Project.objects.filter(id=project_id_int).exists():\n        messages.error(request, f\"'Project { project_id }' does not exist\")\n        return custom_404(request)\n\n    project = Project.objects.get(id=project_id)\n\n    if project.access == ViewAccess.MEMBERS:\n        if not request.user.is_authenticated:\n            messages.error(\n                request,\n                f\"You do not have access to 'project { project_id }'. \"\n                \"This is a members only project.\",\n            )\n            return custom_403(request)\n\n    elif project.access == ViewAccess.PRIVATE:\n        accessible_projects = user_accessible_projects(request)\n        if not any(\n            doc for doc in accessible_projects if doc[\"doc_id\"] == project_id\n        ):\n            messages.error(\n                request, f\"You do not have access to 'project { project_id }'.\"\n            )\n            return custom_403(request)\n\n    internal_path = str(\n        Path(c.DOCUMENTATION_PAGES) / f\"project_{project_id}\" / doc_path\n    )\n\n    file_extension = Path(internal_path).suffix[1:]\n\n    if file_extension == \"html\":\n        mkdocs_control = MkdocsControl(project_id)\n        mkdocs_control.build_documents()\n\n    if not Path(internal_path).is_file():\n        messages.error(request, f\"File '{ doc_path }' does not exist.\")\n        return custom_404(request)\n\n    if file_extension == \"html\":\n        file = open(internal_path, \"r\")\n        document_content = file.read()\n        context = {\n            \"document_content\": document_content,\n            \"project_id\": project_id,\n        }\n        return render(\n            request,\n            \"document_serve.html\",\n            context | std_context(project_id_int),\n        )\n    else:\n        for key, value in c.MIME_TYPES.items():\n            if file_extension == key:\n                content_type = value\n                break\n\n        response = HttpResponse(content_type=content_type)\n        response[\"X-Accel-Redirect\"] = internal_path\n        return response\n</code></pre>"},{"location":"code/functions/custom_exceptions/","title":"Custom exceptions","text":"<p>Custom exceptions</p> <p>Some custom excetions.</p> <p>Functions:</p> Name Description <code>RepositoryAccessException</code> <p>Exception raised when the external repository is not accessible or does not exist.</p>"},{"location":"code/functions/custom_exceptions/#functions.custom_exceptions.RepositoryAccessException","title":"<code>RepositoryAccessException</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Exception raised when the external repository is not accessible or does not exist.</p> Source code in <code>app/dcsp/app/functions/custom_exceptions.py</code> <pre><code>class RepositoryAccessException(Exception):\n    \"\"\"Exception raised when the external repository is not accessible or does not exist.\"\"\"\n\n    def __init__(self, repo_url: str) -&gt; None:\n        super().__init__(\n            f\"The external repository '{repo_url}' does not exist or is not accessible with your credentials\"\n        )\n</code></pre>"},{"location":"code/functions/doctring_manipulation/","title":"Docstring Manipulation","text":"<p>Extracts docstrings from Python files</p> class <p>DocstringManipulation: Extracts docstrings from Python files.</p>"},{"location":"code/functions/doctring_manipulation/#functions.docstring_manipulation.DocstringManipulation","title":"<code>DocstringManipulation</code>","text":"<p>Extracts docstrings from Python files</p> <p>Extracts docstrings from Python files.</p> <p>Methods:</p> Name Description <code>docstring_all</code> <p>Matches hazards in markdown files with code files.</p> <code>extract_docstrings</code> <p>Extracts docstrings from Python files.</p> <code>extract_hazards</code> <p>Extracts hazards from Python files.</p> Source code in <code>app/dcsp/app/functions/docstring_manipulation.py</code> <pre><code>class DocstringManipulation:\n    \"\"\"Extracts docstrings from Python files\n\n    Extracts docstrings from Python files.\n\n    functions:\n        docstring_all: Matches hazards in markdown files with code files.\n        extract_docstrings: Extracts docstrings from Python files.\n        extract_hazards: Extracts hazards from Python files.\n    \"\"\"\n\n    def __init__(self, project_id: int) -&gt; None:\n        self.project_id: int = project_id\n        return\n\n    def docstring_all(self) -&gt; list[dict[str, Any]]:\n        \"\"\"Matches hazards in markdown files with code files\n\n        Searches for hazards in markdown files and matches them with the python\n        files.\n\n        Args:\n            project_id (int): The project id.\n\n        Returns:\n            list[dict[str, Any]]: A list of dictionaries containing the file\n                                  path, function name, code path and hazards.\n        \"\"\"\n        docs_folder: str = (\n            f\"{ c.PROJECTS_FOLDER }project_{ self.project_id }\"\n            f\"/{ c.CLINICAL_SAFETY_FOLDER }docs/\"\n        )\n        markdown_files: Optional[Generator[Path, None, None]] = None\n        project_folder: str = (\n            f\"{ c.PROJECTS_FOLDER }project_{ self.project_id }/\"\n        )\n        function_paths: list[Any] = []\n        file_path: Optional[Path] = None\n        lines: list[str] = []\n        matching_lines: list[str] = []\n        hazard_docs_attributes: list[dict[str, Any]] = []\n        index: int = 0\n        function_info: dict[str, Any] = {}\n        code_file: str = \"\"\n        code_file_path: Path\n        hazards: list[dict[str, Any]] = []\n\n        if not Path(docs_folder).exists():\n            return []\n\n        if not Path(project_folder).exists():\n            return []\n\n        markdown_files = Path(docs_folder).rglob(\"*.md\")\n\n        # list used here as Path is a Generator, and cannot be called twice\n        # in later code.\n        function_paths = list(Path(project_folder).rglob(\"*.py\"))\n\n        for file_path in markdown_files:\n            with open(file_path, \"r\") as file:\n                lines = file.readlines()\n                matching_lines = [\n                    f\"{ line.lstrip().replace(':::', '').strip() }.py\"\n                    for line in lines\n                    if line.startswith(\":::\")\n                ]\n\n                if matching_lines:\n                    for matching_line in matching_lines:\n                        hazard_docs_attributes.append(\n                            {\n                                \"mk_file_path\": str(file_path).replace(\n                                    docs_folder, \"\"\n                                ),\n                                \"code_file\": matching_line,\n                            }\n                        )\n\n        for index, function_info in enumerate(hazard_docs_attributes):\n            code_file = function_info[\"code_file\"]\n            for code_file_path in function_paths:\n                if code_file_path.name == code_file:\n                    hazard_docs_attributes[index][\"code_file_path\"] = str(\n                        code_file_path\n                    )\n                    hazards = self.extract_hazards(str(code_file_path))\n                    if hazards:\n                        hazard_docs_attributes[index][\"hazards\"] = hazards\n\n        hazard_docs_attributes = [\n            item for item in hazard_docs_attributes if \"hazards\" in item\n        ]\n\n        return hazard_docs_attributes\n\n    def extract_docstrings(self, file_path: str) -&gt; list[Tuple[str, Any]]:\n        \"\"\"Extracts docstrings from Python files\n\n        Extracts docstrings from Python files.\n\n        Args:\n            file_path (str): The file path.\n\n        Returns:\n            list[Tuple[str, Any]]: A list of tuples containing the subroutine\n                                        name and docstring.\n        \"\"\"\n        docstrings: list[Tuple[str, Any]] = []\n        file: Optional[TextIO] = None\n        tree: Optional[ast.AST] = None\n        node: Optional[ast.AST] = None\n\n        if not Path(file_path).exists():\n            return []\n\n        with open(file_path, \"r\") as file:\n            file_contents = file.read()\n            tree = ast.parse(file_contents, filename=file_path)\n\n        for node in ast.walk(tree):\n            if isinstance(\n                node,\n                (\n                    ast.FunctionDef,\n                    ast.AsyncFunctionDef,\n                ),\n            ):\n                if (\n                    node.body\n                    and isinstance(node.body[0], ast.Expr)\n                    and isinstance(\n                        node.body[0].value,\n                        ast.Constant,\n                    )\n                ):\n                    docstrings.append(\n                        (\n                            node.name,  # This is named sub_routine elsewhere\n                            node.body[0].value.s,\n                        )\n                    )\n\n        return docstrings\n\n    def extract_hazards(self, file_path: str) -&gt; list[dict[str, Any]]:\n        \"\"\"Extracts hazards from Python files\n\n        Extracts hazards from Python files.\n\n        Args:\n            file_path (str): The file path.\n\n        Returns:\n            list[dict[str, Any]]: A list of dictionaries containing the module\n                                  name, hazard name and hazard number.\n        \"\"\"\n        sub_routine: str = \"\"\n        docstring: str = \"\"\n        docstrings: Optional[list[Tuple[str, Any]]] = None\n        HAZARD_TITLE: str = \"Hazards:\"\n        section_found: bool = False\n        hazard_number: Optional[str] = None\n        line: str = \"\"\n        match: Optional[re.Match[Any]] = None\n        section_content: list[dict[str, Any]] = []\n\n        if not Path(file_path).exists():\n            return []\n\n        docstrings = self.extract_docstrings(file_path)\n\n        for (\n            sub_routine,\n            docstring,\n        ) in docstrings:\n            if HAZARD_TITLE in docstring:\n                section_found = False\n                hazard_number = None\n\n                for line in docstring.splitlines():\n                    if section_found:\n                        if line.strip() == \"\" or '\"\"\"' in line:\n                            section_found = False\n\n                        else:\n                            # Look for value between parentheses\n                            match = re.search(r\"\\(([^)]+)\\)\", line)\n                            hazard_number = (\n                                match.group(1).strip() if match else None\n                            )\n\n                            if not str(hazard_number).isdigit():\n                                hazard_number = None\n\n                            section_content.append(\n                                {\n                                    \"sub_routine\": sub_routine,\n                                    \"hazard_full\": line.lstrip(),\n                                    \"hazard_number\": hazard_number,\n                                }\n                            )\n                    elif line.strip() == f\"{ HAZARD_TITLE }\":\n                        section_found = True\n\n        return section_content\n</code></pre>"},{"location":"code/functions/doctring_manipulation/#functions.docstring_manipulation.DocstringManipulation.docstring_all","title":"<code>docstring_all()</code>","text":"<p>Matches hazards in markdown files with code files</p> <p>Searches for hazards in markdown files and matches them with the python files.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>int</code> <p>The project id.</p> required <p>Returns:</p> Type Description <code>list[dict[str, Any]]</code> <p>list[dict[str, Any]]: A list of dictionaries containing the file                   path, function name, code path and hazards.</p> Source code in <code>app/dcsp/app/functions/docstring_manipulation.py</code> <pre><code>def docstring_all(self) -&gt; list[dict[str, Any]]:\n    \"\"\"Matches hazards in markdown files with code files\n\n    Searches for hazards in markdown files and matches them with the python\n    files.\n\n    Args:\n        project_id (int): The project id.\n\n    Returns:\n        list[dict[str, Any]]: A list of dictionaries containing the file\n                              path, function name, code path and hazards.\n    \"\"\"\n    docs_folder: str = (\n        f\"{ c.PROJECTS_FOLDER }project_{ self.project_id }\"\n        f\"/{ c.CLINICAL_SAFETY_FOLDER }docs/\"\n    )\n    markdown_files: Optional[Generator[Path, None, None]] = None\n    project_folder: str = (\n        f\"{ c.PROJECTS_FOLDER }project_{ self.project_id }/\"\n    )\n    function_paths: list[Any] = []\n    file_path: Optional[Path] = None\n    lines: list[str] = []\n    matching_lines: list[str] = []\n    hazard_docs_attributes: list[dict[str, Any]] = []\n    index: int = 0\n    function_info: dict[str, Any] = {}\n    code_file: str = \"\"\n    code_file_path: Path\n    hazards: list[dict[str, Any]] = []\n\n    if not Path(docs_folder).exists():\n        return []\n\n    if not Path(project_folder).exists():\n        return []\n\n    markdown_files = Path(docs_folder).rglob(\"*.md\")\n\n    # list used here as Path is a Generator, and cannot be called twice\n    # in later code.\n    function_paths = list(Path(project_folder).rglob(\"*.py\"))\n\n    for file_path in markdown_files:\n        with open(file_path, \"r\") as file:\n            lines = file.readlines()\n            matching_lines = [\n                f\"{ line.lstrip().replace(':::', '').strip() }.py\"\n                for line in lines\n                if line.startswith(\":::\")\n            ]\n\n            if matching_lines:\n                for matching_line in matching_lines:\n                    hazard_docs_attributes.append(\n                        {\n                            \"mk_file_path\": str(file_path).replace(\n                                docs_folder, \"\"\n                            ),\n                            \"code_file\": matching_line,\n                        }\n                    )\n\n    for index, function_info in enumerate(hazard_docs_attributes):\n        code_file = function_info[\"code_file\"]\n        for code_file_path in function_paths:\n            if code_file_path.name == code_file:\n                hazard_docs_attributes[index][\"code_file_path\"] = str(\n                    code_file_path\n                )\n                hazards = self.extract_hazards(str(code_file_path))\n                if hazards:\n                    hazard_docs_attributes[index][\"hazards\"] = hazards\n\n    hazard_docs_attributes = [\n        item for item in hazard_docs_attributes if \"hazards\" in item\n    ]\n\n    return hazard_docs_attributes\n</code></pre>"},{"location":"code/functions/doctring_manipulation/#functions.docstring_manipulation.DocstringManipulation.extract_docstrings","title":"<code>extract_docstrings(file_path)</code>","text":"<p>Extracts docstrings from Python files</p> <p>Extracts docstrings from Python files.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>The file path.</p> required <p>Returns:</p> Type Description <code>list[Tuple[str, Any]]</code> <p>list[Tuple[str, Any]]: A list of tuples containing the subroutine                         name and docstring.</p> Source code in <code>app/dcsp/app/functions/docstring_manipulation.py</code> <pre><code>def extract_docstrings(self, file_path: str) -&gt; list[Tuple[str, Any]]:\n    \"\"\"Extracts docstrings from Python files\n\n    Extracts docstrings from Python files.\n\n    Args:\n        file_path (str): The file path.\n\n    Returns:\n        list[Tuple[str, Any]]: A list of tuples containing the subroutine\n                                    name and docstring.\n    \"\"\"\n    docstrings: list[Tuple[str, Any]] = []\n    file: Optional[TextIO] = None\n    tree: Optional[ast.AST] = None\n    node: Optional[ast.AST] = None\n\n    if not Path(file_path).exists():\n        return []\n\n    with open(file_path, \"r\") as file:\n        file_contents = file.read()\n        tree = ast.parse(file_contents, filename=file_path)\n\n    for node in ast.walk(tree):\n        if isinstance(\n            node,\n            (\n                ast.FunctionDef,\n                ast.AsyncFunctionDef,\n            ),\n        ):\n            if (\n                node.body\n                and isinstance(node.body[0], ast.Expr)\n                and isinstance(\n                    node.body[0].value,\n                    ast.Constant,\n                )\n            ):\n                docstrings.append(\n                    (\n                        node.name,  # This is named sub_routine elsewhere\n                        node.body[0].value.s,\n                    )\n                )\n\n    return docstrings\n</code></pre>"},{"location":"code/functions/doctring_manipulation/#functions.docstring_manipulation.DocstringManipulation.extract_hazards","title":"<code>extract_hazards(file_path)</code>","text":"<p>Extracts hazards from Python files</p> <p>Extracts hazards from Python files.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>The file path.</p> required <p>Returns:</p> Type Description <code>list[dict[str, Any]]</code> <p>list[dict[str, Any]]: A list of dictionaries containing the module                   name, hazard name and hazard number.</p> Source code in <code>app/dcsp/app/functions/docstring_manipulation.py</code> <pre><code>def extract_hazards(self, file_path: str) -&gt; list[dict[str, Any]]:\n    \"\"\"Extracts hazards from Python files\n\n    Extracts hazards from Python files.\n\n    Args:\n        file_path (str): The file path.\n\n    Returns:\n        list[dict[str, Any]]: A list of dictionaries containing the module\n                              name, hazard name and hazard number.\n    \"\"\"\n    sub_routine: str = \"\"\n    docstring: str = \"\"\n    docstrings: Optional[list[Tuple[str, Any]]] = None\n    HAZARD_TITLE: str = \"Hazards:\"\n    section_found: bool = False\n    hazard_number: Optional[str] = None\n    line: str = \"\"\n    match: Optional[re.Match[Any]] = None\n    section_content: list[dict[str, Any]] = []\n\n    if not Path(file_path).exists():\n        return []\n\n    docstrings = self.extract_docstrings(file_path)\n\n    for (\n        sub_routine,\n        docstring,\n    ) in docstrings:\n        if HAZARD_TITLE in docstring:\n            section_found = False\n            hazard_number = None\n\n            for line in docstring.splitlines():\n                if section_found:\n                    if line.strip() == \"\" or '\"\"\"' in line:\n                        section_found = False\n\n                    else:\n                        # Look for value between parentheses\n                        match = re.search(r\"\\(([^)]+)\\)\", line)\n                        hazard_number = (\n                            match.group(1).strip() if match else None\n                        )\n\n                        if not str(hazard_number).isdigit():\n                            hazard_number = None\n\n                        section_content.append(\n                            {\n                                \"sub_routine\": sub_routine,\n                                \"hazard_full\": line.lstrip(),\n                                \"hazard_number\": hazard_number,\n                            }\n                        )\n                elif line.strip() == f\"{ HAZARD_TITLE }\":\n                    section_found = True\n\n    return section_content\n</code></pre>"},{"location":"code/functions/email_functions/","title":"Email Functions","text":"<p>Basic email testing</p> <p>This module needs building out further, but at the moment can test if the syntax of a given email address is correct.</p> <p>Classes:</p> Name Description <code>EmailFunctions</code> <p>placeholder</p>"},{"location":"code/functions/email_functions/#functions.email_functions.EmailFunctions","title":"<code>EmailFunctions</code>","text":"Source code in <code>app/dcsp/app/functions/email_functions.py</code> <pre><code>class EmailFunctions:\n    _valid_email_regex: str = (\n        r\"\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b\"\n    )\n\n    def __init__(self) -&gt; None:\n        \"\"\"Init\n\n        Nothing is done in the initialisation phase\n        \"\"\"\n        return\n\n    def valid_syntax(self, email: str) -&gt; bool:\n        \"\"\"Checks if the syntax of an email string is corrent\n\n        This function only checks if the syntax of an email is correct. It does\n        not confirm if the email exists or that the end-server is able to\n        process the email\n\n        Args:\n            email (str): the email address to be assesed.\n\n        Returns:\n            bool: True if a valid email, otherwise False.\n        \"\"\"\n        if re.fullmatch(self._valid_email_regex, email):\n            return True\n\n        else:\n            return False\n</code></pre>"},{"location":"code/functions/email_functions/#functions.email_functions.EmailFunctions.__init__","title":"<code>__init__()</code>","text":"<p>Init</p> <p>Nothing is done in the initialisation phase</p> Source code in <code>app/dcsp/app/functions/email_functions.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Init\n\n    Nothing is done in the initialisation phase\n    \"\"\"\n    return\n</code></pre>"},{"location":"code/functions/email_functions/#functions.email_functions.EmailFunctions.valid_syntax","title":"<code>valid_syntax(email)</code>","text":"<p>Checks if the syntax of an email string is corrent</p> <p>This function only checks if the syntax of an email is correct. It does not confirm if the email exists or that the end-server is able to process the email</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>the email address to be assesed.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if a valid email, otherwise False.</p> Source code in <code>app/dcsp/app/functions/email_functions.py</code> <pre><code>def valid_syntax(self, email: str) -&gt; bool:\n    \"\"\"Checks if the syntax of an email string is corrent\n\n    This function only checks if the syntax of an email is correct. It does\n    not confirm if the email exists or that the end-server is able to\n    process the email\n\n    Args:\n        email (str): the email address to be assesed.\n\n    Returns:\n        bool: True if a valid email, otherwise False.\n    \"\"\"\n    if re.fullmatch(self._valid_email_regex, email):\n        return True\n\n    else:\n        return False\n</code></pre>"},{"location":"code/functions/env_manipulation/","title":"Env manipulation","text":"<p>env manipulator</p> <p>Better live env manipulation than standard python library.</p> <p>Classes:</p> Name Description <code>ENVManipulator</code> <p>placeholder</p>"},{"location":"code/functions/env_manipulation/#functions.env_manipulation.ENVManipulator","title":"<code>ENVManipulator</code>","text":"Source code in <code>app/dcsp/app/functions/env_manipulation.py</code> <pre><code>class ENVManipulator:\n    def __init__(\n        self,\n        env_path: str = c.ENV_PATH_PLACEHOLDERS,\n    ) -&gt; None:\n        \"\"\"Initialise the env path\n\n        Initialise the env path\n\n        Args:\n            env_path (str): location of the env file. Sets to c.ENV_PATH_PLACEHOLDERS if not\n                            sets.\n        \"\"\"\n        self.env_path = env_path\n        return\n\n    def delete(self, variable_to_delete: str) -&gt; bool:\n        \"\"\"Remove a variable from the env file\n\n        Removes the variable from the env file.\n\n        Args:\n            variable_to_delete (str): as name.\n\n        Returns:\n            bool: True if was present and deleted, False if was never present.\n        \"\"\"\n        variable_set: bool = False\n        env_variables = dotenv_values(self.env_path)  # TODO need type\n        key: str = \"\"\n        value2: str | None = \"\"\n        key2: str | None = \"\"\n\n        for key in env_variables:\n            if key == variable_to_delete:\n                variable_set = True\n\n        if variable_set == True:\n            del env_variables[variable_to_delete]\n            open(self.env_path, \"w\").close()\n\n            for (\n                key2,\n                value2,\n            ) in env_variables.items():\n                set_key(\n                    self.env_path,\n                    str(key2),\n                    str(value2),\n                )\n\n        return variable_set\n\n    def delete_all(self) -&gt; None:\n        \"\"\"Remove all variables from env file\n\n        Removes all the variables from the env file, keeping the file itself\n        however.\n        \"\"\"\n        open(self.env_path, \"w\").close()\n        return\n\n    def add(self, variable: str, value: str) -&gt; None:\n        \"\"\"Add or change a variable in the env file\n\n        Add or change a variable in the env file\n\n        Args:\n            variable (str): name of variable.\n            value (str): value to set.\n\n        Returns:\n            None\n        \"\"\"\n        set_key(self.env_path, variable, value)\n        return\n\n    def read(self, key_to_read: str) -&gt; str:\n        \"\"\"Reads a variable from env file\n\n        Reads a variable from an env file\n\n        Args:\n            key_to_read (str): the variable to read.\n\n        Returns:\n            str: value of the variable. This will return empty string (\"\")\n                 if the variable has not been set.\n        \"\"\"\n        dot_values: dict[str, str | None] = dotenv_values(self.env_path)\n        return str(dot_values.get(key_to_read) or \"\")\n\n    def read_all(self) -&gt; dict[str, str]:\n        \"\"\"Reads all variables from env file\n\n        Reads all variable from an env file and returns with keys in alphabetical\n        order.\n\n        Returns:\n            dict[str, str]: returns all variables in the env file. This will\n                            return empty string (\"\") if the variable has not been\n                            set.\n        \"\"\"\n        dot_values_raw: dict[str, str | None] = dotenv_values(self.env_path)\n        dot_values_clean: dict[str, str] = {}\n        key: str = \"\"\n        value: str | None = \"\"\n        sorted_dict: dict[str, str]\n\n        for key, value in dot_values_raw.items():\n            dot_values_clean[key] = str(value or \"\")\n\n        keys_list = list(dot_values_clean.keys())\n        keys_list.sort(key=str.lower)\n        sorted_dict = {i: dot_values_clean[i] for i in keys_list}\n        return sorted_dict\n</code></pre>"},{"location":"code/functions/env_manipulation/#functions.env_manipulation.ENVManipulator.__init__","title":"<code>__init__(env_path=c.ENV_PATH_PLACEHOLDERS)</code>","text":"<p>Initialise the env path</p> <p>Initialise the env path</p> <p>Parameters:</p> Name Type Description Default <code>env_path</code> <code>str</code> <p>location of the env file. Sets to c.ENV_PATH_PLACEHOLDERS if not             sets.</p> <code>ENV_PATH_PLACEHOLDERS</code> Source code in <code>app/dcsp/app/functions/env_manipulation.py</code> <pre><code>def __init__(\n    self,\n    env_path: str = c.ENV_PATH_PLACEHOLDERS,\n) -&gt; None:\n    \"\"\"Initialise the env path\n\n    Initialise the env path\n\n    Args:\n        env_path (str): location of the env file. Sets to c.ENV_PATH_PLACEHOLDERS if not\n                        sets.\n    \"\"\"\n    self.env_path = env_path\n    return\n</code></pre>"},{"location":"code/functions/env_manipulation/#functions.env_manipulation.ENVManipulator.add","title":"<code>add(variable, value)</code>","text":"<p>Add or change a variable in the env file</p> <p>Add or change a variable in the env file</p> <p>Parameters:</p> Name Type Description Default <code>variable</code> <code>str</code> <p>name of variable.</p> required <code>value</code> <code>str</code> <p>value to set.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>app/dcsp/app/functions/env_manipulation.py</code> <pre><code>def add(self, variable: str, value: str) -&gt; None:\n    \"\"\"Add or change a variable in the env file\n\n    Add or change a variable in the env file\n\n    Args:\n        variable (str): name of variable.\n        value (str): value to set.\n\n    Returns:\n        None\n    \"\"\"\n    set_key(self.env_path, variable, value)\n    return\n</code></pre>"},{"location":"code/functions/env_manipulation/#functions.env_manipulation.ENVManipulator.delete","title":"<code>delete(variable_to_delete)</code>","text":"<p>Remove a variable from the env file</p> <p>Removes the variable from the env file.</p> <p>Parameters:</p> Name Type Description Default <code>variable_to_delete</code> <code>str</code> <p>as name.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if was present and deleted, False if was never present.</p> Source code in <code>app/dcsp/app/functions/env_manipulation.py</code> <pre><code>def delete(self, variable_to_delete: str) -&gt; bool:\n    \"\"\"Remove a variable from the env file\n\n    Removes the variable from the env file.\n\n    Args:\n        variable_to_delete (str): as name.\n\n    Returns:\n        bool: True if was present and deleted, False if was never present.\n    \"\"\"\n    variable_set: bool = False\n    env_variables = dotenv_values(self.env_path)  # TODO need type\n    key: str = \"\"\n    value2: str | None = \"\"\n    key2: str | None = \"\"\n\n    for key in env_variables:\n        if key == variable_to_delete:\n            variable_set = True\n\n    if variable_set == True:\n        del env_variables[variable_to_delete]\n        open(self.env_path, \"w\").close()\n\n        for (\n            key2,\n            value2,\n        ) in env_variables.items():\n            set_key(\n                self.env_path,\n                str(key2),\n                str(value2),\n            )\n\n    return variable_set\n</code></pre>"},{"location":"code/functions/env_manipulation/#functions.env_manipulation.ENVManipulator.delete_all","title":"<code>delete_all()</code>","text":"<p>Remove all variables from env file</p> <p>Removes all the variables from the env file, keeping the file itself however.</p> Source code in <code>app/dcsp/app/functions/env_manipulation.py</code> <pre><code>def delete_all(self) -&gt; None:\n    \"\"\"Remove all variables from env file\n\n    Removes all the variables from the env file, keeping the file itself\n    however.\n    \"\"\"\n    open(self.env_path, \"w\").close()\n    return\n</code></pre>"},{"location":"code/functions/env_manipulation/#functions.env_manipulation.ENVManipulator.read","title":"<code>read(key_to_read)</code>","text":"<p>Reads a variable from env file</p> <p>Reads a variable from an env file</p> <p>Parameters:</p> Name Type Description Default <code>key_to_read</code> <code>str</code> <p>the variable to read.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>value of the variable. This will return empty string (\"\")  if the variable has not been set.</p> Source code in <code>app/dcsp/app/functions/env_manipulation.py</code> <pre><code>def read(self, key_to_read: str) -&gt; str:\n    \"\"\"Reads a variable from env file\n\n    Reads a variable from an env file\n\n    Args:\n        key_to_read (str): the variable to read.\n\n    Returns:\n        str: value of the variable. This will return empty string (\"\")\n             if the variable has not been set.\n    \"\"\"\n    dot_values: dict[str, str | None] = dotenv_values(self.env_path)\n    return str(dot_values.get(key_to_read) or \"\")\n</code></pre>"},{"location":"code/functions/env_manipulation/#functions.env_manipulation.ENVManipulator.read_all","title":"<code>read_all()</code>","text":"<p>Reads all variables from env file</p> <p>Reads all variable from an env file and returns with keys in alphabetical order.</p> <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>dict[str, str]: returns all variables in the env file. This will             return empty string (\"\") if the variable has not been             set.</p> Source code in <code>app/dcsp/app/functions/env_manipulation.py</code> <pre><code>def read_all(self) -&gt; dict[str, str]:\n    \"\"\"Reads all variables from env file\n\n    Reads all variable from an env file and returns with keys in alphabetical\n    order.\n\n    Returns:\n        dict[str, str]: returns all variables in the env file. This will\n                        return empty string (\"\") if the variable has not been\n                        set.\n    \"\"\"\n    dot_values_raw: dict[str, str | None] = dotenv_values(self.env_path)\n    dot_values_clean: dict[str, str] = {}\n    key: str = \"\"\n    value: str | None = \"\"\n    sorted_dict: dict[str, str]\n\n    for key, value in dot_values_raw.items():\n        dot_values_clean[key] = str(value or \"\")\n\n    keys_list = list(dot_values_clean.keys())\n    keys_list.sort(key=str.lower)\n    sorted_dict = {i: dot_values_clean[i] for i in keys_list}\n    return sorted_dict\n</code></pre>"},{"location":"code/functions/git_control/","title":"Git controller","text":"<p>Management of git and GitHub</p> <p>If no organisation is provided, repos will be presumed to be stored under username on Github</p> <p>Classes:</p> Name Description <code>GitController</code> <p>handle git and GitHub functionality</p>"},{"location":"code/functions/git_control/#functions.git_control.GitController","title":"<code>GitController</code>","text":"Source code in <code>app/dcsp/app/functions/git_control.py</code> <pre><code>class GitController:\n    def __init__(self) -&gt; None:\n        return\n\n    def clone(self, from_url: str, to_folder: str) -&gt; None:\n        \"\"\"Clone a repository from GitHub\"\"\"\n        repo = Repo.clone_from(\n            f\"{ from_url }.git\",\n            to_folder,\n        )\n\n        return\n</code></pre>"},{"location":"code/functions/git_control/#functions.git_control.GitController.clone","title":"<code>clone(from_url, to_folder)</code>","text":"<p>Clone a repository from GitHub</p> Source code in <code>app/dcsp/app/functions/git_control.py</code> <pre><code>def clone(self, from_url: str, to_folder: str) -&gt; None:\n    \"\"\"Clone a repository from GitHub\"\"\"\n    repo = Repo.clone_from(\n        f\"{ from_url }.git\",\n        to_folder,\n    )\n\n    return\n</code></pre>"},{"location":"code/functions/git_control/#functions.git_control.GitController_on_hold","title":"<code>GitController_on_hold</code>","text":"Source code in <code>app/dcsp/app/functions/git_control.py</code> <pre><code>class GitController_on_hold:\n    def __init__(\n        self,\n        github_username: str = \"\",\n        email: str = \"\",\n        github_organisation: str = \"\",\n        github_repo: str = c.REPO_NAME,\n        default_external_repository_token: str = \"\",\n        repo_path_local: str = c.REPO_PATH_LOCAL,\n        env_location: str = c.ENV_PATH_PLACEHOLDERS,\n    ) -&gt; None:\n        \"\"\"Initialising GitController class\n\n        Initialisation of the git and GitHub functionality.\n\n        Args:\n            github_username (str): the user's GitHub personal username.\n            email (str): the user's personal email address.\n            github_organisation (str): the organisation that the user wishes to\n                                       associate repositories with. If this an\n                                       empty string is supplied then username is\n                                       used as storage location for repositories.\n            github_repo (str): Name of the GitHub repository.\n            default_external_repository_token (str): GitHub token.\n            repo_path_local (str): Local name of repository.\n            env_location (str): Location of .env file. Mainly changed for unit\n                                testing purposes.\n\n        Raises:\n            ValueError: if a empty string is supplied as the env_location.\n            ValueError: if env_location is an invalid file path.\n            ValueError: if no GitHub username is supplied as an argument or in\n                        the .env file.\n            ValueError: if no email is supplied as an argument or in the .env\n                        file.\n            ValueError: if invalid syntax of email (does not check to see if a\n                        current and working email address).\n            ValueError: if github_repo is set to an empty string.\n            ValueError: if no default_external_repository_token is supplied as an argument or in\n                        the .env file.\n            ValueError: if repo_path_local is set to an empty string.\n            FileNotFoundError: if repo_path_local points to a invalid or non-\n                               existing directory.\n        \"\"\"  # nosec B107\n        self.github_username: str = \"\"\n        self.email: str = \"\"\n        self.github_organisation: str = \"\"\n        self.default_external_repository_token: str = \"\"\n\n        if env_location == \"\":\n            raise ValueError(f\".env location is set to empty string\")\n\n        if not os.path.isfile(env_location):\n            raise ValueError(\n                f\"'{ env_location }' path for .env file does not exist\"\n            )\n\n        dot_values = dotenv_values(env_location)\n\n        if github_username == \"\":\n            self.github_username = str(dot_values.get(\"GITHUB_USERNAME\") or \"\")\n            if self.github_username == \"\":\n                raise ValueError(\n                    f\"'{ c.EnvKeysPH.GITHUB_USERNAME.value }' has not been set as an argument or in .env\"\n                )\n        else:\n            self.github_username = github_username\n\n        if email == \"\":\n            self.email = str(dot_values.get(\"EMAIL\") or \"\")\n            if self.email == \"\":\n                raise ValueError(\n                    f\"'{ c.EnvKeysPH.EMAIL.value }' has not been set as an argument or in .env\"\n                )\n        else:\n            self.email = email\n\n        email_function = EmailFunctions()\n        if not email_function.valid_syntax(self.email):\n            raise ValueError(f\"Email address '{ self.email }' is invalid\")\n\n        if github_organisation == \"\":\n            self.github_organisation = str(\n                dot_values.get(\"GITHUB_ORGANISATION\" or \"\")\n            )\n        else:\n            self.github_organisation = github_organisation\n\n        if github_repo == \"\":\n            self.github_repo = str(dot_values.get(\"GITHUB_REPO\") or \"\")\n            if self.github_repo == \"\":\n                raise ValueError(\n                    f\"'{ c.EnvKeysPH.GITHUB_REPO.value }' has not been set as an argument or in .env\"\n                )\n        else:\n            self.github_repo = github_repo\n\n        if default_external_repository_token == \"\":  # nosec B105, B107\n            self.default_external_repository_token = str(\n                dot_values.get(\"GITHUB_TOKEN\") or \"\"\n            )\n            if (\n                self.default_external_repository_token == None\n                or self.default_external_repository_token == \"\"  # nosec B105\n            ):  # nosec B105, B107\n                raise ValueError(\n                    f\"'{ c.EnvKeysPH.GITHUB_TOKEN.value }' has not been set as an argument or in .env\"\n                )\n        else:\n            self.default_external_repository_token = (\n                default_external_repository_token\n            )\n\n        if repo_path_local == \"\":\n            raise ValueError(f\"'repo_path_local' has not been set\")\n        else:\n            self.repo_path_local = repo_path_local\n            if not os.path.isdir(repo_path_local):\n                raise FileNotFoundError(\n                    f\"'{ repo_path_local }' is not a valid path for 'repo_path_local'\"\n                )\n        return None\n\n    # TODO #28 - need to find a good way to see if github token and username pair is valid\n    # TODO #29 - need to handle 404, 500, Timeout and connection errors\n    def check_github_credentials(\n        self,\n    ) -&gt; dict[str, str | bool | None]:\n        \"\"\"Checking Github credentials\n\n        If no organisation is provided, then username will be used for repo storage location\n\n        Returns:\n            dict: a dictionary with 4 values covering the validity of the credentials supplied\n                  in the initialisation of the GitController class\n        \"\"\"\n        g: Github\n        github_username_exists: bool = False\n        github_organisation_exists: bool = False\n        repo_exists: bool = False\n        permission: str | None = None\n        results: dict[str, str | bool | None] = {}\n        username_request: Response\n        repo_request: Response\n        repo: Repository.Repository\n\n        # TODO ? manage rate limiters\n\n        try:\n            username_request = requests.get(\n                f\"https://api.github.com/users/{ self.github_username }\",\n                auth=(\n                    self.github_username,\n                    self.default_external_repository_token,\n                ),\n                timeout=10,\n            )\n        except requests.exceptions.ConnectionError:\n            raise requests.exceptions.ConnectionError(\n                \"No connection available to GitHub API\"\n            )\n        except requests.exceptions.Timeout:\n            raise requests.exceptions.Timeout(\n                \"Timeout while connecting to GitHub API\"\n            )\n\n        if username_request.status_code == 200:\n            github_username_exists = True\n        elif username_request.status_code == 404:\n            github_username_exists = False\n        else:\n            raise ValueError(\n                f\"Error with Github username checking. Returned value of: {username_request.status_code }\"\n            )\n\n        github_organisation_exists = self.organisation_exists(\n            self.github_organisation\n        )\n\n        try:\n            repo_request = requests.get(\n                f\"https://api.github.com/repos/{ self.repo_domain_name() }/{ self.github_repo }\",\n                auth=(\n                    self.github_organisation,\n                    self.default_external_repository_token,\n                ),\n                timeout=10,\n            )\n        except requests.exceptions.ConnectionError:\n            raise requests.exceptions.ConnectionError(\n                \"No connection available to GitHub API\"\n            )\n        except requests.exceptions.Timeout:\n            raise requests.exceptions.Timeout(\n                \"Timeout while connecting to GitHub API\"\n            )\n\n        if repo_request.status_code == 200:\n            repo_exists = True\n\n            # patch\n            g = Github(\n                self.github_username,\n                self.default_external_repository_token,\n            )\n            repo = g.get_repo(\n                f\"{ self.repo_domain_name() }/{ self.github_repo }\"\n            )\n\n            try:\n                permission = repo.get_collaborator_permission(\n                    self.github_username\n                )\n            except GithubException:\n                pass\n        elif repo_request.status_code == 404:\n            repo_exists = False\n        else:\n            raise ValueError(\n                f\"Error with Github repo checking. Returned value of: {repo_request.status_code }\"\n            )\n\n        results = {\n            \"github_username_exists\": github_username_exists,\n            \"github_organisation_exists\": github_organisation_exists,\n            \"repo_exists\": repo_exists,\n            \"permission\": permission,\n        }\n        return results\n\n    def organisation_exists(self, organisation: str) -&gt; bool:\n        \"\"\"Checks if the GitHub organisation exists\n\n        Checks to see if the provided organisation name exists. This utilises\n        authentification, so good credentitals are needed.\n\n        Args:\n            organisation (str): name of GitHub organisation to test.\n\n        Returns:\n            bool: True if exists, False if does not.\n\n        Raises:\n            ValueError: if bad return code from GET request\n        \"\"\"\n        organisation_request: Response\n        github_organisation_exists: bool = False\n\n        # TODO will need to manage other errors like time outs and rate limiters\n        try:\n            organisation_request = requests.get(\n                f\"https://api.github.com/users/{ organisation }\",\n                auth=(\n                    self.github_organisation,\n                    self.default_external_repository_token,\n                ),\n                timeout=10,\n            )\n        except requests.exceptions.ConnectionError:\n            raise requests.exceptions.ConnectionError(\n                \"No connection available to GitHub API\"\n            )\n        except requests.exceptions.Timeout:\n            raise requests.exceptions.Timeout(\n                \"Timeout while connecting to GitHub API\"\n            )\n\n        if organisation_request.status_code == 200:\n            github_organisation_exists = True\n        elif organisation_request.status_code == 404:\n            github_organisation_exists = False\n        else:\n            raise ValueError(\n                f\"Error with Github organisation checking. Returned value of: {organisation_request.status_code }\"\n            )\n\n        return github_organisation_exists\n\n    def get_repos(self, github_user_org: str) -&gt; list[str]:\n        \"\"\"Returns a list of repositories for a user or organisation\n\n        Gets a list of repositories under a specified user or organisation\n\n        Args:\n            github_user_org (str): the username or organisation to look for the\n                                   repositories under.\n\n        Returns:\n            list[str]: a list of repositories. Returns empty list if unsuccessful in\n                       getting.\n\n        Raises:\n            ValueError: if unable to get user or organisation.\n        \"\"\"\n        g: Github\n        github_user: NamedUser.NamedUser | AuthenticatedUser.AuthenticatedUser\n        repos_found: list[str] = []\n        repo: Repository.Repository\n\n        g = Github(\n            self.github_username,\n            self.default_external_repository_token,\n        )\n\n        try:\n            github_user = g.get_user(github_user_org)\n        except GithubException as error:\n            raise ValueError(\n                f\"Error with getting user / organisastion '{ github_user_org }', returned - '{ error.data['message'] }'\"\n            )\n        else:\n            for repo in github_user.get_repos():\n                repos_found.append(repo.name)\n\n        return repos_found\n\n    def current_repo_on_github(\n        self,\n        github_user_org: str,\n        github_repo: str,\n    ) -&gt; bool:\n        \"\"\"Checks if supplied repository is on GitHub\n\n        Checks if the supplied repository name is on GitHub, in the format\n        \"github_user_org/github_repo\".\n\n        Args:\n            github_user_org (str): the username or organisation that the\n                                   repository is stored under.\n            github_repo (str): the name of the GitHub repository.\n\n        Returns:\n            bool: True if is a current repository under the user/organisation\n                  or False if not.\n        \"\"\"\n        current_repos_on_github: list[str] = self.get_repos(github_user_org)\n        # print(\"\")\n        # print(str(current_repos_on_github))\n        if github_repo in current_repos_on_github:\n            return True\n        else:\n            return False\n\n    def create_repo(\n        self,\n        github_use_org: str,\n        github_repo: str,\n    ) -&gt; bool:\n        \"\"\"Create a new repository on GitHub\n\n        If does not already exist, this function will create a new repository\n        on GitHub.\n\n        Args:\n            github_use_org (str): username or organisation to create the new\n                                  repository under.\n            github_repo (str): name of new repository.\n\n        Returns:\n            bool: False if already exists. True if created.\n\n        Raises:\n            ValueError: if invalid credentials supplied to\n                        'current_repo_on_github'.\n        \"\"\"\n        g: Github\n        github_get: Organization.Organization\n\n        try:\n            if self.current_repo_on_github(github_use_org, github_repo):\n                return False\n        except ValueError as error:\n            raise ValueError(f\"{ error }\")\n\n        g = Github(\n            self.github_username,\n            self.default_external_repository_token,\n        )\n        github_get = g.get_organization(github_use_org)\n        github_get.create_repo(github_repo)\n        return True\n\n    def delete_repo(\n        self,\n        github_use_org: str,\n        github_repo: str,\n    ) -&gt; bool:\n        \"\"\"Delete a repository on GitHub\n\n        If in existence, then deletes repository on GitHub.\n\n        Args:\n            github_use_org (str): username or organisation where repository\n                                  is stored.\n            github_repo (str): name of repository to delete.\n\n        Returns:\n            bool: False if does not exist. True if exists and deleted.\n        \"\"\"\n        g: Github\n        github_get: Organization.Organization\n        repo: Repository.Repository\n\n        if not self.current_repo_on_github(github_use_org, github_repo):\n            return False\n\n        g = Github(\n            self.github_username,\n            self.default_external_repository_token,\n        )\n        github_get = g.get_organization(github_use_org)\n        repo = github_get.get_repo(github_repo)\n        repo.delete()\n        return True\n\n    # TODO #20 - needs lots of testing\n    # TODO - need to figure out if it failed\n    # TODO - also need to make sure a push to gh pages is set on Github\n    def commit_and_push(\n        self,\n        commit_message: str = \"Automated commit\",\n        verbose: bool = False,\n    ) -&gt; bool:\n        \"\"\"Commits changes and then pushes to repo\n\n        Initially checks if the git configs are set, and if not sets\n        The username and email. Then commits the changes with the supplied\n        message. If verbose is set to true, then a print out of the pexpect\n        execution is given.\n\n        Args:\n            commit_message (str): message for the commit\n            verbose (bool): set to True to display stdout of push.\n\n        Returns:\n            bool: currently returns False if commit fails\n        \"\"\"\n\n        repo = Repo(self.repo_path_local)\n\n        # TODO #19 - how will this work with lots of other users.\n        try:\n            repo.config_reader().get_value(\"user\", \"name\")\n            repo.config_reader().get_value(\"user\", \"email\")\n        except:\n            subprocess.Popen(\n                [\n                    \"/usr/bin/git\",\n                    \"config\",\n                    \"--global\",\n                    \"user.name\",\n                    self.github_username,\n                ],\n                shell=False,\n            ).wait()  # nosec B603\n\n            subprocess.Popen(\n                [\n                    \"/usr/bin/git\",\n                    \"config\",\n                    \"--global\",\n                    \"user.email\",\n                    self.email,\n                ],\n                shell=False,\n            ).wait()  # nosec B603\n\n        repo = Repo(self.repo_path_local)\n        repo.git.add(\"--all\")\n\n        try:\n            # This fails if branch is up to date\n            repo.git.commit(\"-m\", commit_message)\n        except Exception as e:\n            return False\n\n        # origin = repo.remote(name=\"origin\")\n\n        # TODO - need to error handle this part with 'try'\n        child = pexpect.spawn(\"git push\", timeout=10)\n        child.expect(\"Username for 'https://github.com': \")\n        child.sendline(self.github_username)\n        child.expect(\n            f\"Password for 'https://{ self.github_username }@github.com': \"\n        )\n        child.sendline(self.default_external_repository_token)\n\n        if verbose:\n            output = child.readline()\n            while b\"\\r\\n\" in output:\n                split = output.split(b\"\\r\")\n                for s in split:\n                    print(s.decode(\"ascii\"))\n                output = child.readline()\n        else:\n            child.wait()\n        return True\n\n    def entry_update(\n        self,\n        title: str,\n        body: str,\n        labels: list[str],\n    ) -&gt; None:\n        \"\"\"Uses GitHub issues to log a new hazard\n\n        Hazards are logged as issues on GitHub\n\n        Args:\n            title (str): Title for the issue.\n            body (str): Body for the issue.\n            labels (list[str]): a list of labels for the issue.\n\n        Returns:\n            None\n\n        Raises:\n            ValueError: if a hazard label is not valid\n            ValueError: if issue with accessing the repo\n        \"\"\"\n        g: Github\n        repo: Repository.Repository\n\n        for label in labels:\n            if not self.verify_hazard_label(label):\n                raise ValueError(\n                    f\"'{ label }' is not a valid hazard label. Please review label.yml for available values.\"\n                )\n\n        g = Github(\n            self.github_username,\n            self.default_external_repository_token,\n        )\n\n        try:\n            repo = g.get_repo(\n                f\"{ self.repo_domain_name() }/{ self.github_repo }\"\n            )\n            repo.create_issue(\n                title=title,\n                body=body,\n                labels=labels,\n            )\n        except GithubException as error:\n            raise ValueError(\n                f\"Error with accessing repo '{ self.repo_domain_name() }/{ self.github_repo }', return value '{ error.data['message'] }'\"\n            )\n\n        return\n\n    def available_hazard_labels(\n        self, details: str = \"full\"\n    ) -&gt; list[dict[str, str]] | list[str]:\n        \"\"\"Provides a list of available hazard labels\n\n        Reads from the labels yaml file and returns a list of valid hazard labels\n\n        Args:\n            details (str): full = all details of all hazard labels. name_only =\n                           names only of all hazard labels.\n\n        Returns:\n            list: either a list[dict[str,str]] if \"full\" details are requested or\n                  else a list[str] if names_only requested.\n\n        Raises:\n            ValueError: if details argument is not \"full\" or \"name_only\"\n            FileNotFoundError: if a bad file path is given for the labels yaml.\n        \"\"\"\n        issues_yml: list[dict[str, str]]\n        issues_names_only: list[str] = []\n\n        if details != \"full\" and details != \"name_only\":\n            raise ValueError(\n                f\"'{ details }' is not a valid option for return values of hazard labels\"\n            )\n\n        try:\n            with open(c.ISSUE_LABELS_PATH, \"r\") as file:\n                issues_yml = yaml.safe_load(file)\n        except FileNotFoundError:\n            raise FileNotFoundError(\n                f\"Labels.yml does not exist at '{ c.ISSUE_LABELS_PATH }'\"\n            )\n\n        if details == \"full\":\n            return issues_yml\n        else:\n            for label_definition in issues_yml:\n                issues_names_only.append(label_definition[\"name\"].lower())\n            return issues_names_only\n\n    def verify_hazard_label(self, label: str) -&gt; bool:\n        \"\"\"Checks if a label name is valid\n\n        Checking against all known valid hazard labels, checks if label name\n        supplied is valid.\n\n        Args:\n            label (str): label to be examined.\n\n        Returns:\n            bool: True if a valid label, False if not.\n        \"\"\"\n        issues_yml: list[dict[str, str]] | list[\n            str\n        ] = self.available_hazard_labels(\"name_only\")\n        label_name: str | dict[str, str] = \"\"\n\n        for label_name in issues_yml:\n            if (\n                isinstance(label_name, str)\n                and label.lower() in label_name.lower()\n            ):\n                return True\n            elif isinstance(label_name, dict):\n                pass\n\n        return False\n\n    def hazards_open(\n        self,\n    ) -&gt; list[dict[str, Any]]:\n        \"\"\"Returns a list of open hazards on GitHub\n\n        Grabs open hazards (which are actually GitHub Issues) from GitHub\n\n        Returns:\n            list[dict[str, Any]]: list of dictionaries of open hazards.\n\n        Raises:\n            ValueError: if error with accessing the repository\n        \"\"\"\n        g: Github\n        hazards_open: list[dict[str, Any]] = []\n        label_list: list[str] = []\n        issue: Any\n        open_issues: PaginatedList.PaginatedList[Issue]\n        repo: Repository.Repository\n\n        g = Github(\n            self.github_username,\n            self.default_external_repository_token,\n        )\n\n        try:\n            repo = g.get_repo(\n                f\"{ self.repo_domain_name() }/{ self.github_repo }\"\n            )\n            open_issues = repo.get_issues(state=\"open\")\n        except GithubException as error:\n            raise ValueError(\n                f\"Error with accessing repo '{ self.repo_domain_name() }/{ self.github_repo }', return value '{ error.data['message'] }'\"\n            )\n\n        for issue in open_issues:\n            label_list.clear()\n            for label in issue.labels:\n                label_list.append(label.name)\n            hazards_open.append(\n                {\n                    \"number\": issue.number,\n                    \"title\": issue.title,\n                    \"body\": issue.body,\n                    \"labels\": label_list.copy(),\n                }\n            )\n        return hazards_open\n\n    def repo_domain_name(self) -&gt; str:\n        \"\"\"Domain name set\n\n        If organisational name is not set then use username is used as the\n        \"domain\" name for the repository.\n\n        Returns:\n            str: name of domain (organisation or username)\n        \"\"\"\n        repo_domain: str = \"\"\n\n        if self.github_organisation == \"\":\n            repo_domain = self.github_username\n        else:\n            repo_domain = self.github_organisation\n\n        return repo_domain\n\n    def add_comment_to_hazard(\n        self,\n        hazard_number: int = 0,\n        comment: str = \"\",\n    ) -&gt; None:\n        \"\"\"Add a comment to a hazard\n\n        As a comment to an already open hazard (stored as an issue on GitHub).\n\n        Args:\n            hazard_number (int): hazard (issue) number to add comment to.\n            comment (str): comment to add to hazard.\n\n        Returns:\n            None\n\n        Raises:\n            ValueError: if no hazard number is provided.\n            ValueError: if no comment if provided.\n            ValueError: if issue with accessing the repository.\n        \"\"\"\n        g: Github\n        repo: Repository.Repository\n        issue: Issue\n\n        if hazard_number == 0:\n            raise ValueError(\"No Hazard Number has been provided\")\n\n        if comment == \"\":\n            raise ValueError(\"No comment has been provided\")\n\n        g = Github(\n            self.github_username,\n            self.default_external_repository_token,\n        )\n\n        try:\n            repo = g.get_repo(\n                f\"{ self.repo_domain_name() }/{ self.github_repo }\"\n            )\n        except GithubException as error:\n            raise ValueError(\n                f\"Error with accessing repo '{ self.repo_domain_name() }/{ self.github_repo }', return value '{ error.data['message'] }'\"\n            )\n        else:\n            issue = repo.get_issue(number=int(hazard_number))\n            issue.create_comment(comment)\n        return\n</code></pre>"},{"location":"code/functions/git_control/#functions.git_control.GitController_on_hold.__init__","title":"<code>__init__(github_username='', email='', github_organisation='', github_repo=c.REPO_NAME, default_external_repository_token='', repo_path_local=c.REPO_PATH_LOCAL, env_location=c.ENV_PATH_PLACEHOLDERS)</code>","text":"<p>Initialising GitController class</p> <p>Initialisation of the git and GitHub functionality.</p> <p>Parameters:</p> Name Type Description Default <code>github_username</code> <code>str</code> <p>the user's GitHub personal username.</p> <code>''</code> <code>email</code> <code>str</code> <p>the user's personal email address.</p> <code>''</code> <code>github_organisation</code> <code>str</code> <p>the organisation that the user wishes to                        associate repositories with. If this an                        empty string is supplied then username is                        used as storage location for repositories.</p> <code>''</code> <code>github_repo</code> <code>str</code> <p>Name of the GitHub repository.</p> <code>REPO_NAME</code> <code>default_external_repository_token</code> <code>str</code> <p>GitHub token.</p> <code>''</code> <code>repo_path_local</code> <code>str</code> <p>Local name of repository.</p> <code>REPO_PATH_LOCAL</code> <code>env_location</code> <code>str</code> <p>Location of .env file. Mainly changed for unit                 testing purposes.</p> <code>ENV_PATH_PLACEHOLDERS</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>if a empty string is supplied as the env_location.</p> <code>ValueError</code> <p>if env_location is an invalid file path.</p> <code>ValueError</code> <p>if no GitHub username is supplied as an argument or in         the .env file.</p> <code>ValueError</code> <p>if no email is supplied as an argument or in the .env         file.</p> <code>ValueError</code> <p>if invalid syntax of email (does not check to see if a         current and working email address).</p> <code>ValueError</code> <p>if github_repo is set to an empty string.</p> <code>ValueError</code> <p>if no default_external_repository_token is supplied as an argument or in         the .env file.</p> <code>ValueError</code> <p>if repo_path_local is set to an empty string.</p> <code>FileNotFoundError</code> <p>if repo_path_local points to a invalid or non-                existing directory.</p> Source code in <code>app/dcsp/app/functions/git_control.py</code> <pre><code>def __init__(\n    self,\n    github_username: str = \"\",\n    email: str = \"\",\n    github_organisation: str = \"\",\n    github_repo: str = c.REPO_NAME,\n    default_external_repository_token: str = \"\",\n    repo_path_local: str = c.REPO_PATH_LOCAL,\n    env_location: str = c.ENV_PATH_PLACEHOLDERS,\n) -&gt; None:\n    \"\"\"Initialising GitController class\n\n    Initialisation of the git and GitHub functionality.\n\n    Args:\n        github_username (str): the user's GitHub personal username.\n        email (str): the user's personal email address.\n        github_organisation (str): the organisation that the user wishes to\n                                   associate repositories with. If this an\n                                   empty string is supplied then username is\n                                   used as storage location for repositories.\n        github_repo (str): Name of the GitHub repository.\n        default_external_repository_token (str): GitHub token.\n        repo_path_local (str): Local name of repository.\n        env_location (str): Location of .env file. Mainly changed for unit\n                            testing purposes.\n\n    Raises:\n        ValueError: if a empty string is supplied as the env_location.\n        ValueError: if env_location is an invalid file path.\n        ValueError: if no GitHub username is supplied as an argument or in\n                    the .env file.\n        ValueError: if no email is supplied as an argument or in the .env\n                    file.\n        ValueError: if invalid syntax of email (does not check to see if a\n                    current and working email address).\n        ValueError: if github_repo is set to an empty string.\n        ValueError: if no default_external_repository_token is supplied as an argument or in\n                    the .env file.\n        ValueError: if repo_path_local is set to an empty string.\n        FileNotFoundError: if repo_path_local points to a invalid or non-\n                           existing directory.\n    \"\"\"  # nosec B107\n    self.github_username: str = \"\"\n    self.email: str = \"\"\n    self.github_organisation: str = \"\"\n    self.default_external_repository_token: str = \"\"\n\n    if env_location == \"\":\n        raise ValueError(f\".env location is set to empty string\")\n\n    if not os.path.isfile(env_location):\n        raise ValueError(\n            f\"'{ env_location }' path for .env file does not exist\"\n        )\n\n    dot_values = dotenv_values(env_location)\n\n    if github_username == \"\":\n        self.github_username = str(dot_values.get(\"GITHUB_USERNAME\") or \"\")\n        if self.github_username == \"\":\n            raise ValueError(\n                f\"'{ c.EnvKeysPH.GITHUB_USERNAME.value }' has not been set as an argument or in .env\"\n            )\n    else:\n        self.github_username = github_username\n\n    if email == \"\":\n        self.email = str(dot_values.get(\"EMAIL\") or \"\")\n        if self.email == \"\":\n            raise ValueError(\n                f\"'{ c.EnvKeysPH.EMAIL.value }' has not been set as an argument or in .env\"\n            )\n    else:\n        self.email = email\n\n    email_function = EmailFunctions()\n    if not email_function.valid_syntax(self.email):\n        raise ValueError(f\"Email address '{ self.email }' is invalid\")\n\n    if github_organisation == \"\":\n        self.github_organisation = str(\n            dot_values.get(\"GITHUB_ORGANISATION\" or \"\")\n        )\n    else:\n        self.github_organisation = github_organisation\n\n    if github_repo == \"\":\n        self.github_repo = str(dot_values.get(\"GITHUB_REPO\") or \"\")\n        if self.github_repo == \"\":\n            raise ValueError(\n                f\"'{ c.EnvKeysPH.GITHUB_REPO.value }' has not been set as an argument or in .env\"\n            )\n    else:\n        self.github_repo = github_repo\n\n    if default_external_repository_token == \"\":  # nosec B105, B107\n        self.default_external_repository_token = str(\n            dot_values.get(\"GITHUB_TOKEN\") or \"\"\n        )\n        if (\n            self.default_external_repository_token == None\n            or self.default_external_repository_token == \"\"  # nosec B105\n        ):  # nosec B105, B107\n            raise ValueError(\n                f\"'{ c.EnvKeysPH.GITHUB_TOKEN.value }' has not been set as an argument or in .env\"\n            )\n    else:\n        self.default_external_repository_token = (\n            default_external_repository_token\n        )\n\n    if repo_path_local == \"\":\n        raise ValueError(f\"'repo_path_local' has not been set\")\n    else:\n        self.repo_path_local = repo_path_local\n        if not os.path.isdir(repo_path_local):\n            raise FileNotFoundError(\n                f\"'{ repo_path_local }' is not a valid path for 'repo_path_local'\"\n            )\n    return None\n</code></pre>"},{"location":"code/functions/git_control/#functions.git_control.GitController_on_hold.add_comment_to_hazard","title":"<code>add_comment_to_hazard(hazard_number=0, comment='')</code>","text":"<p>Add a comment to a hazard</p> <p>As a comment to an already open hazard (stored as an issue on GitHub).</p> <p>Parameters:</p> Name Type Description Default <code>hazard_number</code> <code>int</code> <p>hazard (issue) number to add comment to.</p> <code>0</code> <code>comment</code> <code>str</code> <p>comment to add to hazard.</p> <code>''</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>if no hazard number is provided.</p> <code>ValueError</code> <p>if no comment if provided.</p> <code>ValueError</code> <p>if issue with accessing the repository.</p> Source code in <code>app/dcsp/app/functions/git_control.py</code> <pre><code>def add_comment_to_hazard(\n    self,\n    hazard_number: int = 0,\n    comment: str = \"\",\n) -&gt; None:\n    \"\"\"Add a comment to a hazard\n\n    As a comment to an already open hazard (stored as an issue on GitHub).\n\n    Args:\n        hazard_number (int): hazard (issue) number to add comment to.\n        comment (str): comment to add to hazard.\n\n    Returns:\n        None\n\n    Raises:\n        ValueError: if no hazard number is provided.\n        ValueError: if no comment if provided.\n        ValueError: if issue with accessing the repository.\n    \"\"\"\n    g: Github\n    repo: Repository.Repository\n    issue: Issue\n\n    if hazard_number == 0:\n        raise ValueError(\"No Hazard Number has been provided\")\n\n    if comment == \"\":\n        raise ValueError(\"No comment has been provided\")\n\n    g = Github(\n        self.github_username,\n        self.default_external_repository_token,\n    )\n\n    try:\n        repo = g.get_repo(\n            f\"{ self.repo_domain_name() }/{ self.github_repo }\"\n        )\n    except GithubException as error:\n        raise ValueError(\n            f\"Error with accessing repo '{ self.repo_domain_name() }/{ self.github_repo }', return value '{ error.data['message'] }'\"\n        )\n    else:\n        issue = repo.get_issue(number=int(hazard_number))\n        issue.create_comment(comment)\n    return\n</code></pre>"},{"location":"code/functions/git_control/#functions.git_control.GitController_on_hold.available_hazard_labels","title":"<code>available_hazard_labels(details='full')</code>","text":"<p>Provides a list of available hazard labels</p> <p>Reads from the labels yaml file and returns a list of valid hazard labels</p> <p>Parameters:</p> Name Type Description Default <code>details</code> <code>str</code> <p>full = all details of all hazard labels. name_only =            names only of all hazard labels.</p> <code>'full'</code> <p>Returns:</p> Name Type Description <code>list</code> <code>list[dict[str, str]] | list[str]</code> <p>either a list[dict[str,str]] if \"full\" details are requested or   else a list[str] if names_only requested.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>if details argument is not \"full\" or \"name_only\"</p> <code>FileNotFoundError</code> <p>if a bad file path is given for the labels yaml.</p> Source code in <code>app/dcsp/app/functions/git_control.py</code> <pre><code>def available_hazard_labels(\n    self, details: str = \"full\"\n) -&gt; list[dict[str, str]] | list[str]:\n    \"\"\"Provides a list of available hazard labels\n\n    Reads from the labels yaml file and returns a list of valid hazard labels\n\n    Args:\n        details (str): full = all details of all hazard labels. name_only =\n                       names only of all hazard labels.\n\n    Returns:\n        list: either a list[dict[str,str]] if \"full\" details are requested or\n              else a list[str] if names_only requested.\n\n    Raises:\n        ValueError: if details argument is not \"full\" or \"name_only\"\n        FileNotFoundError: if a bad file path is given for the labels yaml.\n    \"\"\"\n    issues_yml: list[dict[str, str]]\n    issues_names_only: list[str] = []\n\n    if details != \"full\" and details != \"name_only\":\n        raise ValueError(\n            f\"'{ details }' is not a valid option for return values of hazard labels\"\n        )\n\n    try:\n        with open(c.ISSUE_LABELS_PATH, \"r\") as file:\n            issues_yml = yaml.safe_load(file)\n    except FileNotFoundError:\n        raise FileNotFoundError(\n            f\"Labels.yml does not exist at '{ c.ISSUE_LABELS_PATH }'\"\n        )\n\n    if details == \"full\":\n        return issues_yml\n    else:\n        for label_definition in issues_yml:\n            issues_names_only.append(label_definition[\"name\"].lower())\n        return issues_names_only\n</code></pre>"},{"location":"code/functions/git_control/#functions.git_control.GitController_on_hold.check_github_credentials","title":"<code>check_github_credentials()</code>","text":"<p>Checking Github credentials</p> <p>If no organisation is provided, then username will be used for repo storage location</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict[str, str | bool | None]</code> <p>a dictionary with 4 values covering the validity of the credentials supplied   in the initialisation of the GitController class</p> Source code in <code>app/dcsp/app/functions/git_control.py</code> <pre><code>def check_github_credentials(\n    self,\n) -&gt; dict[str, str | bool | None]:\n    \"\"\"Checking Github credentials\n\n    If no organisation is provided, then username will be used for repo storage location\n\n    Returns:\n        dict: a dictionary with 4 values covering the validity of the credentials supplied\n              in the initialisation of the GitController class\n    \"\"\"\n    g: Github\n    github_username_exists: bool = False\n    github_organisation_exists: bool = False\n    repo_exists: bool = False\n    permission: str | None = None\n    results: dict[str, str | bool | None] = {}\n    username_request: Response\n    repo_request: Response\n    repo: Repository.Repository\n\n    # TODO ? manage rate limiters\n\n    try:\n        username_request = requests.get(\n            f\"https://api.github.com/users/{ self.github_username }\",\n            auth=(\n                self.github_username,\n                self.default_external_repository_token,\n            ),\n            timeout=10,\n        )\n    except requests.exceptions.ConnectionError:\n        raise requests.exceptions.ConnectionError(\n            \"No connection available to GitHub API\"\n        )\n    except requests.exceptions.Timeout:\n        raise requests.exceptions.Timeout(\n            \"Timeout while connecting to GitHub API\"\n        )\n\n    if username_request.status_code == 200:\n        github_username_exists = True\n    elif username_request.status_code == 404:\n        github_username_exists = False\n    else:\n        raise ValueError(\n            f\"Error with Github username checking. Returned value of: {username_request.status_code }\"\n        )\n\n    github_organisation_exists = self.organisation_exists(\n        self.github_organisation\n    )\n\n    try:\n        repo_request = requests.get(\n            f\"https://api.github.com/repos/{ self.repo_domain_name() }/{ self.github_repo }\",\n            auth=(\n                self.github_organisation,\n                self.default_external_repository_token,\n            ),\n            timeout=10,\n        )\n    except requests.exceptions.ConnectionError:\n        raise requests.exceptions.ConnectionError(\n            \"No connection available to GitHub API\"\n        )\n    except requests.exceptions.Timeout:\n        raise requests.exceptions.Timeout(\n            \"Timeout while connecting to GitHub API\"\n        )\n\n    if repo_request.status_code == 200:\n        repo_exists = True\n\n        # patch\n        g = Github(\n            self.github_username,\n            self.default_external_repository_token,\n        )\n        repo = g.get_repo(\n            f\"{ self.repo_domain_name() }/{ self.github_repo }\"\n        )\n\n        try:\n            permission = repo.get_collaborator_permission(\n                self.github_username\n            )\n        except GithubException:\n            pass\n    elif repo_request.status_code == 404:\n        repo_exists = False\n    else:\n        raise ValueError(\n            f\"Error with Github repo checking. Returned value of: {repo_request.status_code }\"\n        )\n\n    results = {\n        \"github_username_exists\": github_username_exists,\n        \"github_organisation_exists\": github_organisation_exists,\n        \"repo_exists\": repo_exists,\n        \"permission\": permission,\n    }\n    return results\n</code></pre>"},{"location":"code/functions/git_control/#functions.git_control.GitController_on_hold.commit_and_push","title":"<code>commit_and_push(commit_message='Automated commit', verbose=False)</code>","text":"<p>Commits changes and then pushes to repo</p> <p>Initially checks if the git configs are set, and if not sets The username and email. Then commits the changes with the supplied message. If verbose is set to true, then a print out of the pexpect execution is given.</p> <p>Parameters:</p> Name Type Description Default <code>commit_message</code> <code>str</code> <p>message for the commit</p> <code>'Automated commit'</code> <code>verbose</code> <code>bool</code> <p>set to True to display stdout of push.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>currently returns False if commit fails</p> Source code in <code>app/dcsp/app/functions/git_control.py</code> <pre><code>def commit_and_push(\n    self,\n    commit_message: str = \"Automated commit\",\n    verbose: bool = False,\n) -&gt; bool:\n    \"\"\"Commits changes and then pushes to repo\n\n    Initially checks if the git configs are set, and if not sets\n    The username and email. Then commits the changes with the supplied\n    message. If verbose is set to true, then a print out of the pexpect\n    execution is given.\n\n    Args:\n        commit_message (str): message for the commit\n        verbose (bool): set to True to display stdout of push.\n\n    Returns:\n        bool: currently returns False if commit fails\n    \"\"\"\n\n    repo = Repo(self.repo_path_local)\n\n    # TODO #19 - how will this work with lots of other users.\n    try:\n        repo.config_reader().get_value(\"user\", \"name\")\n        repo.config_reader().get_value(\"user\", \"email\")\n    except:\n        subprocess.Popen(\n            [\n                \"/usr/bin/git\",\n                \"config\",\n                \"--global\",\n                \"user.name\",\n                self.github_username,\n            ],\n            shell=False,\n        ).wait()  # nosec B603\n\n        subprocess.Popen(\n            [\n                \"/usr/bin/git\",\n                \"config\",\n                \"--global\",\n                \"user.email\",\n                self.email,\n            ],\n            shell=False,\n        ).wait()  # nosec B603\n\n    repo = Repo(self.repo_path_local)\n    repo.git.add(\"--all\")\n\n    try:\n        # This fails if branch is up to date\n        repo.git.commit(\"-m\", commit_message)\n    except Exception as e:\n        return False\n\n    # origin = repo.remote(name=\"origin\")\n\n    # TODO - need to error handle this part with 'try'\n    child = pexpect.spawn(\"git push\", timeout=10)\n    child.expect(\"Username for 'https://github.com': \")\n    child.sendline(self.github_username)\n    child.expect(\n        f\"Password for 'https://{ self.github_username }@github.com': \"\n    )\n    child.sendline(self.default_external_repository_token)\n\n    if verbose:\n        output = child.readline()\n        while b\"\\r\\n\" in output:\n            split = output.split(b\"\\r\")\n            for s in split:\n                print(s.decode(\"ascii\"))\n            output = child.readline()\n    else:\n        child.wait()\n    return True\n</code></pre>"},{"location":"code/functions/git_control/#functions.git_control.GitController_on_hold.create_repo","title":"<code>create_repo(github_use_org, github_repo)</code>","text":"<p>Create a new repository on GitHub</p> <p>If does not already exist, this function will create a new repository on GitHub.</p> <p>Parameters:</p> Name Type Description Default <code>github_use_org</code> <code>str</code> <p>username or organisation to create the new                   repository under.</p> required <code>github_repo</code> <code>str</code> <p>name of new repository.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>False if already exists. True if created.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>if invalid credentials supplied to         'current_repo_on_github'.</p> Source code in <code>app/dcsp/app/functions/git_control.py</code> <pre><code>def create_repo(\n    self,\n    github_use_org: str,\n    github_repo: str,\n) -&gt; bool:\n    \"\"\"Create a new repository on GitHub\n\n    If does not already exist, this function will create a new repository\n    on GitHub.\n\n    Args:\n        github_use_org (str): username or organisation to create the new\n                              repository under.\n        github_repo (str): name of new repository.\n\n    Returns:\n        bool: False if already exists. True if created.\n\n    Raises:\n        ValueError: if invalid credentials supplied to\n                    'current_repo_on_github'.\n    \"\"\"\n    g: Github\n    github_get: Organization.Organization\n\n    try:\n        if self.current_repo_on_github(github_use_org, github_repo):\n            return False\n    except ValueError as error:\n        raise ValueError(f\"{ error }\")\n\n    g = Github(\n        self.github_username,\n        self.default_external_repository_token,\n    )\n    github_get = g.get_organization(github_use_org)\n    github_get.create_repo(github_repo)\n    return True\n</code></pre>"},{"location":"code/functions/git_control/#functions.git_control.GitController_on_hold.current_repo_on_github","title":"<code>current_repo_on_github(github_user_org, github_repo)</code>","text":"<p>Checks if supplied repository is on GitHub</p> <p>Checks if the supplied repository name is on GitHub, in the format \"github_user_org/github_repo\".</p> <p>Parameters:</p> Name Type Description Default <code>github_user_org</code> <code>str</code> <p>the username or organisation that the                    repository is stored under.</p> required <code>github_repo</code> <code>str</code> <p>the name of the GitHub repository.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if is a current repository under the user/organisation   or False if not.</p> Source code in <code>app/dcsp/app/functions/git_control.py</code> <pre><code>def current_repo_on_github(\n    self,\n    github_user_org: str,\n    github_repo: str,\n) -&gt; bool:\n    \"\"\"Checks if supplied repository is on GitHub\n\n    Checks if the supplied repository name is on GitHub, in the format\n    \"github_user_org/github_repo\".\n\n    Args:\n        github_user_org (str): the username or organisation that the\n                               repository is stored under.\n        github_repo (str): the name of the GitHub repository.\n\n    Returns:\n        bool: True if is a current repository under the user/organisation\n              or False if not.\n    \"\"\"\n    current_repos_on_github: list[str] = self.get_repos(github_user_org)\n    # print(\"\")\n    # print(str(current_repos_on_github))\n    if github_repo in current_repos_on_github:\n        return True\n    else:\n        return False\n</code></pre>"},{"location":"code/functions/git_control/#functions.git_control.GitController_on_hold.delete_repo","title":"<code>delete_repo(github_use_org, github_repo)</code>","text":"<p>Delete a repository on GitHub</p> <p>If in existence, then deletes repository on GitHub.</p> <p>Parameters:</p> Name Type Description Default <code>github_use_org</code> <code>str</code> <p>username or organisation where repository                   is stored.</p> required <code>github_repo</code> <code>str</code> <p>name of repository to delete.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>False if does not exist. True if exists and deleted.</p> Source code in <code>app/dcsp/app/functions/git_control.py</code> <pre><code>def delete_repo(\n    self,\n    github_use_org: str,\n    github_repo: str,\n) -&gt; bool:\n    \"\"\"Delete a repository on GitHub\n\n    If in existence, then deletes repository on GitHub.\n\n    Args:\n        github_use_org (str): username or organisation where repository\n                              is stored.\n        github_repo (str): name of repository to delete.\n\n    Returns:\n        bool: False if does not exist. True if exists and deleted.\n    \"\"\"\n    g: Github\n    github_get: Organization.Organization\n    repo: Repository.Repository\n\n    if not self.current_repo_on_github(github_use_org, github_repo):\n        return False\n\n    g = Github(\n        self.github_username,\n        self.default_external_repository_token,\n    )\n    github_get = g.get_organization(github_use_org)\n    repo = github_get.get_repo(github_repo)\n    repo.delete()\n    return True\n</code></pre>"},{"location":"code/functions/git_control/#functions.git_control.GitController_on_hold.entry_update","title":"<code>entry_update(title, body, labels)</code>","text":"<p>Uses GitHub issues to log a new hazard</p> <p>Hazards are logged as issues on GitHub</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>Title for the issue.</p> required <code>body</code> <code>str</code> <p>Body for the issue.</p> required <code>labels</code> <code>list[str]</code> <p>a list of labels for the issue.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>if a hazard label is not valid</p> <code>ValueError</code> <p>if issue with accessing the repo</p> Source code in <code>app/dcsp/app/functions/git_control.py</code> <pre><code>def entry_update(\n    self,\n    title: str,\n    body: str,\n    labels: list[str],\n) -&gt; None:\n    \"\"\"Uses GitHub issues to log a new hazard\n\n    Hazards are logged as issues on GitHub\n\n    Args:\n        title (str): Title for the issue.\n        body (str): Body for the issue.\n        labels (list[str]): a list of labels for the issue.\n\n    Returns:\n        None\n\n    Raises:\n        ValueError: if a hazard label is not valid\n        ValueError: if issue with accessing the repo\n    \"\"\"\n    g: Github\n    repo: Repository.Repository\n\n    for label in labels:\n        if not self.verify_hazard_label(label):\n            raise ValueError(\n                f\"'{ label }' is not a valid hazard label. Please review label.yml for available values.\"\n            )\n\n    g = Github(\n        self.github_username,\n        self.default_external_repository_token,\n    )\n\n    try:\n        repo = g.get_repo(\n            f\"{ self.repo_domain_name() }/{ self.github_repo }\"\n        )\n        repo.create_issue(\n            title=title,\n            body=body,\n            labels=labels,\n        )\n    except GithubException as error:\n        raise ValueError(\n            f\"Error with accessing repo '{ self.repo_domain_name() }/{ self.github_repo }', return value '{ error.data['message'] }'\"\n        )\n\n    return\n</code></pre>"},{"location":"code/functions/git_control/#functions.git_control.GitController_on_hold.get_repos","title":"<code>get_repos(github_user_org)</code>","text":"<p>Returns a list of repositories for a user or organisation</p> <p>Gets a list of repositories under a specified user or organisation</p> <p>Parameters:</p> Name Type Description Default <code>github_user_org</code> <code>str</code> <p>the username or organisation to look for the                    repositories under.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: a list of repositories. Returns empty list if unsuccessful in        getting.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>if unable to get user or organisation.</p> Source code in <code>app/dcsp/app/functions/git_control.py</code> <pre><code>def get_repos(self, github_user_org: str) -&gt; list[str]:\n    \"\"\"Returns a list of repositories for a user or organisation\n\n    Gets a list of repositories under a specified user or organisation\n\n    Args:\n        github_user_org (str): the username or organisation to look for the\n                               repositories under.\n\n    Returns:\n        list[str]: a list of repositories. Returns empty list if unsuccessful in\n                   getting.\n\n    Raises:\n        ValueError: if unable to get user or organisation.\n    \"\"\"\n    g: Github\n    github_user: NamedUser.NamedUser | AuthenticatedUser.AuthenticatedUser\n    repos_found: list[str] = []\n    repo: Repository.Repository\n\n    g = Github(\n        self.github_username,\n        self.default_external_repository_token,\n    )\n\n    try:\n        github_user = g.get_user(github_user_org)\n    except GithubException as error:\n        raise ValueError(\n            f\"Error with getting user / organisastion '{ github_user_org }', returned - '{ error.data['message'] }'\"\n        )\n    else:\n        for repo in github_user.get_repos():\n            repos_found.append(repo.name)\n\n    return repos_found\n</code></pre>"},{"location":"code/functions/git_control/#functions.git_control.GitController_on_hold.hazards_open","title":"<code>hazards_open()</code>","text":"<p>Returns a list of open hazards on GitHub</p> <p>Grabs open hazards (which are actually GitHub Issues) from GitHub</p> <p>Returns:</p> Type Description <code>list[dict[str, Any]]</code> <p>list[dict[str, Any]]: list of dictionaries of open hazards.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>if error with accessing the repository</p> Source code in <code>app/dcsp/app/functions/git_control.py</code> <pre><code>def hazards_open(\n    self,\n) -&gt; list[dict[str, Any]]:\n    \"\"\"Returns a list of open hazards on GitHub\n\n    Grabs open hazards (which are actually GitHub Issues) from GitHub\n\n    Returns:\n        list[dict[str, Any]]: list of dictionaries of open hazards.\n\n    Raises:\n        ValueError: if error with accessing the repository\n    \"\"\"\n    g: Github\n    hazards_open: list[dict[str, Any]] = []\n    label_list: list[str] = []\n    issue: Any\n    open_issues: PaginatedList.PaginatedList[Issue]\n    repo: Repository.Repository\n\n    g = Github(\n        self.github_username,\n        self.default_external_repository_token,\n    )\n\n    try:\n        repo = g.get_repo(\n            f\"{ self.repo_domain_name() }/{ self.github_repo }\"\n        )\n        open_issues = repo.get_issues(state=\"open\")\n    except GithubException as error:\n        raise ValueError(\n            f\"Error with accessing repo '{ self.repo_domain_name() }/{ self.github_repo }', return value '{ error.data['message'] }'\"\n        )\n\n    for issue in open_issues:\n        label_list.clear()\n        for label in issue.labels:\n            label_list.append(label.name)\n        hazards_open.append(\n            {\n                \"number\": issue.number,\n                \"title\": issue.title,\n                \"body\": issue.body,\n                \"labels\": label_list.copy(),\n            }\n        )\n    return hazards_open\n</code></pre>"},{"location":"code/functions/git_control/#functions.git_control.GitController_on_hold.organisation_exists","title":"<code>organisation_exists(organisation)</code>","text":"<p>Checks if the GitHub organisation exists</p> <p>Checks to see if the provided organisation name exists. This utilises authentification, so good credentitals are needed.</p> <p>Parameters:</p> Name Type Description Default <code>organisation</code> <code>str</code> <p>name of GitHub organisation to test.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if exists, False if does not.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>if bad return code from GET request</p> Source code in <code>app/dcsp/app/functions/git_control.py</code> <pre><code>def organisation_exists(self, organisation: str) -&gt; bool:\n    \"\"\"Checks if the GitHub organisation exists\n\n    Checks to see if the provided organisation name exists. This utilises\n    authentification, so good credentitals are needed.\n\n    Args:\n        organisation (str): name of GitHub organisation to test.\n\n    Returns:\n        bool: True if exists, False if does not.\n\n    Raises:\n        ValueError: if bad return code from GET request\n    \"\"\"\n    organisation_request: Response\n    github_organisation_exists: bool = False\n\n    # TODO will need to manage other errors like time outs and rate limiters\n    try:\n        organisation_request = requests.get(\n            f\"https://api.github.com/users/{ organisation }\",\n            auth=(\n                self.github_organisation,\n                self.default_external_repository_token,\n            ),\n            timeout=10,\n        )\n    except requests.exceptions.ConnectionError:\n        raise requests.exceptions.ConnectionError(\n            \"No connection available to GitHub API\"\n        )\n    except requests.exceptions.Timeout:\n        raise requests.exceptions.Timeout(\n            \"Timeout while connecting to GitHub API\"\n        )\n\n    if organisation_request.status_code == 200:\n        github_organisation_exists = True\n    elif organisation_request.status_code == 404:\n        github_organisation_exists = False\n    else:\n        raise ValueError(\n            f\"Error with Github organisation checking. Returned value of: {organisation_request.status_code }\"\n        )\n\n    return github_organisation_exists\n</code></pre>"},{"location":"code/functions/git_control/#functions.git_control.GitController_on_hold.repo_domain_name","title":"<code>repo_domain_name()</code>","text":"<p>Domain name set</p> <p>If organisational name is not set then use username is used as the \"domain\" name for the repository.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>name of domain (organisation or username)</p> Source code in <code>app/dcsp/app/functions/git_control.py</code> <pre><code>def repo_domain_name(self) -&gt; str:\n    \"\"\"Domain name set\n\n    If organisational name is not set then use username is used as the\n    \"domain\" name for the repository.\n\n    Returns:\n        str: name of domain (organisation or username)\n    \"\"\"\n    repo_domain: str = \"\"\n\n    if self.github_organisation == \"\":\n        repo_domain = self.github_username\n    else:\n        repo_domain = self.github_organisation\n\n    return repo_domain\n</code></pre>"},{"location":"code/functions/git_control/#functions.git_control.GitController_on_hold.verify_hazard_label","title":"<code>verify_hazard_label(label)</code>","text":"<p>Checks if a label name is valid</p> <p>Checking against all known valid hazard labels, checks if label name supplied is valid.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>label to be examined.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if a valid label, False if not.</p> Source code in <code>app/dcsp/app/functions/git_control.py</code> <pre><code>def verify_hazard_label(self, label: str) -&gt; bool:\n    \"\"\"Checks if a label name is valid\n\n    Checking against all known valid hazard labels, checks if label name\n    supplied is valid.\n\n    Args:\n        label (str): label to be examined.\n\n    Returns:\n        bool: True if a valid label, False if not.\n    \"\"\"\n    issues_yml: list[dict[str, str]] | list[\n        str\n    ] = self.available_hazard_labels(\"name_only\")\n    label_name: str | dict[str, str] = \"\"\n\n    for label_name in issues_yml:\n        if (\n            isinstance(label_name, str)\n            and label.lower() in label_name.lower()\n        ):\n            return True\n        elif isinstance(label_name, dict):\n            pass\n\n    return False\n</code></pre>"},{"location":"code/functions/git_control/#functions.git_control.GitHubController","title":"<code>GitHubController</code>","text":"Source code in <code>app/dcsp/app/functions/git_control.py</code> <pre><code>class GitHubController:\n    def __init__(self, username: str, password_token: str):\n        \"\"\" \"\"\"\n        if username == \"\":\n            raise ValueError(\"'username' cannot be empty\")\n        if password_token == \"\":  # nosec B105\n            raise ValueError(\"'password_token' cannot be empty\")\n\n        self.username: str = username\n        self.password_token: str = password_token\n\n    def repository_exists(self, repo_url: str) -&gt; bool:\n        \"\"\" \"\"\"\n        g = Github(self.username, self.password_token)\n\n        # Find the index of the second-to-last forward slash\n        index_of_second_last_slash = repo_url.rfind(\n            \"/\", 0, repo_url.rfind(\"/\")\n        )\n\n        # Retrieve the substring after the second-to-last forward slash\n        repo_path = repo_url[index_of_second_last_slash + 1 :]\n\n        try:\n            repo = g.get_repo(repo_path)\n        except GithubException:\n            return False\n        return True\n</code></pre>"},{"location":"code/functions/git_control/#functions.git_control.GitHubController.__init__","title":"<code>__init__(username, password_token)</code>","text":"Source code in <code>app/dcsp/app/functions/git_control.py</code> <pre><code>def __init__(self, username: str, password_token: str):\n    \"\"\" \"\"\"\n    if username == \"\":\n        raise ValueError(\"'username' cannot be empty\")\n    if password_token == \"\":  # nosec B105\n        raise ValueError(\"'password_token' cannot be empty\")\n\n    self.username: str = username\n    self.password_token: str = password_token\n</code></pre>"},{"location":"code/functions/git_control/#functions.git_control.GitHubController.repository_exists","title":"<code>repository_exists(repo_url)</code>","text":"Source code in <code>app/dcsp/app/functions/git_control.py</code> <pre><code>def repository_exists(self, repo_url: str) -&gt; bool:\n    \"\"\" \"\"\"\n    g = Github(self.username, self.password_token)\n\n    # Find the index of the second-to-last forward slash\n    index_of_second_last_slash = repo_url.rfind(\n        \"/\", 0, repo_url.rfind(\"/\")\n    )\n\n    # Retrieve the substring after the second-to-last forward slash\n    repo_path = repo_url[index_of_second_last_slash + 1 :]\n\n    try:\n        repo = g.get_repo(repo_path)\n    except GithubException:\n        return False\n    return True\n</code></pre>"},{"location":"code/functions/mkdocs_control/","title":"Mkdocs control","text":"<p>Starting and stopping (and test if running) of mkdocs</p> <p>Starts, stops and assesses state of mkdocs serve</p> <p>Classes:</p> Name Description <code>MkdocsControl</code> <p>manage mkdocs server</p>"},{"location":"code/functions/mkdocs_control/#functions.mkdocs_control.MkdocsControl","title":"<code>MkdocsControl</code>","text":"Source code in <code>app/dcsp/app/functions/mkdocs_control.py</code> <pre><code>class MkdocsControl:\n    def __init__(\n        self,\n        project_id: int | str,\n        projects_folder: str = c.PROJECTS_FOLDER,\n    ) -&gt; None:\n        \"\"\"Initialises the MkDocsControl class\n\n        Args:\n            cwd_sh (str): the current working directory for the shell script\n        \"\"\"\n        self.project_id: int = 0\n        self.process_name: str = \"mkdocs\"\n        self.process_arg1: str = \"serve\"\n        self.documentation_pages: str = \"\"\n        self.project_folder: str = \"\"\n\n        if not isinstance(project_id, int):\n            if not project_id.isdigit():\n                raise ValueError(\n                    f\"'project_id of '{ project_id }' is not an integer\"\n                )\n\n        self.project_id = int(project_id)\n\n        # TODO should check in model if project ID exists\n        if self.project_id &lt;= 0:\n            raise ValueError(\n                f\"'project_id of '{ project_id }' must be 1 or more\"\n            )\n\n        self.documentation_pages = (\n            f\"{ c.DOCUMENTATION_PAGES }/project_{ self.project_id }\"\n        )\n\n        if not Path(self.documentation_pages).is_dir():\n            Path(self.documentation_pages).mkdir(parents=True, exist_ok=True)\n\n        self.project_folder = f\"{ projects_folder }project_{ project_id }/\"\n\n        self.documents_directory = (\n            f\"{ self.project_folder }{ c.CLINICAL_SAFETY_FOLDER }\"\n        )\n\n        # TODO #56 - was this meant to check projects_folder or project_folder (not the s)\n        if not Path(projects_folder).is_dir():\n            raise FileExistsError(f\"'{ projects_folder }' does not exist\")\n\n        return\n\n    def preprocessor(self, entry_type: str = \"hazard\") -&gt; str:\n        \"\"\"Adds all entry to the entries-summary page\n\n        Returns:\n            str: a string of outcomes from function, formatted for html\n        \"\"\"\n        entries_dir: str = f\"{ self.documents_directory }docs/{ entry_type }s/\"\n        entries_entries_dir: str = f\"{ entries_dir }{ entry_type }s/\"\n        entry_template_dir: str = f\"{ self.documents_directory }templates/\"\n        files_to_check: list[str] = []\n        docstring: DocstringManipulation\n        # file\n        # entry_file\n        contents_str: str = \"\"\n        # file_name\n        # entry_name\n        # entry_number\n        # entry_name_match\n        warnings: str = \"\"\n        entries: list[dict[str, Any]] = []\n        project: ProjectBuilder\n        contents_list: list[dict[str, Any]] = []\n        entry_form: dict[str, Any]\n        icon_html: str = \"\"\n        code_html: str = \"\"\n        referenced_hazards: list[dict[str, Any]] = []\n        function_hazards: list[str] = []\n\n        if not Path(entries_dir).is_dir():\n            return (\n                \"&lt;b&gt;Failed preprocessor&lt;/b&gt;\"\n                \"&lt;br&gt;&lt;hr&gt;\"\n                f\"'{ entries_dir }' directory does not exist\"\n                \"&lt;br&gt;&lt;hr&gt;\"\n            )\n\n        if not Path(entries_entries_dir).is_dir():\n            Path(entries_entries_dir).mkdir(parents=True, exist_ok=True)\n            return (\n                \"&lt;b&gt;Preprocessor passed with INFO&lt;/b&gt;\"\n                \"&lt;br&gt;&lt;hr&gt;\"\n                f\"INFO - '{ entries_entries_dir }' directory did not exist, now created\"\n                \"&lt;br&gt;&lt;hr&gt;\"\n            )\n\n        for path, _, files in os.walk(entries_entries_dir):\n            for name in files:\n                if fnmatch(name, \"*.md\"):\n                    files_to_check.append(os.path.join(path, name))\n\n        # Sort the list of file paths based on the file numbers\n        files_to_check = sorted(files_to_check, reverse=True)\n\n        if not len(files_to_check):\n            return (\n                \"&lt;b&gt;Preprocessor passed with INFO&lt;/b&gt;\"\n                \"&lt;br&gt;&lt;hr&gt;\"\n                f\"INFO - No entries found in '{ entries_entries_dir }' folder.\"\n                \"Entries summary page could not be created\"\n                \"&lt;br&gt;&lt;hr&gt;\"\n            )\n\n        # TODO - should check there are no files with same entry number (eg hazard-1 and hazard-01 and hazard-001)\n\n        docstring = DocstringManipulation(self.project_id)\n        referenced_hazards = docstring.docstring_all()\n\n        for file in files_to_check:\n            icon_html = \"\"\n            function_hazards = []\n\n            entry_file = open(file, \"r\")\n            contents_str = entry_file.read()\n            file_name = Path(file).stem\n\n            try:\n                entry_number = file_name.split(\"-\")[1]\n                if not entry_number.isdigit():\n                    entry_number = \"[Non-digit entry number]\"\n                    warnings += f\"WARNING - A non-digit 'number' in entry file name '{ file_name }'\"\n            except:\n                entry_number = \"[Number not defined]\"\n\n            for function_info in referenced_hazards:\n                for hazard in function_info[\"hazards\"]:\n                    if hazard[\"hazard_number\"] == entry_number:\n                        function_hazards.append(function_info[\"mk_file_path\"])\n\n                        # print(entry_number)\n                        # print(function_hazards)\n\n            project = ProjectBuilder(self.project_id)\n            # TODO - need to figure out which entry_types are preprocessed\n            contents_list = project.entry_read_with_field_types(\"hazard\", file)\n\n            for field in contents_list:\n                if field[\"field_type\"] == \"icon\":\n                    env = Environment(\n                        loader=FileSystemLoader(entry_template_dir),\n                        autoescape=True,\n                    )\n                    template = env.get_template(f\"{ entry_type }-icons.md\")\n\n                    context = {\"contents_list\": contents_list}\n                    icon_html = template.render(context)\n                    icon_html = f\"{ icon_html }\\n&lt;!-- [iconend] --&gt;\"\n\n                elif field[\"field_type\"] == \"code\":\n                    code_html = \"\"\n\n                    for function in referenced_hazards:\n                        for hazard in function[\"hazards\"]:\n                            if hazard[\"hazard_number\"] == entry_number:\n                                code_html += (\n                                    f\"[{ function['code_file'].replace('.py', '') }\"\n                                    f\".{ hazard['sub_routine']}](../../{ function['mk_file_path'] }\"\n                                    f\"#{ hazard['sub_routine']}_hazard)\\n\\n\"\n                                )\n\n                    code_html = code_html.rstrip(\"\\n\\n\")\n\n                    if not code_html:\n                        code_html = \"Hazard not mentioned in source code\"\n\n            entry_form = project.entry_file_read_to_form(\n                contents_list,\n                icon_html,\n                code_html,\n            )\n\n            project.entry_update(\n                entry_form,\n                entry_type,\n                entry_number,\n            )\n            pattern = re.compile(\n                r\"&lt;!--\\s*\\[icon\\]\\s*--&gt;.*?&lt;!--\\s*\\[iconend\\]\\s*--&gt;\",\n                re.DOTALL,\n            )\n            contents_str = re.sub(pattern, \"\", contents_str)\n            contents_str = contents_str.replace(\"../../\", \"../\")\n            icon_html = icon_html.replace(\"../../\", \"../\")\n            icon_html = icon_html.replace(\n                'class=\"icon-large\"',\n                'class=\"icon-small\"',\n            )\n\n            entries.append(\n                {\n                    \"number\": entry_number,\n                    \"contents_str\": contents_str,\n                    \"contents_list\": contents_list,\n                    \"icon_html\": icon_html,\n                }\n            )\n\n        # Creating the summary\n        env = Environment(\n            loader=FileSystemLoader(entry_template_dir), autoescape=True\n        )\n        template = env.get_template(\n            f\"{ entry_type }{ c.ENTRY_SUMMARY_SUFFIX }\"\n        )\n        context = {\"entries\": entries}\n        md_content = template.render(context)\n        summary_file = open(\n            f\"{ entries_dir }{ entry_type }{ c.ENTRY_SUMMARY_SUFFIX }\",\n            \"w\",\n        )\n        summary_file.write(md_content)\n        summary_file.close()\n\n        if warnings:\n            return (\n                \"&lt;b&gt;Successful preprocessor step with WARNINGS&lt;/b&gt;\"\n                \"&lt;br&gt;&lt;hr&gt;\"\n                f\"{ warnings }\"\n                \"&lt;br&gt;&lt;hr&gt;\"\n            )\n        else:\n            return \"&lt;b&gt;Successful preprocessor step&lt;/b&gt;\" \"&lt;br&gt;&lt;hr&gt;\"\n\n    def build(self) -&gt; str:\n        \"\"\" \"\"\"\n        command: list[str] = []\n        command_output_dir: str = (\n            f\"{ c.DOCUMENTATION_PAGES }/project_{ self.project_id }\"\n        )\n        command_output: CompletedProcess[str]\n        command_output_html: str = \"\"\n        stdout_result: str = \"\"\n        stderr_result: str = \"\"\n\n        if not Path(command_output_dir).is_dir():\n            raise FileExistsError(\n                f\"'{ command_output_dir }' directory does not exist\"\n            )\n\n        command = [\n            \"/usr/local/bin/mkdocs\",\n            \"build\",\n            \"-d\",\n            command_output_dir,\n        ]\n\n        command_output = subprocess.run(\n            command,\n            shell=False,\n            check=False,\n            cwd=self.documents_directory,\n            capture_output=True,\n            text=True,\n        )  # nosec B603\n\n        if command_output.returncode == 0:\n            command_output_html += \"&lt;b&gt;Successful mkdocs build&lt;/b&gt;\"\n        else:\n            command_output_html += \"&lt;b&gt;Mkdocs build errors!&lt;/b&gt;\"\n\n        command_output_html += \"&lt;br&gt;&lt;hr&gt;\"\n\n        stdout_result = command_output.stdout.replace(\"\\n\", \"&lt;br&gt;\")\n        command_output_html += f\"&lt;b&gt;Stdout:&lt;/b&gt; { stdout_result }\"\n\n        command_output_html += \"&lt;br&gt;&lt;hr&gt;\"\n\n        stderr_result = command_output.stderr.replace(\"\\n\", \"&lt;br&gt;\")\n        command_output_html += f\"&lt;b&gt;Stderr:&lt;/b&gt; { stderr_result }\"\n\n        return command_output_html\n\n    def build_documents(self, force: bool = False) -&gt; str:\n        \"\"\"Build the documents static pages\n\n        Builds the documents static pages if any documents have been modified since\n        last build.\n\n        Args:\n            project_id (str): the primary key for the project\n        \"\"\"\n        project: Project\n        time_now = timezone.now()\n        build_output: str = \"\"\n        last_build: Optional[datetime] = None\n        last_modified: Optional[datetime] = None\n        preprocessor_output: str = \"\"\n\n        project = project = Project.objects.get(id=self.project_id)\n        last_build = project.last_built\n        last_modified = project.last_modified\n\n        if (\n            isinstance(last_modified, datetime)\n            and isinstance(last_build, datetime)\n            and not force\n        ):\n            if last_modified &lt; last_build:\n                return \"\"\n\n        preprocessor_output = self.preprocessor()\n        if preprocessor_output == \"\":\n            return \"Preprocessor error!\"\n\n        build_output = self.build()\n        if build_output == \"\":\n            return \"mkdocs build error!\"\n\n        build_output = f\"{ preprocessor_output } {build_output}\"\n\n        project.last_built = time_now\n        project.build_output = build_output\n        project.save()\n\n        return build_output\n</code></pre>"},{"location":"code/functions/mkdocs_control/#functions.mkdocs_control.MkdocsControl.__init__","title":"<code>__init__(project_id, projects_folder=c.PROJECTS_FOLDER)</code>","text":"<p>Initialises the MkDocsControl class</p> <p>Parameters:</p> Name Type Description Default <code>cwd_sh</code> <code>str</code> <p>the current working directory for the shell script</p> required Source code in <code>app/dcsp/app/functions/mkdocs_control.py</code> <pre><code>def __init__(\n    self,\n    project_id: int | str,\n    projects_folder: str = c.PROJECTS_FOLDER,\n) -&gt; None:\n    \"\"\"Initialises the MkDocsControl class\n\n    Args:\n        cwd_sh (str): the current working directory for the shell script\n    \"\"\"\n    self.project_id: int = 0\n    self.process_name: str = \"mkdocs\"\n    self.process_arg1: str = \"serve\"\n    self.documentation_pages: str = \"\"\n    self.project_folder: str = \"\"\n\n    if not isinstance(project_id, int):\n        if not project_id.isdigit():\n            raise ValueError(\n                f\"'project_id of '{ project_id }' is not an integer\"\n            )\n\n    self.project_id = int(project_id)\n\n    # TODO should check in model if project ID exists\n    if self.project_id &lt;= 0:\n        raise ValueError(\n            f\"'project_id of '{ project_id }' must be 1 or more\"\n        )\n\n    self.documentation_pages = (\n        f\"{ c.DOCUMENTATION_PAGES }/project_{ self.project_id }\"\n    )\n\n    if not Path(self.documentation_pages).is_dir():\n        Path(self.documentation_pages).mkdir(parents=True, exist_ok=True)\n\n    self.project_folder = f\"{ projects_folder }project_{ project_id }/\"\n\n    self.documents_directory = (\n        f\"{ self.project_folder }{ c.CLINICAL_SAFETY_FOLDER }\"\n    )\n\n    # TODO #56 - was this meant to check projects_folder or project_folder (not the s)\n    if not Path(projects_folder).is_dir():\n        raise FileExistsError(f\"'{ projects_folder }' does not exist\")\n\n    return\n</code></pre>"},{"location":"code/functions/mkdocs_control/#functions.mkdocs_control.MkdocsControl.build","title":"<code>build()</code>","text":"Source code in <code>app/dcsp/app/functions/mkdocs_control.py</code> <pre><code>def build(self) -&gt; str:\n    \"\"\" \"\"\"\n    command: list[str] = []\n    command_output_dir: str = (\n        f\"{ c.DOCUMENTATION_PAGES }/project_{ self.project_id }\"\n    )\n    command_output: CompletedProcess[str]\n    command_output_html: str = \"\"\n    stdout_result: str = \"\"\n    stderr_result: str = \"\"\n\n    if not Path(command_output_dir).is_dir():\n        raise FileExistsError(\n            f\"'{ command_output_dir }' directory does not exist\"\n        )\n\n    command = [\n        \"/usr/local/bin/mkdocs\",\n        \"build\",\n        \"-d\",\n        command_output_dir,\n    ]\n\n    command_output = subprocess.run(\n        command,\n        shell=False,\n        check=False,\n        cwd=self.documents_directory,\n        capture_output=True,\n        text=True,\n    )  # nosec B603\n\n    if command_output.returncode == 0:\n        command_output_html += \"&lt;b&gt;Successful mkdocs build&lt;/b&gt;\"\n    else:\n        command_output_html += \"&lt;b&gt;Mkdocs build errors!&lt;/b&gt;\"\n\n    command_output_html += \"&lt;br&gt;&lt;hr&gt;\"\n\n    stdout_result = command_output.stdout.replace(\"\\n\", \"&lt;br&gt;\")\n    command_output_html += f\"&lt;b&gt;Stdout:&lt;/b&gt; { stdout_result }\"\n\n    command_output_html += \"&lt;br&gt;&lt;hr&gt;\"\n\n    stderr_result = command_output.stderr.replace(\"\\n\", \"&lt;br&gt;\")\n    command_output_html += f\"&lt;b&gt;Stderr:&lt;/b&gt; { stderr_result }\"\n\n    return command_output_html\n</code></pre>"},{"location":"code/functions/mkdocs_control/#functions.mkdocs_control.MkdocsControl.build_documents","title":"<code>build_documents(force=False)</code>","text":"<p>Build the documents static pages</p> <p>Builds the documents static pages if any documents have been modified since last build.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>the primary key for the project</p> required Source code in <code>app/dcsp/app/functions/mkdocs_control.py</code> <pre><code>def build_documents(self, force: bool = False) -&gt; str:\n    \"\"\"Build the documents static pages\n\n    Builds the documents static pages if any documents have been modified since\n    last build.\n\n    Args:\n        project_id (str): the primary key for the project\n    \"\"\"\n    project: Project\n    time_now = timezone.now()\n    build_output: str = \"\"\n    last_build: Optional[datetime] = None\n    last_modified: Optional[datetime] = None\n    preprocessor_output: str = \"\"\n\n    project = project = Project.objects.get(id=self.project_id)\n    last_build = project.last_built\n    last_modified = project.last_modified\n\n    if (\n        isinstance(last_modified, datetime)\n        and isinstance(last_build, datetime)\n        and not force\n    ):\n        if last_modified &lt; last_build:\n            return \"\"\n\n    preprocessor_output = self.preprocessor()\n    if preprocessor_output == \"\":\n        return \"Preprocessor error!\"\n\n    build_output = self.build()\n    if build_output == \"\":\n        return \"mkdocs build error!\"\n\n    build_output = f\"{ preprocessor_output } {build_output}\"\n\n    project.last_built = time_now\n    project.build_output = build_output\n    project.save()\n\n    return build_output\n</code></pre>"},{"location":"code/functions/mkdocs_control/#functions.mkdocs_control.MkdocsControl.preprocessor","title":"<code>preprocessor(entry_type='hazard')</code>","text":"<p>Adds all entry to the entries-summary page</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>a string of outcomes from function, formatted for html</p> Source code in <code>app/dcsp/app/functions/mkdocs_control.py</code> <pre><code>def preprocessor(self, entry_type: str = \"hazard\") -&gt; str:\n    \"\"\"Adds all entry to the entries-summary page\n\n    Returns:\n        str: a string of outcomes from function, formatted for html\n    \"\"\"\n    entries_dir: str = f\"{ self.documents_directory }docs/{ entry_type }s/\"\n    entries_entries_dir: str = f\"{ entries_dir }{ entry_type }s/\"\n    entry_template_dir: str = f\"{ self.documents_directory }templates/\"\n    files_to_check: list[str] = []\n    docstring: DocstringManipulation\n    # file\n    # entry_file\n    contents_str: str = \"\"\n    # file_name\n    # entry_name\n    # entry_number\n    # entry_name_match\n    warnings: str = \"\"\n    entries: list[dict[str, Any]] = []\n    project: ProjectBuilder\n    contents_list: list[dict[str, Any]] = []\n    entry_form: dict[str, Any]\n    icon_html: str = \"\"\n    code_html: str = \"\"\n    referenced_hazards: list[dict[str, Any]] = []\n    function_hazards: list[str] = []\n\n    if not Path(entries_dir).is_dir():\n        return (\n            \"&lt;b&gt;Failed preprocessor&lt;/b&gt;\"\n            \"&lt;br&gt;&lt;hr&gt;\"\n            f\"'{ entries_dir }' directory does not exist\"\n            \"&lt;br&gt;&lt;hr&gt;\"\n        )\n\n    if not Path(entries_entries_dir).is_dir():\n        Path(entries_entries_dir).mkdir(parents=True, exist_ok=True)\n        return (\n            \"&lt;b&gt;Preprocessor passed with INFO&lt;/b&gt;\"\n            \"&lt;br&gt;&lt;hr&gt;\"\n            f\"INFO - '{ entries_entries_dir }' directory did not exist, now created\"\n            \"&lt;br&gt;&lt;hr&gt;\"\n        )\n\n    for path, _, files in os.walk(entries_entries_dir):\n        for name in files:\n            if fnmatch(name, \"*.md\"):\n                files_to_check.append(os.path.join(path, name))\n\n    # Sort the list of file paths based on the file numbers\n    files_to_check = sorted(files_to_check, reverse=True)\n\n    if not len(files_to_check):\n        return (\n            \"&lt;b&gt;Preprocessor passed with INFO&lt;/b&gt;\"\n            \"&lt;br&gt;&lt;hr&gt;\"\n            f\"INFO - No entries found in '{ entries_entries_dir }' folder.\"\n            \"Entries summary page could not be created\"\n            \"&lt;br&gt;&lt;hr&gt;\"\n        )\n\n    # TODO - should check there are no files with same entry number (eg hazard-1 and hazard-01 and hazard-001)\n\n    docstring = DocstringManipulation(self.project_id)\n    referenced_hazards = docstring.docstring_all()\n\n    for file in files_to_check:\n        icon_html = \"\"\n        function_hazards = []\n\n        entry_file = open(file, \"r\")\n        contents_str = entry_file.read()\n        file_name = Path(file).stem\n\n        try:\n            entry_number = file_name.split(\"-\")[1]\n            if not entry_number.isdigit():\n                entry_number = \"[Non-digit entry number]\"\n                warnings += f\"WARNING - A non-digit 'number' in entry file name '{ file_name }'\"\n        except:\n            entry_number = \"[Number not defined]\"\n\n        for function_info in referenced_hazards:\n            for hazard in function_info[\"hazards\"]:\n                if hazard[\"hazard_number\"] == entry_number:\n                    function_hazards.append(function_info[\"mk_file_path\"])\n\n                    # print(entry_number)\n                    # print(function_hazards)\n\n        project = ProjectBuilder(self.project_id)\n        # TODO - need to figure out which entry_types are preprocessed\n        contents_list = project.entry_read_with_field_types(\"hazard\", file)\n\n        for field in contents_list:\n            if field[\"field_type\"] == \"icon\":\n                env = Environment(\n                    loader=FileSystemLoader(entry_template_dir),\n                    autoescape=True,\n                )\n                template = env.get_template(f\"{ entry_type }-icons.md\")\n\n                context = {\"contents_list\": contents_list}\n                icon_html = template.render(context)\n                icon_html = f\"{ icon_html }\\n&lt;!-- [iconend] --&gt;\"\n\n            elif field[\"field_type\"] == \"code\":\n                code_html = \"\"\n\n                for function in referenced_hazards:\n                    for hazard in function[\"hazards\"]:\n                        if hazard[\"hazard_number\"] == entry_number:\n                            code_html += (\n                                f\"[{ function['code_file'].replace('.py', '') }\"\n                                f\".{ hazard['sub_routine']}](../../{ function['mk_file_path'] }\"\n                                f\"#{ hazard['sub_routine']}_hazard)\\n\\n\"\n                            )\n\n                code_html = code_html.rstrip(\"\\n\\n\")\n\n                if not code_html:\n                    code_html = \"Hazard not mentioned in source code\"\n\n        entry_form = project.entry_file_read_to_form(\n            contents_list,\n            icon_html,\n            code_html,\n        )\n\n        project.entry_update(\n            entry_form,\n            entry_type,\n            entry_number,\n        )\n        pattern = re.compile(\n            r\"&lt;!--\\s*\\[icon\\]\\s*--&gt;.*?&lt;!--\\s*\\[iconend\\]\\s*--&gt;\",\n            re.DOTALL,\n        )\n        contents_str = re.sub(pattern, \"\", contents_str)\n        contents_str = contents_str.replace(\"../../\", \"../\")\n        icon_html = icon_html.replace(\"../../\", \"../\")\n        icon_html = icon_html.replace(\n            'class=\"icon-large\"',\n            'class=\"icon-small\"',\n        )\n\n        entries.append(\n            {\n                \"number\": entry_number,\n                \"contents_str\": contents_str,\n                \"contents_list\": contents_list,\n                \"icon_html\": icon_html,\n            }\n        )\n\n    # Creating the summary\n    env = Environment(\n        loader=FileSystemLoader(entry_template_dir), autoescape=True\n    )\n    template = env.get_template(\n        f\"{ entry_type }{ c.ENTRY_SUMMARY_SUFFIX }\"\n    )\n    context = {\"entries\": entries}\n    md_content = template.render(context)\n    summary_file = open(\n        f\"{ entries_dir }{ entry_type }{ c.ENTRY_SUMMARY_SUFFIX }\",\n        \"w\",\n    )\n    summary_file.write(md_content)\n    summary_file.close()\n\n    if warnings:\n        return (\n            \"&lt;b&gt;Successful preprocessor step with WARNINGS&lt;/b&gt;\"\n            \"&lt;br&gt;&lt;hr&gt;\"\n            f\"{ warnings }\"\n            \"&lt;br&gt;&lt;hr&gt;\"\n        )\n    else:\n        return \"&lt;b&gt;Successful preprocessor step&lt;/b&gt;\" \"&lt;br&gt;&lt;hr&gt;\"\n</code></pre>"},{"location":"code/functions/projects_builder/","title":"Project builder","text":"<p>Functionality to create and manipulate files for mkdocs</p> <p>This module carries out all of the functionality needed to create and manipulate markdown and yaml files for use in mkdocs, a static web site generator.</p> <p>Classes:</p> Name Description <code>ProjectBuilder</code> <p>a class to create and manipulate files for mkdocs</p>"},{"location":"code/functions/projects_builder/#functions.project_builder.ProjectBuilder","title":"<code>ProjectBuilder</code>","text":"<p>A class to create and manipulate files for mkdocs</p> <p>This class carries out all of the functionality needed to create and manipulate markdown and yaml files for use in mkdocs, a static web site generator.</p> <p>Methods:</p> Name Description <code>new_build_prohibit</code> <p>a decorator to stop certain methods being used for a new                 build project.</p> <code>new_build</code> <p>creates a new project and associated files.</p> <code>master_template_get</code> <p>gets the different types of document templates available.</p> <code>configuration_get</code> <p>gets the configuration settings for the project.</p> <code>configuration_set</code> <p>sets the configuration settings for the project.</p> <code>copy_templates</code> <p>copies a project template to the clinical safety folder.</p> <code>get_placeholders</code> <p>gets the placeholders found in markdown files.</p> <code>save_placeholders</code> <p>saves placeholders to yaml.</p> <code>save_placeholders_from_form</code> <p>saves placeholders to yaml from a form.</p> <code>read_placeholders</code> <p>reads placeholders from yaml file.</p> <code>entry_exists</code> <p>checks if an entry of certain type exists.</p> <code>entry_file_read</code> <p>reads the contents of either an entry template or entry instance.</p> <code>entry_read_with_field_types</code> <p>read an instance of a entry with field typing.</p> <code>_heading_numbering</code> <p>creates a numbered heading.</p> <code>_create_gui_label</code> <p>creates a user readable label.</p> <code>entry_update</code> <p>creates or updates entries (eg Hazards and incidents).</p> <code>entry_file_read_to_form</code> <p>reads the contents of either an entry template or entry instance.</p> <code>entry_template_names</code> <p>gets the names of the entry templates.</p> <code>entry_type_exists</code> <p>checks if an entry type exists.</p> <code>entries_all_get</code> <p>gets all of the hazards for the project.</p> <code>form_initial</code> <p>returns data for initialising a django form.</p> <code>document_create_check</code> <p>checks and creates a new document.</p> <code>document_create</code> <p>creates a new document.</p> <code>document_list</code> <p>Returns documents for the project.</p> <code>_entry_templates_list</code> <p>returns a list of entry templates.</p> <code>_entry_templates_exclude</code> <p>directories to exclude.</p> Source code in <code>app/dcsp/app/functions/project_builder.py</code> <pre><code>class ProjectBuilder:\n    \"\"\"A class to create and manipulate files for mkdocs\n\n    This class carries out all of the functionality needed to create and manipulate\n    markdown and yaml files for use in mkdocs, a static web site generator.\n\n    functions:\n        new_build_prohibit: a decorator to stop certain methods being used for a new\n                            build project.\n        new_build: creates a new project and associated files.\n        master_template_get: gets the different types of document templates available.\n        configuration_get: gets the configuration settings for the project.\n        configuration_set: sets the configuration settings for the project.\n        copy_templates: copies a project template to the clinical safety folder.\n        get_placeholders: gets the placeholders found in markdown files.\n        save_placeholders: saves placeholders to yaml.\n        save_placeholders_from_form: saves placeholders to yaml from a form.\n        read_placeholders: reads placeholders from yaml file.\n        entry_exists: checks if an entry of certain type exists.\n        entry_file_read: reads the contents of either an entry template or entry instance.\n        entry_read_with_field_types: read an instance of a entry with field typing.\n        _heading_numbering: creates a numbered heading.\n        _create_gui_label: creates a user readable label.\n        entry_update: creates or updates entries (eg Hazards and incidents).\n        entry_file_read_to_form: reads the contents of either an entry template or entry instance.\n        entry_template_names: gets the names of the entry templates.\n        entry_type_exists: checks if an entry type exists.\n        entries_all_get: gets all of the hazards for the project.\n        form_initial: returns data for initialising a django form.\n        document_create_check: checks and creates a new document.\n        document_create: creates a new document.\n        document_list: Returns documents for the project.\n        _entry_templates_list: returns a list of entry templates.\n        _entry_templates_exclude: directories to exclude.\n    \"\"\"\n\n    def __init__(\n        self,\n        project_id: int = 0,\n    ) -&gt; None:\n        \"\"\"Initialises the ProjectBuilder class\n\n        Project builder initialiser\n\n        Args:\n            project_id (int): the id of the project to be worked on. A value of\n                              0 means a new project is being created.\n\n        Raises:\n            TypeError: if project_id is not an integer.\n            ValueError: if project_id is not a positive integer\n        \"\"\"\n        self.new_build_flag: bool = False\n        self.project_id: int = 0\n        self.master_template_directory: str = \"\"\n        self.project_directory: str = \"\"\n        self.safety_directory: str = \"\"\n        self.documents_yaml: str = \"\"\n        self.docs_dir: str = \"\"\n        self.placeholders_yaml: str = \"\"\n        self.entries_templates_dir: str = \"\"\n\n        if not isinstance(project_id, int):\n            raise TypeError(f\"'project_id' '{ project_id }' is not an integer\")\n\n        if project_id == 0:\n            self.new_build_flag = True\n        elif project_id &lt; 0:\n            raise ValueError(\n                f\"'project_id' '{ project_id }' is not a positive integer\"\n            )\n\n        self.project_id = project_id\n        self.master_template_directory = c.MASTER_TEMPLATES\n        self.project_directory = (\n            f\"{ c.PROJECTS_FOLDER }project_{ self.project_id }/\"\n        )\n        self.safety_directory = (\n            f\"{ self.project_directory }{ c.CLINICAL_SAFETY_FOLDER }\"\n        )\n        self.documents_yaml = f\"{ self.safety_directory }documents.yml\"\n        self.docs_dir = f\"{ self.safety_directory }docs/\"\n        self.placeholders_yaml = f\"{ self.safety_directory }placeholders.yml\"\n        self.entries_templates_dir = f\"{ self.safety_directory }templates/\"\n\n        return\n\n    @staticmethod\n    def new_build_prohibit(func: Callable[..., Any]) -&gt; Callable[..., Any]:\n        \"\"\"A decorator checking if a method can be used\n\n        If used, this decorator only allows a method to be used if a project_id\n        is 1 or more.\n\n        functions:\n            wrapper: to check if a method can be used\n        \"\"\"\n\n        @wraps(func)\n        def wrapper(self: \"ProjectBuilder\", *args: Any, **kwargs: Any) -&gt; Any:\n            \"\"\"Wraps around the page function.\n\n            Args:\n                request (HttpRequest):\n                project_id (str): datanase primary key for project\n\n            Returns:\n                HttpResponse | func: error responses or runs func.\n\n            Raises:\n                SyntaxError: if the function is not allowed for a new-build project\n            \"\"\"\n            if self.new_build_flag:\n                raise SyntaxError(\n                    \"This function is not allowed for a new-build project (with no primary key)\"\n                )\n\n            return func(self, *args, **kwargs)\n\n        return wrapper\n\n    def test_no_wrapper(self) -&gt; None:\n        \"\"\"Do not alter this function.\n\n        Used for testing the new_build_prohibit decorator.\n        \"\"\"\n        return\n\n    @new_build_prohibit\n    def test_with_wrapper(self) -&gt; None:\n        \"\"\"Do not alter this function (or decorator).\n\n        Used for testing the new_build_prohibit decorator.\n        \"\"\"\n        return\n\n    def new_build(self, request: HttpRequest) -&gt; None:\n        \"\"\"Creates a new project and associated files\n\n        This function creates a new project and associated files. It also creates a\n        new project in the database.\n\n        Args:\n            request (HttpRequest): the request object\n\n        Returns:\n            Tuple[bool, str]: True when successful build. String is a list of\n                              errors, if present.\n\n        Raises:\n            ValueError: User id could not be converted to an integer\n            KeyError: 'setup_choice' not set\n            ValueError: 'setup_choice' is incorrectly set\n            KeyError: 'external_repository_username_import' not set\n            KeyError: 'external_repository_password_token_import' not set\n            KeyError: 'external_repository_url_import' not set\n            RepositoryAccessException: if the repository does not exist or is not\n                                       accessible\n            NotImplementedError: Code for other external repositories is not yet\n                                 written.\n            FileExistsError: if the project directory already exists\n        \"\"\"\n        user_id: int = 0\n        inputs = request.session[\"inputs\"]\n        new_project: Project\n        group_id: int = 0\n        github_controller: GitHubController\n        new_user_project_attribute: UserProjectAttribute\n        new_project_directory: str = \"\"\n        new_safety_directory: str = \"\"\n\n        if not isinstance(request.user.id, int):\n            raise ValueError(\"User id could not be converted to an integer\")\n\n        user_id = int(request.user.id)\n\n        if not \"setup_choice\" in inputs:\n            raise KeyError(\"'setup_choice' not set\")\n\n        if (\n            inputs[\"setup_choice\"] != \"start_anew\"\n            and inputs[\"setup_choice\"] != \"import\"\n        ):\n            raise ValueError(\"'setup_choice' is incorrectly set\")\n\n        if inputs[\"setup_choice\"] == \"import\":\n            if not \"external_repository_username_import\" in inputs:\n                raise KeyError(\"'external_repository_username_import' not set\")\n            if not \"external_repository_password_token_import\" in inputs:\n                raise KeyError(\n                    \"'external_repository_password_token_import' not set\"\n                )\n            if not \"external_repository_url_import\" in inputs:\n                raise KeyError(\"'external_repository_url_import' not set\")\n\n        if inputs[\"setup_choice\"] == \"import\":\n            if inputs[\"repository_type\"] == \"github\":\n                github_controller = GitHubController(\n                    inputs[\"external_repository_username_import\"],\n                    inputs[\"external_repository_password_token_import\"],\n                )\n                if not github_controller.repository_exists(\n                    inputs[\"external_repository_url_import\"]\n                ):\n                    raise RepositoryAccessException(\n                        inputs[\"external_repository_url_import\"]\n                    )\n\n            else:\n                # TODO #44\n                raise NotImplementedError(\n                    \"Code for other external repositories is not yet written.\",\n                )\n\n        # Database record creation\n        new_project = Project()\n        new_project.name = inputs[\"project_name\"]\n        new_project.description = inputs[\"description\"]\n        new_project.access = inputs[\"access\"]\n        new_project.owner = User.objects.get(id=user_id)\n\n        if inputs[\"setup_choice\"] == \"import\":\n            new_project.external_repository_url = inputs[\n                \"external_repository_url_import\"\n            ]\n\n        new_project.save()\n        new_project.member.set(User.objects.filter(id__in=inputs[\"members\"]))\n        new_project.save()\n\n        request.session[\"project_id\"] = new_project.id\n\n        new_user_project_attribute = UserProjectAttribute()\n        new_user_project_attribute.user = User.objects.get(id=user_id)\n        new_user_project_attribute.project = new_project\n\n        if inputs[\"setup_choice\"] == \"import\":\n            new_user_project_attribute.repository_username = inputs[\n                \"external_repository_username_import\"\n            ]\n            new_user_project_attribute.repository_password_token = inputs[\n                \"external_repository_password_token_import\"\n            ]\n\n        new_user_project_attribute.save()\n\n        for group_id in map(int, inputs[\"groups\"]):\n            group = ProjectGroup.objects.get(id=group_id)\n            group.project_access.add(new_project)\n            group.save()\n\n        new_project_directory = (\n            f\"{ c.PROJECTS_FOLDER }project_{ new_project.id }/\"\n        )\n        new_safety_directory = (\n            f\"{ new_project_directory }{ c.CLINICAL_SAFETY_FOLDER }\"\n        )\n\n        if Path(new_project_directory).is_dir():\n            raise FileExistsError(\n                f\"'{ new_project_directory }' already exists\",\n            )\n\n        Path(new_project_directory).mkdir(parents=True, exist_ok=True)\n\n        if inputs[\"setup_choice\"] == \"import\":\n            git_controller = GitController()\n            git_controller.clone(\n                inputs[\"external_repository_url_import\"],\n                new_project_directory,\n            )\n\n        if not Path(new_safety_directory).is_dir():\n            Path(new_safety_directory).mkdir(parents=True, exist_ok=True)\n\n        return\n\n    def master_template_get(self) -&gt; list[str]:\n        \"\"\"Get the different types of master templates available\n\n        Looks in the master template folder for template subfolders. Technically\n        a template is a collection of markdown and yaml files.\n\n        Returns:\n            list[str]: a list of templates in alphabetical order.\n\n        Raises:\n            FileNotFoundError: if no template subfolder found in templates main\n                               folder.\n        \"\"\"\n        templates: list[str] = []\n\n        templates = [\n            directory.name\n            for directory in Path(self.master_template_directory).iterdir()\n            if directory.is_dir()\n        ]\n\n        if not templates:\n            raise FileNotFoundError(\n                f\"No templates folders found in '{ self.master_template_directory }' template directory\"\n            )\n\n        return sorted(templates, key=str.lower)\n\n    @new_build_prohibit\n    def configuration_get(self) -&gt; dict[str, Any]:\n        \"\"\"Returns the configuration settings for the project\n\n        Reads the setup.ini file in the clinical safety folder and returns the\n        settings.\n\n        Returns:\n            dict[str, Any]: a dictionary of the settings.\n\n        Raises:\n            FileNotFoundError: if the clinical safety folder does not exist.\n        \"\"\"\n        configration_file: str = f\"{ self.safety_directory }setup.ini\"\n        config: Optional[ENVManipulator] = None\n\n        if not Path(self.safety_directory).is_dir():\n            raise FileNotFoundError(\n                f\"'{ self.safety_directory }' does not exist\"\n            )\n\n        config = ENVManipulator(configration_file)\n        setup_step: Optional[str] = None\n\n        setup_step = config.read(\"setup_step\")\n\n        # catches negative numbers and non-numeric characters\n        if not setup_step.isdigit():\n            setup_step = \"1\"\n            config.add(\"setup_step\", setup_step)\n\n        return {\"setup_step\": int(setup_step)}\n\n    @new_build_prohibit\n    def configuration_set(self, key: str, value: str) -&gt; bool:\n        \"\"\"Sets the configuration settings for the project\n\n        Writes to the setup.ini file in the clinical safety folder.\n\n        Args:\n            key (str): the key to be set.\n            value (str): the value to be set.\n\n        Returns:\n            bool: True if successful, False if not.\n\n        Raises:\n            FileNotFoundError: if the clinical safety folder does not exist.\n        \"\"\"\n        configration_file: str = f\"{ self.safety_directory }setup.ini\"\n        config: Optional[ENVManipulator] = None\n\n        if not Path(self.safety_directory).is_dir():\n            raise FileNotFoundError(\n                f\"'{ self.safety_directory }' does not exist\"\n            )\n\n        config = ENVManipulator(configration_file)\n\n        config.add(key, str(value))\n        return True\n\n    @new_build_prohibit\n    def copy_master_template(self, template_chosen: str) -&gt; None:\n        \"\"\"Copies a master template to the clinical safety folder\n\n        Copies a master template to the clinical safety folder.\n\n        Args:\n            template_chosen (str): the template to copy across.\n\n        Raises:\n            FileNotFoundError: if the template chosen does not exist.\n        \"\"\"\n        template_chosen_path: str = (\n            f\"{ self.master_template_directory }{ template_chosen }\"\n        )\n\n        if not Path(template_chosen_path).is_dir():\n            raise FileNotFoundError(\n                f\"'{ template_chosen_path }' does not exist\"\n            )\n\n        shutil.copytree(\n            template_chosen_path,\n            self.safety_directory,\n            dirs_exist_ok=True,\n        )\n        return\n\n    @new_build_prohibit\n    def get_placeholders(self) -&gt; dict[str, str]:\n        \"\"\"Returns the placeholders found in markdown files\n\n        Searches the docs folder for markdown files and extracts all placeholders.\n\n        Returns:\n            dic[str,str]: a dictionary with the placeholder name as the key and the\n                          value set to an empty string if no previously stored\n                          placeholders, or updated to stored values if they are\n                          available. Uses ninja2 formating, eg {{ placeholder }}.\n\n        Raises:\n            FileNotFoundError: if no files found in the docs folder.\n        \"\"\"\n\n        files_to_check: list[str] = []\n        file_path: str = \"\"\n        file: Optional[TextIO] = None\n        doc_Regex: Optional[Pattern[str]] = None\n        placeholders_sub: list[str] = []\n        placeholder: str = \"\"\n        placeholders_raw: list[str] = []\n        stored_placeholders: dict[str, str] = {}\n        placeholders_clean: dict[str, str] = {}\n\n        files_to_check = [str(p) for p in Path(self.docs_dir).rglob(\"*.md\")]\n\n        if not len(files_to_check):\n            raise FileNotFoundError(\n                f\"No files found in mkdocs '{ self.docs_dir }' folder\"\n            )\n\n        for file_path in files_to_check:\n            file = open(file_path, \"r\")\n            doc_Regex = re.compile(r\"\\{\\{.*?\\}\\}\", flags=re.S)\n            placeholders_sub = doc_Regex.findall(file.read())\n            for placeholder in placeholders_sub:\n                if placeholder not in placeholders_raw:\n                    placeholders_raw.append(placeholder)\n            file.close()\n\n        if Path(self.placeholders_yaml).exists():\n            stored_placeholders = self.read_placeholders()\n\n        for placeholder in placeholders_raw:\n            placeholder = placeholder.replace(\"{{\", \"\")\n            placeholder = placeholder.replace(\"}}\", \"\")\n            placeholder = placeholder.strip()\n            placeholders_clean[placeholder] = stored_placeholders.get(\n                placeholder, \"\"\n            )\n        return placeholders_clean\n\n    @new_build_prohibit\n    def save_placeholders(self, placeholders: dict[str, str]) -&gt; None:\n        \"\"\"Saves placeholders to yaml file\n\n        Saves the placeholders, supplied as a dictionary, into the\n        placeholders.yml file in the clinical safety folder.\n\n        Args:\n            placeholders (dict[str,str]): dictionary of placeholders. Key is name\n                                          of placeholder and value is the value.\n\n        Raises:\n            FileNotFoundError: if the safety directory does not exist.\n        \"\"\"\n        placeholders_extra: dict[str, dict[str, str]] = {\"extra\": placeholders}\n        file: Optional[TextIO] = None\n\n        if not Path(self.safety_directory).is_dir():\n            raise FileNotFoundError(\n                f\"'{ self.safety_directory }' does not exist\"\n            )\n\n        with open(self.placeholders_yaml, \"w\") as file:\n            yaml.dump(placeholders_extra, file)\n        return\n\n    def save_placeholders_from_form(self, form: PlaceholdersForm) -&gt; None:\n        \"\"\"Saves placeholders to yaml\n\n        Saves the placeholders, as supplied via a web form. Note that\n        get_placeholders can raise a FileNotFoundError if no files found in the\n        docs folder and save_placeholders can raise a FileNotFoundError if the\n        safety directory does not exist.\n\n        Args:\n            form (dict[str,str]): dictionary of placeholders.\n        \"\"\"\n        placeholders: dict[str, str] = self.get_placeholders()\n\n        for placeholder in placeholders:\n            placeholders[placeholder] = form.cleaned_data.get(placeholder, \"\")\n\n        self.save_placeholders(placeholders)\n        return\n\n    @new_build_prohibit\n    def read_placeholders(self) -&gt; dict[str, str]:\n        \"\"\"Read placeholders from yaml file\n\n        Reads already stored placeholder values as stored in placeholders.yml.\n\n        Returns:\n            dict[str,str]: placeholder names and value pairs.\n\n        Raises:\n            FileNotFoundError: if placeholder yaml is not a valid file.\n            ValueError: if error reading content of yaml file (eg no 'extra'\n                        key).\n        \"\"\"\n        placeholders_extra: dict[str, dict[str, str]] = {}\n        file: Optional[TextIO] = None\n        return_dict: dict[str, str] = {}\n\n        if not Path(self.placeholders_yaml).is_file():\n            raise FileNotFoundError(\n                f\"'{ self.placeholders_yaml }' is not a valid path\"\n            )\n\n        with open(self.placeholders_yaml, \"r\") as file:\n            placeholders_extra = yaml.safe_load(file)\n\n        try:\n            return_dict = placeholders_extra[\"extra\"]\n        except:\n            raise ValueError(\n                \"Error with placeholders yaml file, likely 'extra' missing from file\"\n            )\n        return return_dict\n\n    @new_build_prohibit\n    def entry_exists(self, entry_type: str, id: int) -&gt; bool:\n        \"\"\"Checks if an entry of certain type exists\n\n        Args:\n            entry_type (str): named type of entry\n            id (int): the id to be assessed if an associated entry exists\n\n        Returns:\n            bool: true if entry is a positive integer and exists.\n        \"\"\"\n        directory_to_check: str = f\"{ c.PROJECTS_FOLDER }project_{ self.project_id }/{ c.CLINICAL_SAFETY_FOLDER }docs/{ entry_type }s/{ entry_type }s/\"\n        file_to_find: str = f\"{ entry_type }-{ id }.md\"\n\n        if not isinstance(id, int):\n            raise ValueError(f\"'id' '{ id }' is not an integer\")\n\n        if id &lt; 1:\n            raise ValueError(f\"'id' '{ id }' is not a positive integer\")\n\n        if any(Path(directory_to_check).rglob(file_to_find)):\n            return True\n\n        return False\n\n    @new_build_prohibit\n    def entry_file_read(\n        self,\n        entry_type: str,\n        non_template_path: str = \"\",\n    ) -&gt; list[dict[str, Any]]:\n        \"\"\"Read the contents of either an entry template or entry instance\n\n        Args:\n            entry_type (str): the type of entry (eg hazard or incident)\n            non_template_path (str): if empty string, then read template,\n                                     otherwise read contents from file path.\n\n        Returns:\n            list[dict[str, Any]]: a dictionary of fields.\n\n        Raises:\n            FileExistsError: if entry instance or template does not exist.\n        \"\"\"\n        entry_file_path: str = \"\"\n        lines: list[str] = []\n        line: str = \"\"\n        headed: bool = False\n        heading: str = \"\"\n        content_list: list[dict[str, Any]] = []\n        horizontal_line: str = \"\"\n        br_line: str = \"\"\n        matches: list[str] = []\n        argument: str = \"\"\n        index: int = 0\n        element: dict[str, Any] = {}\n        choice_name: str = \"\"\n        choices_list: list[Any] = []\n        key: str = \"\"\n        value: str = \"\"\n        text_list: list[str] = []\n        choice: str = \"\"\n        choice_split: list[str] = []\n        choices_dict_split: dict[str, str] = {}\n        potential_number: str = \"\"\n\n        if non_template_path == \"\":\n            entry_file_path = f\"{ self.entries_templates_dir }{ entry_type }{ c.ENTRY_TEMPLATE_SUFFIX }\"\n        else:\n            entry_file_path = non_template_path\n\n        if not Path(entry_file_path).is_file():\n            raise FileNotFoundError(f\"'{ entry_file_path }' does not exists\")\n\n        lines = open(entry_file_path, \"r\").read().split(\"\\n\")\n\n        for line in lines:\n            line = line.strip()\n\n            # To match the heading line\n            if re.match(r\"^#\", line):\n                headed = True\n                heading = line\n\n                content_list.append(\n                    {\n                        \"field_type\": \"text_area\",  # This is changed later if needed\n                        \"heading\": self._heading_numbering(\n                            heading,\n                            content_list,\n                        ),\n                        \"gui_label\": self._create_gui_label(heading),\n                        \"text\": \"\",\n                    }\n                )\n\n            # To match the horizontal line\n            elif re.match(r\"^-\", line):\n                horizontal_line = line\n                headed = False\n\n                content_list.append(\n                    {\n                        \"field_type\": \"horizontal_line\",\n                        \"heading\": self._heading_numbering(\n                            horizontal_line,\n                            content_list,\n                        ),\n                    }\n                )\n\n            # To match new line tag &lt;br&gt;\n            elif re.match(r\"^&lt;br&gt;\", line):\n                br_line = line\n                headed = False\n\n                content_list.append(\n                    {\n                        \"field_type\": \"new_line\",\n                        \"heading\": self._heading_numbering(\n                            br_line,\n                            content_list,\n                        ),\n                    }\n                )\n\n            # To match the icon line\n            elif re.match(\n                r\"^&lt;!--\\s*\\[\\s*icon\\s*\\]\\s*--&gt;$\",\n                line,\n            ):\n                headed = False\n\n                content_list.append(\n                    {\n                        \"field_type\": \"icon\",\n                        \"heading\": self._heading_numbering(\n                            \"icon\",\n                            content_list,\n                        ),\n                    }\n                )\n\n            elif headed and line:\n                # To match for labels\n                if line[0] == \"[\":\n                    matches = re.findall(r\"\\[([^\\]]+)\\]\", line)\n                    content_list[-1][\"labels\"] = []\n                    for argument in matches:\n                        argument = argument.strip()\n                        if argument == \"select\":\n                            content_list[-1][\"field_type\"] = \"select\"\n                        elif argument == \"multiselect\":\n                            content_list[-1][\"field_type\"] = \"multiselect\"\n                        elif argument == \"calculate\":\n                            content_list[-1][\"field_type\"] = \"calculate\"\n                        elif argument == \"readonly\":\n                            content_list[-1][\"field_type\"] = \"readonly\"\n                        elif argument == \"date\":\n                            content_list[-1][\"field_type\"] = \"date\"\n                        elif argument == \"code\":\n                            content_list[-1][\"field_type\"] = \"code\"\n                            # content_list[-1][\"text\"] = \"&lt;!-- [code] --&gt;\"\n                        else:\n                            content_list[-1][\"labels\"].append(argument)\n\n                # If no labels then use as text\n                else:\n                    content_list[-1][\"text\"] += f\"{ line.strip() }\\n\"\n\n        for index, element in enumerate(content_list):\n            choice_name = \"\"\n            choices_dict_split = {}\n\n            if element[\"field_type\"] == \"select\":\n                choices_list = [(\"\", \"\")]\n            else:\n                choices_list = []\n\n            for key, value in element.items():\n                if key != \"labels\":\n                    content_list[index][key] = value.strip()\n\n            if (\n                element[\"field_type\"] == \"select\"\n                or element[\"field_type\"] == \"multiselect\"\n            ):\n                text_list = element[\"text\"].split(\"\\n\")\n\n                for choice in text_list:\n                    choice_name = choice.split(\":\")[0]\n                    choices_list.append([choice, choice_name])\n                    content_list[index][\"choices\"] = tuple(choices_list)\n\n            elif element[\"field_type\"] == \"calculate\":\n                choices_list = element[\"text\"].split(\"\\n\")\n\n                # TODO what what I trying to do here?\n                for choice in choices_list:\n                    choice_split = choice.split(\"[\")\n                    choices_dict_split[\n                        choice_split[0]\n                    ] = f\"[{ choice_split[1] }\"\n\n                content_list[index][\"choices\"] = choices_dict_split\n\n            if \"text\" in element:\n                content_list[index][\"number\"] = []\n                lines = element[\"text\"].split(\"\\n\")\n\n                for line in lines:\n                    potential_number = line.split(\n                        c.MKDOCS_TEMPLATE_NUMBER_DELIMITER\n                    )[0]\n                    potential_number = potential_number.strip()\n                    if potential_number.isdigit():\n                        content_list[index][\"number\"].append(potential_number)\n\n        return content_list\n\n    def entry_read_with_field_types(\n        self,\n        entry_type: str,\n        entry_file_path: str,\n    ) -&gt; list[dict[str, Any]]:\n        \"\"\"Returns an entry instance with field typing\n\n        Looks up the entry template and the entry instance and matches the\n        fields.\n\n        Args:\n            entry_type (str): the type of entry (eg hazard or incident)\n            entry_file_path (str): the path to the entry file\n        \"\"\"\n        entry_instance: list[dict[str, Any]] = self.entry_file_read(\n            entry_type, entry_file_path\n        )\n        index_entry: int = 0\n        field_entry: dict[str, Any] = {}\n        entry_template: list[dict[str, Any]] = self.entry_file_read(entry_type)\n\n        for index_entry, field_entry in enumerate(entry_instance):\n            for field_template in entry_template:\n                if field_entry[\"heading\"] == field_template[\"heading\"]:\n                    entry_instance[index_entry][\"field_type\"] = field_template[\n                        \"field_type\"\n                    ]\n\n        return entry_instance\n\n    def _heading_numbering(\n        self,\n        heading: str,\n        content_list: list[dict[str, str]],\n    ) -&gt; str:\n        \"\"\"Adds a number to the heading if needed\n\n        Returns a numbered heading if the heading does already exists in the\n        content list.\n\n        Args:\n            heading (str): the heading to be numbered\n            content_list (list[dict[str, str]]): a list of headings. A copy of the\n                                                 list is made to avoid changing the\n                                                 original list.\n\n        Returns:\n            str: the heading with a number if needed.\n\n        Raises:\n            ValueError: if loop exceeds HEADING_MAX_LOOP.\n        \"\"\"\n        heading = heading.strip()\n        heading_numbered: str = \"\"\n\n        content_list = content_list.copy()\n\n        if not any(d[\"heading\"] == heading for d in content_list):\n            return heading\n\n        for x in range(2, c.HEADING_MAX_LOOP):\n            heading_numbered = f\"{ heading } [{ x }]\"\n            if not any(d[\"heading\"] == heading_numbered for d in content_list):\n                return heading_numbered\n            if x == (c.HEADING_MAX_LOOP - 1):\n                # Used break here to get 'raise' outside of for loop and satisfy\n                # mypy\n                break\n\n        raise ValueError(f\"For loop over { c.HEADING_MAX_LOOP }!\")\n\n    def _create_gui_label(self, string: str) -&gt; str:\n        \"\"\"Create user readable label\n\n        User reable string\n\n        Args:\n            string (str): the string to change\n\n        Returns:\n            string: the user readable string in Sentence case.\n        \"\"\"\n\n        string = string.replace(\"#\", \"\")\n        string = string.strip()\n        return string\n\n    @new_build_prohibit\n    def entry_update(\n        self,\n        form_data: dict[str, str],\n        entry_type: str = \"hazard\",\n        id_new: str = \"new\",\n    ) -&gt; dict[str, Any]:\n        \"\"\"Create or update entries (eg hazards and incidents)\n\n        Depending on the value of id_new (a valid int or the str \"new\"), either\n        a new entry will be created or a pre-existing one updated.\n\n        Args:\n            form_data (dict[str, str]): key value pairs of data to be written\n                                        to file\n            entry_type (str): type of entry, eg hazard, incident, officer.\n            id_new (str): a valid digit (1 of more) to update an existing entry\n                          or the word \"new\" to create a new one.\n\n        Returns:\n            dict[str, Any]: returns a dictionary of method outcomes.\n        \"\"\"\n        entries_directory: str = f\"{ c.PROJECTS_FOLDER }project_{ self.project_id }/{ c.CLINICAL_SAFETY_FOLDER }docs/{ entry_type }s/{ entry_type }s/\"\n        files_to_check: list[str] = []\n        filename: str = \"\"\n        match: Optional[re.Match[str]] = None\n        extracted_number: int = 0\n        numbers: list[int] = []\n        entry_file: Optional[TextIO] = None\n        id_int: int = 0\n        to_write: str = \"\"\n        entry_name: str = \"\"\n\n        if not Path(entries_directory).is_dir():\n            Path(entries_directory).mkdir(parents=True, exist_ok=True)\n\n        # files_to_check = [f.name for f in Path(entries_directory).rglob('*.md')]\n        for path, _, files in os.walk(entries_directory):\n            for name in files:\n                if fnmatch(name, \"*.md\"):\n                    files_to_check.append(name)\n\n        if id_new == \"new\":\n            if files_to_check:\n                for filename in files_to_check:\n                    match = re.search(r\"-(\\d+)\\.md\", filename)\n                    if match:\n                        extracted_number = int(match.group(1))\n                        numbers.append(extracted_number)\n                # what happens if numbers is an empty list?\n                id_int = max(numbers) + 1\n            else:\n                id_int = 1\n\n        elif id_new.isdigit() and self.entry_exists(entry_type, int(id_new)):\n            id_int = int(id_new)\n        else:\n            return {\n                \"pass\": False,\n            }\n\n        entry_file = open(\n            f\"{ entries_directory }{ entry_type }-{ id_int }.md\",\n            \"w\",\n        )\n\n        for key, value in form_data.items():\n            to_write = re.sub(r\"\\s*\\[\\d+\\]$\", \"\", key)\n            if to_write == \"icon\":\n                entry_file.write(\"&lt;!-- [icon] --&gt;\\n\")\n            else:\n                entry_file.write(f\"{ to_write }\\n\")\n\n            if isinstance(value, list):\n                for item in value:\n                    entry_file.write(f\"{ item }\\n\\n\")\n            else:\n                entry_file.write(f\"{ value }\\n\\n\")\n        entry_file.close()\n\n        # TODO #54 need to get ride of the 404 in this none view.py code\n        project_timestamp(self.project_id)\n        \"\"\"project = get_object_or_404(Project, id=self.project_id)\n        project.last_modified = timezone.now()\n        project.save()\"\"\"\n\n        for key, value in form_data.items():\n            if \"name\" in key.lower():\n                entry_name = value\n                break\n\n        return {\n            \"pass\": True,\n            \"id\": id_int,\n            \"name\": entry_name,\n            \"entries_url\": f\"{ entry_type }s/{ entry_type }s/{ entry_type }-{ id_int }.html\",\n        }\n\n    def entry_file_read_to_form(\n        self,\n        file_read: list[dict[str, Any]],\n        icon_html: str = \"\",\n        code_html: str = \"\",\n    ) -&gt; dict[str, Any]:\n        \"\"\" \"\"\"\n        element: dict[str, Any] = {}\n        entry_form: dict[str, Any] = {}\n        key: str = \"\"\n\n        for element in file_read:\n            if element[\"field_type\"] == \"icon\":\n                # print(\"icon\")\n                # To copy across ' [number]' if present\n                key = element[\"heading\"].replace(\"icon\", \"\")\n                key = f\"&lt;!-- [icon] --&gt;{ key }\"\n                entry_form[key] = f\"{ icon_html }\"\n\n            elif element[\"field_type\"] == \"code\":\n                # print(\"code\")\n                entry_form[\n                    element[\"heading\"]\n                ] = f\"&lt;!-- [code] --&gt;\\n{ code_html }\\n&lt;!-- [codeend] --&gt;\"\n\n            elif element[\"field_type\"] == \"horizontal_line\":\n                entry_form[element[\"heading\"]] = \"\"\n\n            # TODO #55 might need to consider updating the file_read to include field_types\n            # only the template gives this information at the moment\n            elif \"number\" in element:\n                entry_form[element[\"heading\"]] = element[\"text\"].replace(\n                    \"\\n\", \"\\n\\n\"\n                )\n\n            else:\n                # print(element[\"heading\"])\n                entry_form[element[\"heading\"]] = element[\"text\"]\n\n        return entry_form\n\n    @new_build_prohibit\n    def entry_template_names(self) -&gt; list[str]:\n        \"\"\" \"\"\"\n        templates: Generator[Path, None, None] = Path(\n            self.entries_templates_dir\n        ).glob(\"*-template.md\")\n        templates_ls: list[str] = [file.stem for file in templates]\n        templates_prefix: list[str] = []\n        documents_config: dict[str, str] = {}\n\n        for template in templates_ls:\n            templates_prefix.append(str(template).replace(\"-template\", \"\"))\n\n        if Path(self.documents_yaml).is_file():\n            with open(self.documents_yaml, \"r\") as file:\n                documents_config = yaml.safe_load(file)\n            try:\n                entried_ordered = documents_config[\"entries\"]\n\n            except KeyError:\n                pass\n            else:\n                order_dict = {\n                    element: index\n                    for index, element in enumerate(entried_ordered)\n                }\n                templates_prefix = sorted(\n                    templates_prefix,\n                    key=lambda x: order_dict.get(x, float(\"inf\")),\n                )\n\n        return templates_prefix\n\n    @new_build_prohibit\n    def entry_type_exists(self, entry_type: str) -&gt; bool:\n        \"\"\" \"\"\"\n        entry_types_found: list[str] = self.entry_template_names()\n\n        if entry_type in entry_types_found:\n            return True\n\n        return False\n\n    @new_build_prohibit\n    def entries_all_get(\n        self, entry_type: str\n    ) -&gt; list[str | list[dict[str, Any]]]:\n        \"\"\"Get all of the hazards for the project\n\n        Returns:\n            list[str]: A list of all hazards found for a project.\n        \"\"\"\n        entry_dir: str = f\"{ self.safety_directory }docs/{ entry_type }s/\"\n        entry_entry_dir: str = f\"{ entry_dir }{ entry_type }s/\"\n        entry_file_contents: list[str] = []\n        entries_list: list[str | list[dict[str, Any]]] = []\n        fields: list[dict[str, Any]] = []\n        name: str = \"\"\n        entry_with_attributes: list[dict[str, Any]] = []\n        entry_number: str | None = \"\"\n        # element\n\n        for path, _, files in os.walk(entry_entry_dir):\n            for name in files:\n                if fnmatch(name, \"*.md\"):\n                    entry_file_contents.append(os.path.join(path, name))\n\n        entry_file_contents = sorted(entry_file_contents, reverse=True)\n\n        for file in entry_file_contents:\n            pattern = r\"-([0-9]+)\\.md\"\n            name = \"\"\n\n            matches = re.search(pattern, file)\n\n            # print(matches.group(1))\n            # TODO #50 need to handel a bad file name eg hazard-abc.md\n\n            if matches:\n                entry_number = matches.group(1)\n            else:\n                entry_number = None\n\n            fields = self.entry_file_read(entry_type, file)\n\n            for element in fields:\n                if \"name\" in element[\"heading\"]:\n                    name = element[\"text\"]\n                    break\n\n            entry_with_attributes = [\n                {\n                    \"file\": file,\n                    \"number\": entry_number,\n                    \"name\": name,\n                }\n            ]\n            entry_with_attributes.extend(fields)\n            entries_list.append(entry_with_attributes)\n\n            # print(entries_list)\n        return entries_list\n\n    @new_build_prohibit\n    def form_initial(\n        self, entry_type: str, id: int\n    ) -&gt; dict[str, str | list[str]]:\n        \"\"\"Return data for initialising a django form\n\n        Args:\n            entry_type (str): the data/template type (eg hazard, incident, compliance\n                        sign off).\n            id (int): the id of the type.\n\n        Returns:\n            dict: dictionary of the fields initial values\n        \"\"\"\n        file_path: str = \"\"\n        data: list[dict[str, str]] = []\n        data_initial: dict[str, str | list[str]] = {}\n        selected_options: list[str] = []\n\n        file_path = f\"{ c.PROJECTS_FOLDER }project_{ self.project_id }/{ c.CLINICAL_SAFETY_FOLDER }docs/{ entry_type }s/{ entry_type }s/{ entry_type }-{ id }.md\"\n        template = self.entry_file_read(entry_type)\n        data = self.entry_file_read(entry_type, file_path)\n\n        for field_data in data:\n            for field_template in template:\n                if field_data[\"heading\"] == field_template[\"heading\"]:\n                    if field_template[\"field_type\"] == \"multiselect\":\n                        selected_options = field_data[\"text\"].split(\"\\n\")\n                        data_initial[field_data[\"heading\"]] = selected_options\n\n                    elif field_template[\"field_type\"] == \"code\":\n                        data_initial[field_data[\"heading\"]] = \"&lt;!-- [code] --&gt;\"\n\n                    elif (\n                        field_template[\"field_type\"] != \"horizontal_line\"\n                        and field_template[\"field_type\"] != \"icon\"\n                        and field_template[\"field_type\"] != \"new_line\"\n                    ):\n                        data_initial[field_data[\"heading\"]] = field_data[\n                            \"text\"\n                        ]\n\n        return data_initial\n\n    @new_build_prohibit\n    def document_create_check(self, path: str) -&gt; Tuple[bool, list[str]]:\n        \"\"\"Checks and creates a new document\n\n        Args:\n            path (str): the path (after the /docs/ folder) of the file to be\n                        created.\n\n        Returns;\n            Tuple: bool for if successful or not. String for error messsages.\n        \"\"\"\n        docs_directory = f\"{ c.PROJECTS_FOLDER }project_{ self.project_id }/{ c.CLINICAL_SAFETY_FOLDER }docs/\"\n        successful_creation: bool = True\n        error_messages: list[str] = []\n\n        full_path = Path(docs_directory).joinpath(Path(path))\n\n        if full_path.is_file():\n            successful_creation = False\n            error_messages.append(\"file already exists\")\n\n        return successful_creation, error_messages\n\n    @new_build_prohibit\n    def document_create(self, path: str) -&gt; bool:\n        \"\"\"Creates the document\n\n        Args:\n            path (str): the path (after the /docs/ folder) of the file to be\n                        created.\n\n        Returns;\n            Tuple: bool for if successful or not. String for error messsages.\n        \"\"\"\n        docs_directory = f\"{ c.PROJECTS_FOLDER }project_{ self.project_id }/{ c.CLINICAL_SAFETY_FOLDER }docs/\"\n\n        full_path = Path(docs_directory).joinpath(Path(path))\n        try:\n            open(full_path, \"w\").close()\n        except:\n            return False\n        else:\n            return True\n\n    @new_build_prohibit\n    def documents_list(self) -&gt; list[str]:\n        \"\"\"Returns documents for the project\n\n        Returns a list of documents for the clinical safety project. An entries\n        (eg, hazards, incidences) are removed from this list.\n\n        Returns:\n            list[str]: a list of documents for the project, minus any \"entries\".\n        \"\"\"\n        docs_location = f\"{ c.PROJECTS_FOLDER }project_{ self.project_id }/{ c.CLINICAL_SAFETY_FOLDER }docs/\"\n        excluded_directory: list[str] = self._entry_templates_exclude()\n        exclude: bool = False\n        md_files: list[str] = []\n\n        if not os.path.isdir(docs_location):\n            raise FileNotFoundError(\n                f\"{ docs_location } is not a valid folder location\"\n            )\n\n        for path, dir, files in os.walk(docs_location):\n            for name in files:\n                exclude = False\n                if fnmatch(name, \"*.md\"):\n                    file_full_name = os.path.join(path, name)\n                    file_full_name = file_full_name.replace(docs_location, \"\")\n\n                    for directory in excluded_directory:\n                        if file_full_name.startswith(directory):\n                            exclude = True\n\n                    if not exclude:\n                        md_files.append(file_full_name)\n\n        return md_files\n\n    @new_build_prohibit\n    def _entry_templates_list(self) -&gt; list[str]:\n        \"\"\" \"\"\"\n        entry_templates_location = f\"{ c.PROJECTS_FOLDER }project_{ self.project_id }/{ c.CLINICAL_SAFETY_FOLDER }templates/\"\n        templates: Generator[Path, None, None] = Path(\n            entry_templates_location\n        ).rglob(f\"*{ c.TEMPLATE_SUFFIX }\")\n\n        return [file_path.name for file_path in templates]\n\n    def _entry_templates_exclude(\n        self,\n    ) -&gt; list[str]:\n        \"\"\" \"\"\"\n        directories_to_exclude: list[str] = []\n        templates: list[str] = self._entry_templates_list()\n\n        for template in templates:\n            directories_to_exclude.append(\n                template.replace(c.TEMPLATE_SUFFIX, \"s/\")\n            )\n\n        return directories_to_exclude\n</code></pre>"},{"location":"code/functions/projects_builder/#functions.project_builder.ProjectBuilder.__init__","title":"<code>__init__(project_id=0)</code>","text":"<p>Initialises the ProjectBuilder class</p> <p>Project builder initialiser</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>int</code> <p>the id of the project to be worked on. A value of               0 means a new project is being created.</p> <code>0</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>if project_id is not an integer.</p> <code>ValueError</code> <p>if project_id is not a positive integer</p> Source code in <code>app/dcsp/app/functions/project_builder.py</code> <pre><code>def __init__(\n    self,\n    project_id: int = 0,\n) -&gt; None:\n    \"\"\"Initialises the ProjectBuilder class\n\n    Project builder initialiser\n\n    Args:\n        project_id (int): the id of the project to be worked on. A value of\n                          0 means a new project is being created.\n\n    Raises:\n        TypeError: if project_id is not an integer.\n        ValueError: if project_id is not a positive integer\n    \"\"\"\n    self.new_build_flag: bool = False\n    self.project_id: int = 0\n    self.master_template_directory: str = \"\"\n    self.project_directory: str = \"\"\n    self.safety_directory: str = \"\"\n    self.documents_yaml: str = \"\"\n    self.docs_dir: str = \"\"\n    self.placeholders_yaml: str = \"\"\n    self.entries_templates_dir: str = \"\"\n\n    if not isinstance(project_id, int):\n        raise TypeError(f\"'project_id' '{ project_id }' is not an integer\")\n\n    if project_id == 0:\n        self.new_build_flag = True\n    elif project_id &lt; 0:\n        raise ValueError(\n            f\"'project_id' '{ project_id }' is not a positive integer\"\n        )\n\n    self.project_id = project_id\n    self.master_template_directory = c.MASTER_TEMPLATES\n    self.project_directory = (\n        f\"{ c.PROJECTS_FOLDER }project_{ self.project_id }/\"\n    )\n    self.safety_directory = (\n        f\"{ self.project_directory }{ c.CLINICAL_SAFETY_FOLDER }\"\n    )\n    self.documents_yaml = f\"{ self.safety_directory }documents.yml\"\n    self.docs_dir = f\"{ self.safety_directory }docs/\"\n    self.placeholders_yaml = f\"{ self.safety_directory }placeholders.yml\"\n    self.entries_templates_dir = f\"{ self.safety_directory }templates/\"\n\n    return\n</code></pre>"},{"location":"code/functions/projects_builder/#functions.project_builder.ProjectBuilder.configuration_get","title":"<code>configuration_get()</code>","text":"<p>Returns the configuration settings for the project</p> <p>Reads the setup.ini file in the clinical safety folder and returns the settings.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>dict[str, Any]: a dictionary of the settings.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>if the clinical safety folder does not exist.</p> Source code in <code>app/dcsp/app/functions/project_builder.py</code> <pre><code>@new_build_prohibit\ndef configuration_get(self) -&gt; dict[str, Any]:\n    \"\"\"Returns the configuration settings for the project\n\n    Reads the setup.ini file in the clinical safety folder and returns the\n    settings.\n\n    Returns:\n        dict[str, Any]: a dictionary of the settings.\n\n    Raises:\n        FileNotFoundError: if the clinical safety folder does not exist.\n    \"\"\"\n    configration_file: str = f\"{ self.safety_directory }setup.ini\"\n    config: Optional[ENVManipulator] = None\n\n    if not Path(self.safety_directory).is_dir():\n        raise FileNotFoundError(\n            f\"'{ self.safety_directory }' does not exist\"\n        )\n\n    config = ENVManipulator(configration_file)\n    setup_step: Optional[str] = None\n\n    setup_step = config.read(\"setup_step\")\n\n    # catches negative numbers and non-numeric characters\n    if not setup_step.isdigit():\n        setup_step = \"1\"\n        config.add(\"setup_step\", setup_step)\n\n    return {\"setup_step\": int(setup_step)}\n</code></pre>"},{"location":"code/functions/projects_builder/#functions.project_builder.ProjectBuilder.configuration_set","title":"<code>configuration_set(key, value)</code>","text":"<p>Sets the configuration settings for the project</p> <p>Writes to the setup.ini file in the clinical safety folder.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>the key to be set.</p> required <code>value</code> <code>str</code> <p>the value to be set.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if successful, False if not.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>if the clinical safety folder does not exist.</p> Source code in <code>app/dcsp/app/functions/project_builder.py</code> <pre><code>@new_build_prohibit\ndef configuration_set(self, key: str, value: str) -&gt; bool:\n    \"\"\"Sets the configuration settings for the project\n\n    Writes to the setup.ini file in the clinical safety folder.\n\n    Args:\n        key (str): the key to be set.\n        value (str): the value to be set.\n\n    Returns:\n        bool: True if successful, False if not.\n\n    Raises:\n        FileNotFoundError: if the clinical safety folder does not exist.\n    \"\"\"\n    configration_file: str = f\"{ self.safety_directory }setup.ini\"\n    config: Optional[ENVManipulator] = None\n\n    if not Path(self.safety_directory).is_dir():\n        raise FileNotFoundError(\n            f\"'{ self.safety_directory }' does not exist\"\n        )\n\n    config = ENVManipulator(configration_file)\n\n    config.add(key, str(value))\n    return True\n</code></pre>"},{"location":"code/functions/projects_builder/#functions.project_builder.ProjectBuilder.copy_master_template","title":"<code>copy_master_template(template_chosen)</code>","text":"<p>Copies a master template to the clinical safety folder</p> <p>Copies a master template to the clinical safety folder.</p> <p>Parameters:</p> Name Type Description Default <code>template_chosen</code> <code>str</code> <p>the template to copy across.</p> required <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>if the template chosen does not exist.</p> Source code in <code>app/dcsp/app/functions/project_builder.py</code> <pre><code>@new_build_prohibit\ndef copy_master_template(self, template_chosen: str) -&gt; None:\n    \"\"\"Copies a master template to the clinical safety folder\n\n    Copies a master template to the clinical safety folder.\n\n    Args:\n        template_chosen (str): the template to copy across.\n\n    Raises:\n        FileNotFoundError: if the template chosen does not exist.\n    \"\"\"\n    template_chosen_path: str = (\n        f\"{ self.master_template_directory }{ template_chosen }\"\n    )\n\n    if not Path(template_chosen_path).is_dir():\n        raise FileNotFoundError(\n            f\"'{ template_chosen_path }' does not exist\"\n        )\n\n    shutil.copytree(\n        template_chosen_path,\n        self.safety_directory,\n        dirs_exist_ok=True,\n    )\n    return\n</code></pre>"},{"location":"code/functions/projects_builder/#functions.project_builder.ProjectBuilder.document_create","title":"<code>document_create(path)</code>","text":"<p>Creates the document</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>the path (after the /docs/ folder) of the file to be         created.</p> required <p>Returns;     Tuple: bool for if successful or not. String for error messsages.</p> Source code in <code>app/dcsp/app/functions/project_builder.py</code> <pre><code>@new_build_prohibit\ndef document_create(self, path: str) -&gt; bool:\n    \"\"\"Creates the document\n\n    Args:\n        path (str): the path (after the /docs/ folder) of the file to be\n                    created.\n\n    Returns;\n        Tuple: bool for if successful or not. String for error messsages.\n    \"\"\"\n    docs_directory = f\"{ c.PROJECTS_FOLDER }project_{ self.project_id }/{ c.CLINICAL_SAFETY_FOLDER }docs/\"\n\n    full_path = Path(docs_directory).joinpath(Path(path))\n    try:\n        open(full_path, \"w\").close()\n    except:\n        return False\n    else:\n        return True\n</code></pre>"},{"location":"code/functions/projects_builder/#functions.project_builder.ProjectBuilder.document_create_check","title":"<code>document_create_check(path)</code>","text":"<p>Checks and creates a new document</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>the path (after the /docs/ folder) of the file to be         created.</p> required <p>Returns;     Tuple: bool for if successful or not. String for error messsages.</p> Source code in <code>app/dcsp/app/functions/project_builder.py</code> <pre><code>@new_build_prohibit\ndef document_create_check(self, path: str) -&gt; Tuple[bool, list[str]]:\n    \"\"\"Checks and creates a new document\n\n    Args:\n        path (str): the path (after the /docs/ folder) of the file to be\n                    created.\n\n    Returns;\n        Tuple: bool for if successful or not. String for error messsages.\n    \"\"\"\n    docs_directory = f\"{ c.PROJECTS_FOLDER }project_{ self.project_id }/{ c.CLINICAL_SAFETY_FOLDER }docs/\"\n    successful_creation: bool = True\n    error_messages: list[str] = []\n\n    full_path = Path(docs_directory).joinpath(Path(path))\n\n    if full_path.is_file():\n        successful_creation = False\n        error_messages.append(\"file already exists\")\n\n    return successful_creation, error_messages\n</code></pre>"},{"location":"code/functions/projects_builder/#functions.project_builder.ProjectBuilder.documents_list","title":"<code>documents_list()</code>","text":"<p>Returns documents for the project</p> <p>Returns a list of documents for the clinical safety project. An entries (eg, hazards, incidences) are removed from this list.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: a list of documents for the project, minus any \"entries\".</p> Source code in <code>app/dcsp/app/functions/project_builder.py</code> <pre><code>@new_build_prohibit\ndef documents_list(self) -&gt; list[str]:\n    \"\"\"Returns documents for the project\n\n    Returns a list of documents for the clinical safety project. An entries\n    (eg, hazards, incidences) are removed from this list.\n\n    Returns:\n        list[str]: a list of documents for the project, minus any \"entries\".\n    \"\"\"\n    docs_location = f\"{ c.PROJECTS_FOLDER }project_{ self.project_id }/{ c.CLINICAL_SAFETY_FOLDER }docs/\"\n    excluded_directory: list[str] = self._entry_templates_exclude()\n    exclude: bool = False\n    md_files: list[str] = []\n\n    if not os.path.isdir(docs_location):\n        raise FileNotFoundError(\n            f\"{ docs_location } is not a valid folder location\"\n        )\n\n    for path, dir, files in os.walk(docs_location):\n        for name in files:\n            exclude = False\n            if fnmatch(name, \"*.md\"):\n                file_full_name = os.path.join(path, name)\n                file_full_name = file_full_name.replace(docs_location, \"\")\n\n                for directory in excluded_directory:\n                    if file_full_name.startswith(directory):\n                        exclude = True\n\n                if not exclude:\n                    md_files.append(file_full_name)\n\n    return md_files\n</code></pre>"},{"location":"code/functions/projects_builder/#functions.project_builder.ProjectBuilder.entries_all_get","title":"<code>entries_all_get(entry_type)</code>","text":"<p>Get all of the hazards for the project</p> <p>Returns:</p> Type Description <code>list[str | list[dict[str, Any]]]</code> <p>list[str]: A list of all hazards found for a project.</p> Source code in <code>app/dcsp/app/functions/project_builder.py</code> <pre><code>@new_build_prohibit\ndef entries_all_get(\n    self, entry_type: str\n) -&gt; list[str | list[dict[str, Any]]]:\n    \"\"\"Get all of the hazards for the project\n\n    Returns:\n        list[str]: A list of all hazards found for a project.\n    \"\"\"\n    entry_dir: str = f\"{ self.safety_directory }docs/{ entry_type }s/\"\n    entry_entry_dir: str = f\"{ entry_dir }{ entry_type }s/\"\n    entry_file_contents: list[str] = []\n    entries_list: list[str | list[dict[str, Any]]] = []\n    fields: list[dict[str, Any]] = []\n    name: str = \"\"\n    entry_with_attributes: list[dict[str, Any]] = []\n    entry_number: str | None = \"\"\n    # element\n\n    for path, _, files in os.walk(entry_entry_dir):\n        for name in files:\n            if fnmatch(name, \"*.md\"):\n                entry_file_contents.append(os.path.join(path, name))\n\n    entry_file_contents = sorted(entry_file_contents, reverse=True)\n\n    for file in entry_file_contents:\n        pattern = r\"-([0-9]+)\\.md\"\n        name = \"\"\n\n        matches = re.search(pattern, file)\n\n        # print(matches.group(1))\n        # TODO #50 need to handel a bad file name eg hazard-abc.md\n\n        if matches:\n            entry_number = matches.group(1)\n        else:\n            entry_number = None\n\n        fields = self.entry_file_read(entry_type, file)\n\n        for element in fields:\n            if \"name\" in element[\"heading\"]:\n                name = element[\"text\"]\n                break\n\n        entry_with_attributes = [\n            {\n                \"file\": file,\n                \"number\": entry_number,\n                \"name\": name,\n            }\n        ]\n        entry_with_attributes.extend(fields)\n        entries_list.append(entry_with_attributes)\n\n        # print(entries_list)\n    return entries_list\n</code></pre>"},{"location":"code/functions/projects_builder/#functions.project_builder.ProjectBuilder.entry_exists","title":"<code>entry_exists(entry_type, id)</code>","text":"<p>Checks if an entry of certain type exists</p> <p>Parameters:</p> Name Type Description Default <code>entry_type</code> <code>str</code> <p>named type of entry</p> required <code>id</code> <code>int</code> <p>the id to be assessed if an associated entry exists</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>true if entry is a positive integer and exists.</p> Source code in <code>app/dcsp/app/functions/project_builder.py</code> <pre><code>@new_build_prohibit\ndef entry_exists(self, entry_type: str, id: int) -&gt; bool:\n    \"\"\"Checks if an entry of certain type exists\n\n    Args:\n        entry_type (str): named type of entry\n        id (int): the id to be assessed if an associated entry exists\n\n    Returns:\n        bool: true if entry is a positive integer and exists.\n    \"\"\"\n    directory_to_check: str = f\"{ c.PROJECTS_FOLDER }project_{ self.project_id }/{ c.CLINICAL_SAFETY_FOLDER }docs/{ entry_type }s/{ entry_type }s/\"\n    file_to_find: str = f\"{ entry_type }-{ id }.md\"\n\n    if not isinstance(id, int):\n        raise ValueError(f\"'id' '{ id }' is not an integer\")\n\n    if id &lt; 1:\n        raise ValueError(f\"'id' '{ id }' is not a positive integer\")\n\n    if any(Path(directory_to_check).rglob(file_to_find)):\n        return True\n\n    return False\n</code></pre>"},{"location":"code/functions/projects_builder/#functions.project_builder.ProjectBuilder.entry_file_read","title":"<code>entry_file_read(entry_type, non_template_path='')</code>","text":"<p>Read the contents of either an entry template or entry instance</p> <p>Parameters:</p> Name Type Description Default <code>entry_type</code> <code>str</code> <p>the type of entry (eg hazard or incident)</p> required <code>non_template_path</code> <code>str</code> <p>if empty string, then read template,                      otherwise read contents from file path.</p> <code>''</code> <p>Returns:</p> Type Description <code>list[dict[str, Any]]</code> <p>list[dict[str, Any]]: a dictionary of fields.</p> <p>Raises:</p> Type Description <code>FileExistsError</code> <p>if entry instance or template does not exist.</p> Source code in <code>app/dcsp/app/functions/project_builder.py</code> <pre><code>@new_build_prohibit\ndef entry_file_read(\n    self,\n    entry_type: str,\n    non_template_path: str = \"\",\n) -&gt; list[dict[str, Any]]:\n    \"\"\"Read the contents of either an entry template or entry instance\n\n    Args:\n        entry_type (str): the type of entry (eg hazard or incident)\n        non_template_path (str): if empty string, then read template,\n                                 otherwise read contents from file path.\n\n    Returns:\n        list[dict[str, Any]]: a dictionary of fields.\n\n    Raises:\n        FileExistsError: if entry instance or template does not exist.\n    \"\"\"\n    entry_file_path: str = \"\"\n    lines: list[str] = []\n    line: str = \"\"\n    headed: bool = False\n    heading: str = \"\"\n    content_list: list[dict[str, Any]] = []\n    horizontal_line: str = \"\"\n    br_line: str = \"\"\n    matches: list[str] = []\n    argument: str = \"\"\n    index: int = 0\n    element: dict[str, Any] = {}\n    choice_name: str = \"\"\n    choices_list: list[Any] = []\n    key: str = \"\"\n    value: str = \"\"\n    text_list: list[str] = []\n    choice: str = \"\"\n    choice_split: list[str] = []\n    choices_dict_split: dict[str, str] = {}\n    potential_number: str = \"\"\n\n    if non_template_path == \"\":\n        entry_file_path = f\"{ self.entries_templates_dir }{ entry_type }{ c.ENTRY_TEMPLATE_SUFFIX }\"\n    else:\n        entry_file_path = non_template_path\n\n    if not Path(entry_file_path).is_file():\n        raise FileNotFoundError(f\"'{ entry_file_path }' does not exists\")\n\n    lines = open(entry_file_path, \"r\").read().split(\"\\n\")\n\n    for line in lines:\n        line = line.strip()\n\n        # To match the heading line\n        if re.match(r\"^#\", line):\n            headed = True\n            heading = line\n\n            content_list.append(\n                {\n                    \"field_type\": \"text_area\",  # This is changed later if needed\n                    \"heading\": self._heading_numbering(\n                        heading,\n                        content_list,\n                    ),\n                    \"gui_label\": self._create_gui_label(heading),\n                    \"text\": \"\",\n                }\n            )\n\n        # To match the horizontal line\n        elif re.match(r\"^-\", line):\n            horizontal_line = line\n            headed = False\n\n            content_list.append(\n                {\n                    \"field_type\": \"horizontal_line\",\n                    \"heading\": self._heading_numbering(\n                        horizontal_line,\n                        content_list,\n                    ),\n                }\n            )\n\n        # To match new line tag &lt;br&gt;\n        elif re.match(r\"^&lt;br&gt;\", line):\n            br_line = line\n            headed = False\n\n            content_list.append(\n                {\n                    \"field_type\": \"new_line\",\n                    \"heading\": self._heading_numbering(\n                        br_line,\n                        content_list,\n                    ),\n                }\n            )\n\n        # To match the icon line\n        elif re.match(\n            r\"^&lt;!--\\s*\\[\\s*icon\\s*\\]\\s*--&gt;$\",\n            line,\n        ):\n            headed = False\n\n            content_list.append(\n                {\n                    \"field_type\": \"icon\",\n                    \"heading\": self._heading_numbering(\n                        \"icon\",\n                        content_list,\n                    ),\n                }\n            )\n\n        elif headed and line:\n            # To match for labels\n            if line[0] == \"[\":\n                matches = re.findall(r\"\\[([^\\]]+)\\]\", line)\n                content_list[-1][\"labels\"] = []\n                for argument in matches:\n                    argument = argument.strip()\n                    if argument == \"select\":\n                        content_list[-1][\"field_type\"] = \"select\"\n                    elif argument == \"multiselect\":\n                        content_list[-1][\"field_type\"] = \"multiselect\"\n                    elif argument == \"calculate\":\n                        content_list[-1][\"field_type\"] = \"calculate\"\n                    elif argument == \"readonly\":\n                        content_list[-1][\"field_type\"] = \"readonly\"\n                    elif argument == \"date\":\n                        content_list[-1][\"field_type\"] = \"date\"\n                    elif argument == \"code\":\n                        content_list[-1][\"field_type\"] = \"code\"\n                        # content_list[-1][\"text\"] = \"&lt;!-- [code] --&gt;\"\n                    else:\n                        content_list[-1][\"labels\"].append(argument)\n\n            # If no labels then use as text\n            else:\n                content_list[-1][\"text\"] += f\"{ line.strip() }\\n\"\n\n    for index, element in enumerate(content_list):\n        choice_name = \"\"\n        choices_dict_split = {}\n\n        if element[\"field_type\"] == \"select\":\n            choices_list = [(\"\", \"\")]\n        else:\n            choices_list = []\n\n        for key, value in element.items():\n            if key != \"labels\":\n                content_list[index][key] = value.strip()\n\n        if (\n            element[\"field_type\"] == \"select\"\n            or element[\"field_type\"] == \"multiselect\"\n        ):\n            text_list = element[\"text\"].split(\"\\n\")\n\n            for choice in text_list:\n                choice_name = choice.split(\":\")[0]\n                choices_list.append([choice, choice_name])\n                content_list[index][\"choices\"] = tuple(choices_list)\n\n        elif element[\"field_type\"] == \"calculate\":\n            choices_list = element[\"text\"].split(\"\\n\")\n\n            # TODO what what I trying to do here?\n            for choice in choices_list:\n                choice_split = choice.split(\"[\")\n                choices_dict_split[\n                    choice_split[0]\n                ] = f\"[{ choice_split[1] }\"\n\n            content_list[index][\"choices\"] = choices_dict_split\n\n        if \"text\" in element:\n            content_list[index][\"number\"] = []\n            lines = element[\"text\"].split(\"\\n\")\n\n            for line in lines:\n                potential_number = line.split(\n                    c.MKDOCS_TEMPLATE_NUMBER_DELIMITER\n                )[0]\n                potential_number = potential_number.strip()\n                if potential_number.isdigit():\n                    content_list[index][\"number\"].append(potential_number)\n\n    return content_list\n</code></pre>"},{"location":"code/functions/projects_builder/#functions.project_builder.ProjectBuilder.entry_file_read_to_form","title":"<code>entry_file_read_to_form(file_read, icon_html='', code_html='')</code>","text":"Source code in <code>app/dcsp/app/functions/project_builder.py</code> <pre><code>def entry_file_read_to_form(\n    self,\n    file_read: list[dict[str, Any]],\n    icon_html: str = \"\",\n    code_html: str = \"\",\n) -&gt; dict[str, Any]:\n    \"\"\" \"\"\"\n    element: dict[str, Any] = {}\n    entry_form: dict[str, Any] = {}\n    key: str = \"\"\n\n    for element in file_read:\n        if element[\"field_type\"] == \"icon\":\n            # print(\"icon\")\n            # To copy across ' [number]' if present\n            key = element[\"heading\"].replace(\"icon\", \"\")\n            key = f\"&lt;!-- [icon] --&gt;{ key }\"\n            entry_form[key] = f\"{ icon_html }\"\n\n        elif element[\"field_type\"] == \"code\":\n            # print(\"code\")\n            entry_form[\n                element[\"heading\"]\n            ] = f\"&lt;!-- [code] --&gt;\\n{ code_html }\\n&lt;!-- [codeend] --&gt;\"\n\n        elif element[\"field_type\"] == \"horizontal_line\":\n            entry_form[element[\"heading\"]] = \"\"\n\n        # TODO #55 might need to consider updating the file_read to include field_types\n        # only the template gives this information at the moment\n        elif \"number\" in element:\n            entry_form[element[\"heading\"]] = element[\"text\"].replace(\n                \"\\n\", \"\\n\\n\"\n            )\n\n        else:\n            # print(element[\"heading\"])\n            entry_form[element[\"heading\"]] = element[\"text\"]\n\n    return entry_form\n</code></pre>"},{"location":"code/functions/projects_builder/#functions.project_builder.ProjectBuilder.entry_read_with_field_types","title":"<code>entry_read_with_field_types(entry_type, entry_file_path)</code>","text":"<p>Returns an entry instance with field typing</p> <p>Looks up the entry template and the entry instance and matches the fields.</p> <p>Parameters:</p> Name Type Description Default <code>entry_type</code> <code>str</code> <p>the type of entry (eg hazard or incident)</p> required <code>entry_file_path</code> <code>str</code> <p>the path to the entry file</p> required Source code in <code>app/dcsp/app/functions/project_builder.py</code> <pre><code>def entry_read_with_field_types(\n    self,\n    entry_type: str,\n    entry_file_path: str,\n) -&gt; list[dict[str, Any]]:\n    \"\"\"Returns an entry instance with field typing\n\n    Looks up the entry template and the entry instance and matches the\n    fields.\n\n    Args:\n        entry_type (str): the type of entry (eg hazard or incident)\n        entry_file_path (str): the path to the entry file\n    \"\"\"\n    entry_instance: list[dict[str, Any]] = self.entry_file_read(\n        entry_type, entry_file_path\n    )\n    index_entry: int = 0\n    field_entry: dict[str, Any] = {}\n    entry_template: list[dict[str, Any]] = self.entry_file_read(entry_type)\n\n    for index_entry, field_entry in enumerate(entry_instance):\n        for field_template in entry_template:\n            if field_entry[\"heading\"] == field_template[\"heading\"]:\n                entry_instance[index_entry][\"field_type\"] = field_template[\n                    \"field_type\"\n                ]\n\n    return entry_instance\n</code></pre>"},{"location":"code/functions/projects_builder/#functions.project_builder.ProjectBuilder.entry_template_names","title":"<code>entry_template_names()</code>","text":"Source code in <code>app/dcsp/app/functions/project_builder.py</code> <pre><code>@new_build_prohibit\ndef entry_template_names(self) -&gt; list[str]:\n    \"\"\" \"\"\"\n    templates: Generator[Path, None, None] = Path(\n        self.entries_templates_dir\n    ).glob(\"*-template.md\")\n    templates_ls: list[str] = [file.stem for file in templates]\n    templates_prefix: list[str] = []\n    documents_config: dict[str, str] = {}\n\n    for template in templates_ls:\n        templates_prefix.append(str(template).replace(\"-template\", \"\"))\n\n    if Path(self.documents_yaml).is_file():\n        with open(self.documents_yaml, \"r\") as file:\n            documents_config = yaml.safe_load(file)\n        try:\n            entried_ordered = documents_config[\"entries\"]\n\n        except KeyError:\n            pass\n        else:\n            order_dict = {\n                element: index\n                for index, element in enumerate(entried_ordered)\n            }\n            templates_prefix = sorted(\n                templates_prefix,\n                key=lambda x: order_dict.get(x, float(\"inf\")),\n            )\n\n    return templates_prefix\n</code></pre>"},{"location":"code/functions/projects_builder/#functions.project_builder.ProjectBuilder.entry_type_exists","title":"<code>entry_type_exists(entry_type)</code>","text":"Source code in <code>app/dcsp/app/functions/project_builder.py</code> <pre><code>@new_build_prohibit\ndef entry_type_exists(self, entry_type: str) -&gt; bool:\n    \"\"\" \"\"\"\n    entry_types_found: list[str] = self.entry_template_names()\n\n    if entry_type in entry_types_found:\n        return True\n\n    return False\n</code></pre>"},{"location":"code/functions/projects_builder/#functions.project_builder.ProjectBuilder.entry_update","title":"<code>entry_update(form_data, entry_type='hazard', id_new='new')</code>","text":"<p>Create or update entries (eg hazards and incidents)</p> <p>Depending on the value of id_new (a valid int or the str \"new\"), either a new entry will be created or a pre-existing one updated.</p> <p>Parameters:</p> Name Type Description Default <code>form_data</code> <code>dict[str, str]</code> <p>key value pairs of data to be written                         to file</p> required <code>entry_type</code> <code>str</code> <p>type of entry, eg hazard, incident, officer.</p> <code>'hazard'</code> <code>id_new</code> <code>str</code> <p>a valid digit (1 of more) to update an existing entry           or the word \"new\" to create a new one.</p> <code>'new'</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>dict[str, Any]: returns a dictionary of method outcomes.</p> Source code in <code>app/dcsp/app/functions/project_builder.py</code> <pre><code>@new_build_prohibit\ndef entry_update(\n    self,\n    form_data: dict[str, str],\n    entry_type: str = \"hazard\",\n    id_new: str = \"new\",\n) -&gt; dict[str, Any]:\n    \"\"\"Create or update entries (eg hazards and incidents)\n\n    Depending on the value of id_new (a valid int or the str \"new\"), either\n    a new entry will be created or a pre-existing one updated.\n\n    Args:\n        form_data (dict[str, str]): key value pairs of data to be written\n                                    to file\n        entry_type (str): type of entry, eg hazard, incident, officer.\n        id_new (str): a valid digit (1 of more) to update an existing entry\n                      or the word \"new\" to create a new one.\n\n    Returns:\n        dict[str, Any]: returns a dictionary of method outcomes.\n    \"\"\"\n    entries_directory: str = f\"{ c.PROJECTS_FOLDER }project_{ self.project_id }/{ c.CLINICAL_SAFETY_FOLDER }docs/{ entry_type }s/{ entry_type }s/\"\n    files_to_check: list[str] = []\n    filename: str = \"\"\n    match: Optional[re.Match[str]] = None\n    extracted_number: int = 0\n    numbers: list[int] = []\n    entry_file: Optional[TextIO] = None\n    id_int: int = 0\n    to_write: str = \"\"\n    entry_name: str = \"\"\n\n    if not Path(entries_directory).is_dir():\n        Path(entries_directory).mkdir(parents=True, exist_ok=True)\n\n    # files_to_check = [f.name for f in Path(entries_directory).rglob('*.md')]\n    for path, _, files in os.walk(entries_directory):\n        for name in files:\n            if fnmatch(name, \"*.md\"):\n                files_to_check.append(name)\n\n    if id_new == \"new\":\n        if files_to_check:\n            for filename in files_to_check:\n                match = re.search(r\"-(\\d+)\\.md\", filename)\n                if match:\n                    extracted_number = int(match.group(1))\n                    numbers.append(extracted_number)\n            # what happens if numbers is an empty list?\n            id_int = max(numbers) + 1\n        else:\n            id_int = 1\n\n    elif id_new.isdigit() and self.entry_exists(entry_type, int(id_new)):\n        id_int = int(id_new)\n    else:\n        return {\n            \"pass\": False,\n        }\n\n    entry_file = open(\n        f\"{ entries_directory }{ entry_type }-{ id_int }.md\",\n        \"w\",\n    )\n\n    for key, value in form_data.items():\n        to_write = re.sub(r\"\\s*\\[\\d+\\]$\", \"\", key)\n        if to_write == \"icon\":\n            entry_file.write(\"&lt;!-- [icon] --&gt;\\n\")\n        else:\n            entry_file.write(f\"{ to_write }\\n\")\n\n        if isinstance(value, list):\n            for item in value:\n                entry_file.write(f\"{ item }\\n\\n\")\n        else:\n            entry_file.write(f\"{ value }\\n\\n\")\n    entry_file.close()\n\n    # TODO #54 need to get ride of the 404 in this none view.py code\n    project_timestamp(self.project_id)\n    \"\"\"project = get_object_or_404(Project, id=self.project_id)\n    project.last_modified = timezone.now()\n    project.save()\"\"\"\n\n    for key, value in form_data.items():\n        if \"name\" in key.lower():\n            entry_name = value\n            break\n\n    return {\n        \"pass\": True,\n        \"id\": id_int,\n        \"name\": entry_name,\n        \"entries_url\": f\"{ entry_type }s/{ entry_type }s/{ entry_type }-{ id_int }.html\",\n    }\n</code></pre>"},{"location":"code/functions/projects_builder/#functions.project_builder.ProjectBuilder.form_initial","title":"<code>form_initial(entry_type, id)</code>","text":"<p>Return data for initialising a django form</p> <p>Parameters:</p> Name Type Description Default <code>entry_type</code> <code>str</code> <p>the data/template type (eg hazard, incident, compliance         sign off).</p> required <code>id</code> <code>int</code> <p>the id of the type.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict[str, str | list[str]]</code> <p>dictionary of the fields initial values</p> Source code in <code>app/dcsp/app/functions/project_builder.py</code> <pre><code>@new_build_prohibit\ndef form_initial(\n    self, entry_type: str, id: int\n) -&gt; dict[str, str | list[str]]:\n    \"\"\"Return data for initialising a django form\n\n    Args:\n        entry_type (str): the data/template type (eg hazard, incident, compliance\n                    sign off).\n        id (int): the id of the type.\n\n    Returns:\n        dict: dictionary of the fields initial values\n    \"\"\"\n    file_path: str = \"\"\n    data: list[dict[str, str]] = []\n    data_initial: dict[str, str | list[str]] = {}\n    selected_options: list[str] = []\n\n    file_path = f\"{ c.PROJECTS_FOLDER }project_{ self.project_id }/{ c.CLINICAL_SAFETY_FOLDER }docs/{ entry_type }s/{ entry_type }s/{ entry_type }-{ id }.md\"\n    template = self.entry_file_read(entry_type)\n    data = self.entry_file_read(entry_type, file_path)\n\n    for field_data in data:\n        for field_template in template:\n            if field_data[\"heading\"] == field_template[\"heading\"]:\n                if field_template[\"field_type\"] == \"multiselect\":\n                    selected_options = field_data[\"text\"].split(\"\\n\")\n                    data_initial[field_data[\"heading\"]] = selected_options\n\n                elif field_template[\"field_type\"] == \"code\":\n                    data_initial[field_data[\"heading\"]] = \"&lt;!-- [code] --&gt;\"\n\n                elif (\n                    field_template[\"field_type\"] != \"horizontal_line\"\n                    and field_template[\"field_type\"] != \"icon\"\n                    and field_template[\"field_type\"] != \"new_line\"\n                ):\n                    data_initial[field_data[\"heading\"]] = field_data[\n                        \"text\"\n                    ]\n\n    return data_initial\n</code></pre>"},{"location":"code/functions/projects_builder/#functions.project_builder.ProjectBuilder.get_placeholders","title":"<code>get_placeholders()</code>","text":"<p>Returns the placeholders found in markdown files</p> <p>Searches the docs folder for markdown files and extracts all placeholders.</p> <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>dic[str,str]: a dictionary with the placeholder name as the key and the           value set to an empty string if no previously stored           placeholders, or updated to stored values if they are           available. Uses ninja2 formating, eg {{ placeholder }}.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>if no files found in the docs folder.</p> Source code in <code>app/dcsp/app/functions/project_builder.py</code> <pre><code>@new_build_prohibit\ndef get_placeholders(self) -&gt; dict[str, str]:\n    \"\"\"Returns the placeholders found in markdown files\n\n    Searches the docs folder for markdown files and extracts all placeholders.\n\n    Returns:\n        dic[str,str]: a dictionary with the placeholder name as the key and the\n                      value set to an empty string if no previously stored\n                      placeholders, or updated to stored values if they are\n                      available. Uses ninja2 formating, eg {{ placeholder }}.\n\n    Raises:\n        FileNotFoundError: if no files found in the docs folder.\n    \"\"\"\n\n    files_to_check: list[str] = []\n    file_path: str = \"\"\n    file: Optional[TextIO] = None\n    doc_Regex: Optional[Pattern[str]] = None\n    placeholders_sub: list[str] = []\n    placeholder: str = \"\"\n    placeholders_raw: list[str] = []\n    stored_placeholders: dict[str, str] = {}\n    placeholders_clean: dict[str, str] = {}\n\n    files_to_check = [str(p) for p in Path(self.docs_dir).rglob(\"*.md\")]\n\n    if not len(files_to_check):\n        raise FileNotFoundError(\n            f\"No files found in mkdocs '{ self.docs_dir }' folder\"\n        )\n\n    for file_path in files_to_check:\n        file = open(file_path, \"r\")\n        doc_Regex = re.compile(r\"\\{\\{.*?\\}\\}\", flags=re.S)\n        placeholders_sub = doc_Regex.findall(file.read())\n        for placeholder in placeholders_sub:\n            if placeholder not in placeholders_raw:\n                placeholders_raw.append(placeholder)\n        file.close()\n\n    if Path(self.placeholders_yaml).exists():\n        stored_placeholders = self.read_placeholders()\n\n    for placeholder in placeholders_raw:\n        placeholder = placeholder.replace(\"{{\", \"\")\n        placeholder = placeholder.replace(\"}}\", \"\")\n        placeholder = placeholder.strip()\n        placeholders_clean[placeholder] = stored_placeholders.get(\n            placeholder, \"\"\n        )\n    return placeholders_clean\n</code></pre>"},{"location":"code/functions/projects_builder/#functions.project_builder.ProjectBuilder.master_template_get","title":"<code>master_template_get()</code>","text":"<p>Get the different types of master templates available</p> <p>Looks in the master template folder for template subfolders. Technically a template is a collection of markdown and yaml files.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: a list of templates in alphabetical order.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>if no template subfolder found in templates main                folder.</p> Source code in <code>app/dcsp/app/functions/project_builder.py</code> <pre><code>def master_template_get(self) -&gt; list[str]:\n    \"\"\"Get the different types of master templates available\n\n    Looks in the master template folder for template subfolders. Technically\n    a template is a collection of markdown and yaml files.\n\n    Returns:\n        list[str]: a list of templates in alphabetical order.\n\n    Raises:\n        FileNotFoundError: if no template subfolder found in templates main\n                           folder.\n    \"\"\"\n    templates: list[str] = []\n\n    templates = [\n        directory.name\n        for directory in Path(self.master_template_directory).iterdir()\n        if directory.is_dir()\n    ]\n\n    if not templates:\n        raise FileNotFoundError(\n            f\"No templates folders found in '{ self.master_template_directory }' template directory\"\n        )\n\n    return sorted(templates, key=str.lower)\n</code></pre>"},{"location":"code/functions/projects_builder/#functions.project_builder.ProjectBuilder.new_build","title":"<code>new_build(request)</code>","text":"<p>Creates a new project and associated files</p> <p>This function creates a new project and associated files. It also creates a new project in the database.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>HttpRequest</code> <p>the request object</p> required <p>Returns:</p> Type Description <code>None</code> <p>Tuple[bool, str]: True when successful build. String is a list of               errors, if present.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>User id could not be converted to an integer</p> <code>KeyError</code> <p>'setup_choice' not set</p> <code>ValueError</code> <p>'setup_choice' is incorrectly set</p> <code>KeyError</code> <p>'external_repository_username_import' not set</p> <code>KeyError</code> <p>'external_repository_password_token_import' not set</p> <code>KeyError</code> <p>'external_repository_url_import' not set</p> <code>RepositoryAccessException</code> <p>if the repository does not exist or is not                        accessible</p> <code>NotImplementedError</code> <p>Code for other external repositories is not yet                  written.</p> <code>FileExistsError</code> <p>if the project directory already exists</p> Source code in <code>app/dcsp/app/functions/project_builder.py</code> <pre><code>def new_build(self, request: HttpRequest) -&gt; None:\n    \"\"\"Creates a new project and associated files\n\n    This function creates a new project and associated files. It also creates a\n    new project in the database.\n\n    Args:\n        request (HttpRequest): the request object\n\n    Returns:\n        Tuple[bool, str]: True when successful build. String is a list of\n                          errors, if present.\n\n    Raises:\n        ValueError: User id could not be converted to an integer\n        KeyError: 'setup_choice' not set\n        ValueError: 'setup_choice' is incorrectly set\n        KeyError: 'external_repository_username_import' not set\n        KeyError: 'external_repository_password_token_import' not set\n        KeyError: 'external_repository_url_import' not set\n        RepositoryAccessException: if the repository does not exist or is not\n                                   accessible\n        NotImplementedError: Code for other external repositories is not yet\n                             written.\n        FileExistsError: if the project directory already exists\n    \"\"\"\n    user_id: int = 0\n    inputs = request.session[\"inputs\"]\n    new_project: Project\n    group_id: int = 0\n    github_controller: GitHubController\n    new_user_project_attribute: UserProjectAttribute\n    new_project_directory: str = \"\"\n    new_safety_directory: str = \"\"\n\n    if not isinstance(request.user.id, int):\n        raise ValueError(\"User id could not be converted to an integer\")\n\n    user_id = int(request.user.id)\n\n    if not \"setup_choice\" in inputs:\n        raise KeyError(\"'setup_choice' not set\")\n\n    if (\n        inputs[\"setup_choice\"] != \"start_anew\"\n        and inputs[\"setup_choice\"] != \"import\"\n    ):\n        raise ValueError(\"'setup_choice' is incorrectly set\")\n\n    if inputs[\"setup_choice\"] == \"import\":\n        if not \"external_repository_username_import\" in inputs:\n            raise KeyError(\"'external_repository_username_import' not set\")\n        if not \"external_repository_password_token_import\" in inputs:\n            raise KeyError(\n                \"'external_repository_password_token_import' not set\"\n            )\n        if not \"external_repository_url_import\" in inputs:\n            raise KeyError(\"'external_repository_url_import' not set\")\n\n    if inputs[\"setup_choice\"] == \"import\":\n        if inputs[\"repository_type\"] == \"github\":\n            github_controller = GitHubController(\n                inputs[\"external_repository_username_import\"],\n                inputs[\"external_repository_password_token_import\"],\n            )\n            if not github_controller.repository_exists(\n                inputs[\"external_repository_url_import\"]\n            ):\n                raise RepositoryAccessException(\n                    inputs[\"external_repository_url_import\"]\n                )\n\n        else:\n            # TODO #44\n            raise NotImplementedError(\n                \"Code for other external repositories is not yet written.\",\n            )\n\n    # Database record creation\n    new_project = Project()\n    new_project.name = inputs[\"project_name\"]\n    new_project.description = inputs[\"description\"]\n    new_project.access = inputs[\"access\"]\n    new_project.owner = User.objects.get(id=user_id)\n\n    if inputs[\"setup_choice\"] == \"import\":\n        new_project.external_repository_url = inputs[\n            \"external_repository_url_import\"\n        ]\n\n    new_project.save()\n    new_project.member.set(User.objects.filter(id__in=inputs[\"members\"]))\n    new_project.save()\n\n    request.session[\"project_id\"] = new_project.id\n\n    new_user_project_attribute = UserProjectAttribute()\n    new_user_project_attribute.user = User.objects.get(id=user_id)\n    new_user_project_attribute.project = new_project\n\n    if inputs[\"setup_choice\"] == \"import\":\n        new_user_project_attribute.repository_username = inputs[\n            \"external_repository_username_import\"\n        ]\n        new_user_project_attribute.repository_password_token = inputs[\n            \"external_repository_password_token_import\"\n        ]\n\n    new_user_project_attribute.save()\n\n    for group_id in map(int, inputs[\"groups\"]):\n        group = ProjectGroup.objects.get(id=group_id)\n        group.project_access.add(new_project)\n        group.save()\n\n    new_project_directory = (\n        f\"{ c.PROJECTS_FOLDER }project_{ new_project.id }/\"\n    )\n    new_safety_directory = (\n        f\"{ new_project_directory }{ c.CLINICAL_SAFETY_FOLDER }\"\n    )\n\n    if Path(new_project_directory).is_dir():\n        raise FileExistsError(\n            f\"'{ new_project_directory }' already exists\",\n        )\n\n    Path(new_project_directory).mkdir(parents=True, exist_ok=True)\n\n    if inputs[\"setup_choice\"] == \"import\":\n        git_controller = GitController()\n        git_controller.clone(\n            inputs[\"external_repository_url_import\"],\n            new_project_directory,\n        )\n\n    if not Path(new_safety_directory).is_dir():\n        Path(new_safety_directory).mkdir(parents=True, exist_ok=True)\n\n    return\n</code></pre>"},{"location":"code/functions/projects_builder/#functions.project_builder.ProjectBuilder.new_build_prohibit","title":"<code>new_build_prohibit(func)</code>  <code>staticmethod</code>","text":"<p>A decorator checking if a method can be used</p> <p>If used, this decorator only allows a method to be used if a project_id is 1 or more.</p> <p>Functions:</p> Name Description <code>wrapper</code> <p>to check if a method can be used</p> Source code in <code>app/dcsp/app/functions/project_builder.py</code> <pre><code>@staticmethod\ndef new_build_prohibit(func: Callable[..., Any]) -&gt; Callable[..., Any]:\n    \"\"\"A decorator checking if a method can be used\n\n    If used, this decorator only allows a method to be used if a project_id\n    is 1 or more.\n\n    functions:\n        wrapper: to check if a method can be used\n    \"\"\"\n\n    @wraps(func)\n    def wrapper(self: \"ProjectBuilder\", *args: Any, **kwargs: Any) -&gt; Any:\n        \"\"\"Wraps around the page function.\n\n        Args:\n            request (HttpRequest):\n            project_id (str): datanase primary key for project\n\n        Returns:\n            HttpResponse | func: error responses or runs func.\n\n        Raises:\n            SyntaxError: if the function is not allowed for a new-build project\n        \"\"\"\n        if self.new_build_flag:\n            raise SyntaxError(\n                \"This function is not allowed for a new-build project (with no primary key)\"\n            )\n\n        return func(self, *args, **kwargs)\n\n    return wrapper\n</code></pre>"},{"location":"code/functions/projects_builder/#functions.project_builder.ProjectBuilder.read_placeholders","title":"<code>read_placeholders()</code>","text":"<p>Read placeholders from yaml file</p> <p>Reads already stored placeholder values as stored in placeholders.yml.</p> <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>dict[str,str]: placeholder names and value pairs.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>if placeholder yaml is not a valid file.</p> <code>ValueError</code> <p>if error reading content of yaml file (eg no 'extra'         key).</p> Source code in <code>app/dcsp/app/functions/project_builder.py</code> <pre><code>@new_build_prohibit\ndef read_placeholders(self) -&gt; dict[str, str]:\n    \"\"\"Read placeholders from yaml file\n\n    Reads already stored placeholder values as stored in placeholders.yml.\n\n    Returns:\n        dict[str,str]: placeholder names and value pairs.\n\n    Raises:\n        FileNotFoundError: if placeholder yaml is not a valid file.\n        ValueError: if error reading content of yaml file (eg no 'extra'\n                    key).\n    \"\"\"\n    placeholders_extra: dict[str, dict[str, str]] = {}\n    file: Optional[TextIO] = None\n    return_dict: dict[str, str] = {}\n\n    if not Path(self.placeholders_yaml).is_file():\n        raise FileNotFoundError(\n            f\"'{ self.placeholders_yaml }' is not a valid path\"\n        )\n\n    with open(self.placeholders_yaml, \"r\") as file:\n        placeholders_extra = yaml.safe_load(file)\n\n    try:\n        return_dict = placeholders_extra[\"extra\"]\n    except:\n        raise ValueError(\n            \"Error with placeholders yaml file, likely 'extra' missing from file\"\n        )\n    return return_dict\n</code></pre>"},{"location":"code/functions/projects_builder/#functions.project_builder.ProjectBuilder.save_placeholders","title":"<code>save_placeholders(placeholders)</code>","text":"<p>Saves placeholders to yaml file</p> <p>Saves the placeholders, supplied as a dictionary, into the placeholders.yml file in the clinical safety folder.</p> <p>Parameters:</p> Name Type Description Default <code>placeholders</code> <code>dict[str, str]</code> <p>dictionary of placeholders. Key is name                           of placeholder and value is the value.</p> required <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>if the safety directory does not exist.</p> Source code in <code>app/dcsp/app/functions/project_builder.py</code> <pre><code>@new_build_prohibit\ndef save_placeholders(self, placeholders: dict[str, str]) -&gt; None:\n    \"\"\"Saves placeholders to yaml file\n\n    Saves the placeholders, supplied as a dictionary, into the\n    placeholders.yml file in the clinical safety folder.\n\n    Args:\n        placeholders (dict[str,str]): dictionary of placeholders. Key is name\n                                      of placeholder and value is the value.\n\n    Raises:\n        FileNotFoundError: if the safety directory does not exist.\n    \"\"\"\n    placeholders_extra: dict[str, dict[str, str]] = {\"extra\": placeholders}\n    file: Optional[TextIO] = None\n\n    if not Path(self.safety_directory).is_dir():\n        raise FileNotFoundError(\n            f\"'{ self.safety_directory }' does not exist\"\n        )\n\n    with open(self.placeholders_yaml, \"w\") as file:\n        yaml.dump(placeholders_extra, file)\n    return\n</code></pre>"},{"location":"code/functions/projects_builder/#functions.project_builder.ProjectBuilder.save_placeholders_from_form","title":"<code>save_placeholders_from_form(form)</code>","text":"<p>Saves placeholders to yaml</p> <p>Saves the placeholders, as supplied via a web form. Note that get_placeholders can raise a FileNotFoundError if no files found in the docs folder and save_placeholders can raise a FileNotFoundError if the safety directory does not exist.</p> <p>Parameters:</p> Name Type Description Default <code>form</code> <code>dict[str, str]</code> <p>dictionary of placeholders.</p> required Source code in <code>app/dcsp/app/functions/project_builder.py</code> <pre><code>def save_placeholders_from_form(self, form: PlaceholdersForm) -&gt; None:\n    \"\"\"Saves placeholders to yaml\n\n    Saves the placeholders, as supplied via a web form. Note that\n    get_placeholders can raise a FileNotFoundError if no files found in the\n    docs folder and save_placeholders can raise a FileNotFoundError if the\n    safety directory does not exist.\n\n    Args:\n        form (dict[str,str]): dictionary of placeholders.\n    \"\"\"\n    placeholders: dict[str, str] = self.get_placeholders()\n\n    for placeholder in placeholders:\n        placeholders[placeholder] = form.cleaned_data.get(placeholder, \"\")\n\n    self.save_placeholders(placeholders)\n    return\n</code></pre>"},{"location":"code/functions/projects_builder/#functions.project_builder.ProjectBuilder.test_no_wrapper","title":"<code>test_no_wrapper()</code>","text":"<p>Do not alter this function.</p> <p>Used for testing the new_build_prohibit decorator.</p> Source code in <code>app/dcsp/app/functions/project_builder.py</code> <pre><code>def test_no_wrapper(self) -&gt; None:\n    \"\"\"Do not alter this function.\n\n    Used for testing the new_build_prohibit decorator.\n    \"\"\"\n    return\n</code></pre>"},{"location":"code/functions/projects_builder/#functions.project_builder.ProjectBuilder.test_with_wrapper","title":"<code>test_with_wrapper()</code>","text":"<p>Do not alter this function (or decorator).</p> <p>Used for testing the new_build_prohibit decorator.</p> Source code in <code>app/dcsp/app/functions/project_builder.py</code> <pre><code>@new_build_prohibit\ndef test_with_wrapper(self) -&gt; None:\n    \"\"\"Do not alter this function (or decorator).\n\n    Used for testing the new_build_prohibit decorator.\n    \"\"\"\n    return\n</code></pre>"},{"location":"code/functions/text_manipulation/","title":"Text manipulation","text":"<p>Module for text manipulation functions.</p> <p>This module contains functions for manipulating text.</p> <p>Functions:</p> Name Description <code>snake_to_sentense</code> <p>str) -&gt; str: snake to title conversion</p> <code>kebab_to_sentense</code> <p>str) -&gt; str: kebab to title conversion</p> <code>list_to_string</code> <p>list[str]) -&gt; str: list to string conversion</p>"},{"location":"code/functions/text_manipulation/#functions.text_manipulation.kebab_to_sentense","title":"<code>kebab_to_sentense(kebab_text)</code>","text":"<p>Convert kebab case text to title case text.</p> <p>Convert kebab case text to title case text. The first letter of the first word is capitalized and the rest of the words are in lower case.</p> <p>Parameters:</p> Name Type Description Default <code>kebab_text</code> <code>str</code> <p>The kebab case text to convert to title case.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The title case text.</p> Source code in <code>app/dcsp/app/functions/text_manipulation.py</code> <pre><code>def kebab_to_sentense(kebab_text: str) -&gt; str:\n    \"\"\"Convert kebab case text to title case text.\n\n    Convert kebab case text to title case text. The first letter of the first\n    word is capitalized and the rest of the words are in lower case.\n\n    Args:\n        kebab_text (str): The kebab case text to convert to title case.\n\n    Returns:\n        str: The title case text.\n    \"\"\"\n    if kebab_text.startswith(\"-\"):\n        kebab_text = kebab_text[1:]\n\n    kebab_text = kebab_text.replace(\"--\", \"-\")\n\n    words = kebab_text.split(\"-\")\n    title_text = \" \".join(words).capitalize()\n    title_text = title_text.strip()\n    return title_text\n</code></pre>"},{"location":"code/functions/text_manipulation/#functions.text_manipulation.list_to_string","title":"<code>list_to_string(list_to_convert)</code>","text":"<p>Convert a list to a string</p> <p>Take a list of strings and convert it to a string.</p> <p>Parameters:</p> Name Type Description Default <code>list_to_convert</code> <code>list[str]</code> <p>The list to convert to a string.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>String of the list items.</p> Source code in <code>app/dcsp/app/functions/text_manipulation.py</code> <pre><code>def list_to_string(list_to_convert: list[str]) -&gt; str:\n    \"\"\"Convert a list to a string\n\n    Take a list of strings and convert it to a string.\n\n    Args:\n        list_to_convert (list[str]): The list to convert to a string.\n\n    Returns:\n        str: String of the list items.\n    \"\"\"\n    if len(list_to_convert) == 0:\n        return \"\"\n    elif len(list_to_convert) == 1:\n        return list_to_convert[0]\n    else:\n        return \", \".join(list_to_convert[:-1]) + \" and \" + list_to_convert[-1]\n</code></pre>"},{"location":"code/functions/text_manipulation/#functions.text_manipulation.snake_to_sentense","title":"<code>snake_to_sentense(snake_text)</code>","text":"<p>Convert snake case text to title case text.</p> <p>Convert snake case text to title case text. The first letter of the first word is capitalized and the rest of the words are in lower case.</p> <p>Parameters:</p> Name Type Description Default <code>snake_text</code> <code>str</code> <p>The snake case text to convert to title case.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The title case text.</p> Source code in <code>app/dcsp/app/functions/text_manipulation.py</code> <pre><code>def snake_to_sentense(snake_text: str) -&gt; str:\n    \"\"\"Convert snake case text to title case text.\n\n    Convert snake case text to title case text. The first letter of the first\n    word is capitalized and the rest of the words are in lower case.\n\n    Args:\n        snake_text (str): The snake case text to convert to title case.\n\n    Returns:\n        str: The title case text.\n    \"\"\"\n    if snake_text.startswith(\"_\"):\n        snake_text = snake_text[1:]\n\n    snake_text = snake_text.replace(\"__\", \"_\")\n    words = snake_text.split(\"_\")\n    title_text = \" \".join(words).capitalize()\n    title_text = title_text.strip()\n    return title_text\n</code></pre>"},{"location":"how-tos/","title":"Overview","text":""},{"location":"how-tos/#structure-of-clinical-safety-documentation","title":"Structure of clinical safety documentation","text":"<p>Each instance of clincal safety documenation on DCSP is treated as a 'Project'. A project may or may not have source code. Within each project you will find a single set of safety 'Documents'. These safety documents are built from 'Templates' written in markdown. Each usage of a template is termed an 'Entry'. This can be viewed as follows:</p> <p>Project -&gt; Documents -&gt; Templates -&gt; Entry</p>"},{"location":"how-tos/#minimum-files","title":"Minimum files","text":"<ul> <li>An <code>index.md</code> in the <code>docs</code> folder</li> </ul>"},{"location":"how-tos/install-dcsp/","title":"How to install the DCSP app on a local instance","text":""},{"location":"how-tos/install-dcsp/#prerequisites","title":"Prerequisites","text":"<ul> <li>A computer with resources that can manage a docker container running a web app</li> <li>Docker</li> <li>A text editor</li> <li>A command line interface</li> </ul>"},{"location":"how-tos/install-dcsp/#installing","title":"Installing","text":"<p>There are three separate docker-compose files to chose from. There are development, CICD pipeline for testing purposes and also a production docker-compose files. These are called:</p> <ul> <li>docker-compose-dev.yml</li> <li>docker-compose-cicd.yml</li> <li>docker-compose-prod.yml</li> </ul> <p>The docker container</p> <ul> <li>docker-compose-prod-certbot.yml</li> </ul> <p>is used only once when initially setting up the production environment on a new production server.</p>"},{"location":"how-tos/install-dcsp/#development-environment","title":"Development environment","text":"<ul> <li>Clone the repository from https://github.com/digital-clinical-safety-alliance/digital-clinical-safety-platform.</li> <li><code>cd</code> into the root folder of the repository.</li> <li>Copy, paste and rename the .env_example to .env_dev</li> <li>Edit the environment file as needed</li> <li>Run the below command</li> </ul> <p><code>$ docker compose -f docker-compose-dev.yml up</code></p> <p>And then</p> <p><code>docker compose -f docker-compose-dev.yml exec -it dcsp-docs-builder-dev python3 dcsp/manage.py migrate</code></p> <p>And then</p> <p><code>docker compose -f docker-compose-dev.yml exec -it dcsp-docs-builder-dev python3 dcsp/manage.py createsuperuser</code></p> <ul> <li>You should be up and running.</li> <li>Use can use the below command to open a command line within the main container</li> </ul> <p><code>$ docker exec -it dcsp-docs-builder-dev bash</code></p>"},{"location":"how-tos/install-dcsp/#cicd-environment","title":"CICD environment","text":"<ul> <li>You should not routinely need to run the CICD environment on your devlopment environment, but you may wish to for testing before using GitHub actions.</li> <li>Clone the repository from https://github.com/digital-clinical-safety-alliance/digital-clinical-safety-platform (if not already done)</li> <li><code>cd</code> into the root folder of the repository.</li> <li>Copy, paste and rename the .env_example to .env_cicd</li> <li>Edit the environment file as needed</li> <li>Run the below command</li> </ul> <p><code>$ docker compose -f docker-compose-cicd.yml up</code></p> <ul> <li>You should be up and running.</li> <li>Use the below command to open a command line within the main container</li> </ul> <p><code>$ docker exec -it dcsp-docs-builder-cicd bash</code></p>"},{"location":"how-tos/install-dcsp/#development-environment_1","title":"Development environment","text":"<ul> <li>Clone the repository from https://github.com/digital-clinical-safety-alliance/digital-clinical-safety-platform (if not already done).</li> <li><code>cd</code> into the root folder of the repository.</li> <li>Copy, paste and rename the .env_example to .env_prod</li> <li>Edit the environment file as needed</li> <li>Run the below command to get your first certbot certificate from letsencrypt</li> </ul> <p><code>$ docker compose -f docker-compose-prod-certbot.yml up</code></p> <ul> <li>Next, run the below command</li> </ul> <p><code>$ docker compose -f docker-compose-prod.yml up</code></p> <ul> <li>Use the below command to open a command line within the main container</li> </ul> <p><code>$ docker exec -it dcsp-docs-builder-prod bash</code></p> <ul> <li>Edit the cron daemon file (this can be done with crontab -e which normally opens a Vim instance).</li> <li> <p>Add the below job to the file</p> <p>0 0,12 * * * cd /src/digital-clinical-safety-platform &amp;&amp; sh crontab-certbot.sh</p> </li> <li> <p>And that should be the production site up and running</p> </li> </ul>"},{"location":"how-tos/template-building/","title":"How to build templates for DCSP","text":"<p>Outlined below are methods for creating the different templates needed for clinical safety documentation.</p>"},{"location":"how-tos/template-building/#how-to-build-an-entry-template","title":"How to build an entry template","text":"<ul> <li>Entries are instances of items that you wish to log. For example a hazard or incident.</li> <li>Place in 'CS-documents/templates/[entry name]-template.md'</li> <li>Do not use front matter (material between two treble hashes ('---'))</li> <li>Headings can use any number hashtags (#)</li> <li>The first heading with the word 'name' (case insensitive) in it will be used as the field name</li> <li>Under the heading, the following attributes can be used to change the field type:<ul> <li>[select] - simple, single selection field on the building site</li> <li>[multiselect] - a multiselect field on building site</li> <li>[calculate] - calculates a view result based on other 'labelled' fields (discussed in more detail below).</li> <li>[any_other_values] - used as labels for [calculate] to use.</li> <li>no labels - a simple textarea is used on the building site</li> </ul> </li> <li> <p>Numbering should be done as</p> <p>1 - Line wording 2 - More line wording</p> </li> <li> <p>Do not use 1. 2. 3. as this leads to automatically line numbering that you will not want when the markdown files are eventually built.</p> </li> <li>Anything after a semi colon will be removed from the selection field during editing, but will be available for the user to see if they click on the 'More info' help text.</li> <li>You can put placeholders (eg {{ a_placeholder }}) in both the templates and the entry instances.</li> </ul>"},{"location":"how-tos/template-building/#how-are-calculate-fields-calculated","title":"How are calculate fields calculated","text":"<p>Calculated fields use the values of other 'laballed' fields. These 'labelled' fields need to be either a select or multiple select field with a label on the line (under the title) as the select / multiselect attribute: eg</p> <pre><code>[select] [label_name]\n</code></pre> <p>The calculated field needs the attribute [calculate] under the heading and then the labels it is to monitor there after, eg:</p> <pre><code>[calculate] [labelA] [labelB]\n</code></pre> <p>The calculated field should then have a number list (again with \"1 -\" rather than  \"1.\"). At the end of each numbered line, there should be a list of combinations of the monitored fields to match against, a hypthen and then the number of the item in that monitored field, eg:</p> <pre><code>1 - First item [labelA1-labelB1, labelA2-labelB1]\n2 - Second item [labelA3-labelB1, labelA8-labelB1]\netc...\n</code></pre> <p>A javascript script will run each time one of the monitored-labelled field changes and if it matches the values in the monitored fields, it will update the calculated field.</p>"},{"location":"how-tos/template-building/#css","title":"CSS","text":"<p>You need a <code>icon-small</code> and a <code>icon-large</code> CSS definition for the icons used  in the entries. <code>icon-small</code> is used for the summary pages and <code>icon-large</code> is used for the individual entries.</p>"},{"location":"how-tos/template-building/#hazard-summary-page","title":"Hazard summary page","text":"<p>This is a fairly complicated page, and it would be best to follow examples (need a link).</p>"},{"location":"how-tos/template-building/#numbering","title":"Numbering","text":"<p>For lists that are used in selection fields, number lines must be of the form:</p> <p><code>number - text</code></p> <p>eg</p> <p>1 - First selection option</p> <p>2 - Second selection option</p>"},{"location":"how-tos/template-building/#hazard-icons","title":"Hazard icons","text":""},{"location":"how-tos/template-building/#incident-templates","title":"Incident templates","text":""},{"location":"how-tos/template-building/#hazard-types","title":"Hazard types","text":""},{"location":"how-tos/template-building/#officer-template","title":"Officer template","text":""},{"location":"how-tos/template-building/#compliance-sign-off-template","title":"Compliance sign off template","text":""},{"location":"how-tos/template-building/#documentsyml","title":"Documents.yml","text":"<p>Under <code>entries</code> add the order you want entries to appear on the Ux. If not supplied  then these are ordered randomly.</p>"}]}